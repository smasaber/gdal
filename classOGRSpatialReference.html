<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>GDAL: OGRSpatialReference Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GDAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="usergroup0.html"><span>Download</span></a></li>
      <li><a href="https://github.com/OSGeo/gdal/issues/"><span>Issue&#160;Tracker</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classOGRSpatialReference.html#pub-methods">Public Member Functions</a> &#124;
<a href="classOGRSpatialReference.html#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classOGRSpatialReference-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">OGRSpatialReference Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class represents an OpenGIS Spatial Reference System, and contains methods for converting between this object organization and well known text (WKT) format.  
 <a href="classOGRSpatialReference.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ogr__spatialref_8h_source.html">ogr_spatialref.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a324654be9d3912fadc73c1cf352916cf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a324654be9d3912fadc73c1cf352916cf">OGRSpatialReference</a> (const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> &amp;)</td></tr>
<tr class="memdesc:a324654be9d3912fadc73c1cf352916cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple copy constructor.  <a href="classOGRSpatialReference.html#a324654be9d3912fadc73c1cf352916cf">More...</a><br /></td></tr>
<tr class="separator:a324654be9d3912fadc73c1cf352916cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7b8cd219d905ae7983052119fe63b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#aef7b8cd219d905ae7983052119fe63b1">OGRSpatialReference</a> (const char *=nullptr)</td></tr>
<tr class="memdesc:aef7b8cd219d905ae7983052119fe63b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classOGRSpatialReference.html#aef7b8cd219d905ae7983052119fe63b1">More...</a><br /></td></tr>
<tr class="separator:aef7b8cd219d905ae7983052119fe63b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1bb4c483a6b7bf1c3fe9de0b7b00e1e"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#af1bb4c483a6b7bf1c3fe9de0b7b00e1e">~OGRSpatialReference</a> ()</td></tr>
<tr class="memdesc:af1bb4c483a6b7bf1c3fe9de0b7b00e1e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a> destructor.  <a href="classOGRSpatialReference.html#af1bb4c483a6b7bf1c3fe9de0b7b00e1e">More...</a><br /></td></tr>
<tr class="separator:af1bb4c483a6b7bf1c3fe9de0b7b00e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b8c92ac66cd8519f7c5f941e307b6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a97b8c92ac66cd8519f7c5f941e307b6a">operator=</a> (const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> &amp;)</td></tr>
<tr class="memdesc:a97b8c92ac66cd8519f7c5f941e307b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="classOGRSpatialReference.html#a97b8c92ac66cd8519f7c5f941e307b6a">More...</a><br /></td></tr>
<tr class="separator:a97b8c92ac66cd8519f7c5f941e307b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b638c33c0a2b53e59fe694f26f8f89c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a4b638c33c0a2b53e59fe694f26f8f89c">Reference</a> ()</td></tr>
<tr class="memdesc:a4b638c33c0a2b53e59fe694f26f8f89c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the reference count by one.  <a href="classOGRSpatialReference.html#a4b638c33c0a2b53e59fe694f26f8f89c">More...</a><br /></td></tr>
<tr class="separator:a4b638c33c0a2b53e59fe694f26f8f89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade185ac8ef1724fea5ec3c0e68eaae81"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#ade185ac8ef1724fea5ec3c0e68eaae81">Dereference</a> ()</td></tr>
<tr class="memdesc:ade185ac8ef1724fea5ec3c0e68eaae81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements the reference count by one.  <a href="classOGRSpatialReference.html#ade185ac8ef1724fea5ec3c0e68eaae81">More...</a><br /></td></tr>
<tr class="separator:ade185ac8ef1724fea5ec3c0e68eaae81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4e29e50d8591aa2c75620367eb2123"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a0b4e29e50d8591aa2c75620367eb2123">GetReferenceCount</a> () const </td></tr>
<tr class="memdesc:a0b4e29e50d8591aa2c75620367eb2123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch current reference count.  <a href="classOGRSpatialReference.html#a0b4e29e50d8591aa2c75620367eb2123">More...</a><br /></td></tr>
<tr class="separator:a0b4e29e50d8591aa2c75620367eb2123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9a8378c266604b9cd09042597a649f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#aef9a8378c266604b9cd09042597a649f">Release</a> ()</td></tr>
<tr class="memdesc:aef9a8378c266604b9cd09042597a649f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements the reference count by one, and destroy if zero.  <a href="classOGRSpatialReference.html#aef9a8378c266604b9cd09042597a649f">More...</a><br /></td></tr>
<tr class="separator:aef9a8378c266604b9cd09042597a649f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859adfd14d3a050337dcda7d5bdd5a79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a859adfd14d3a050337dcda7d5bdd5a79">Clone</a> () const </td></tr>
<tr class="memdesc:a859adfd14d3a050337dcda7d5bdd5a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a duplicate of this <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a>.  <a href="classOGRSpatialReference.html#a859adfd14d3a050337dcda7d5bdd5a79">More...</a><br /></td></tr>
<tr class="separator:a859adfd14d3a050337dcda7d5bdd5a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1e2b108255487f91ae448f5c11f67c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a0c1e2b108255487f91ae448f5c11f67c">CloneGeogCS</a> () const </td></tr>
<tr class="memdesc:a0c1e2b108255487f91ae448f5c11f67c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a duplicate of the GEOGCS node of this <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a> object.  <a href="classOGRSpatialReference.html#a0c1e2b108255487f91ae448f5c11f67c">More...</a><br /></td></tr>
<tr class="separator:a0c1e2b108255487f91ae448f5c11f67c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b61b8f4e029d91aa0de3a5b9f604e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63b61b8f4e029d91aa0de3a5b9f604e7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a63b61b8f4e029d91aa0de3a5b9f604e7">dumpReadable</a> ()</td></tr>
<tr class="memdesc:a63b61b8f4e029d91aa0de3a5b9f604e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump pretty wkt to stdout, mostly for debugging. <br /></td></tr>
<tr class="separator:a63b61b8f4e029d91aa0de3a5b9f604e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596b8e527d66a5054408159f0006fdac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a596b8e527d66a5054408159f0006fdac">exportToWkt</a> (char **) const </td></tr>
<tr class="memdesc:a596b8e527d66a5054408159f0006fdac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert this SRS into WKT format.  <a href="classOGRSpatialReference.html#a596b8e527d66a5054408159f0006fdac">More...</a><br /></td></tr>
<tr class="separator:a596b8e527d66a5054408159f0006fdac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635423e09630b4d31b2fa4259667a4ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a635423e09630b4d31b2fa4259667a4ec">exportToPrettyWkt</a> (char **, int=FALSE) const </td></tr>
<tr class="memdesc:a635423e09630b4d31b2fa4259667a4ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert this SRS into a nicely formatted WKT string for display to a person.  <a href="classOGRSpatialReference.html#a635423e09630b4d31b2fa4259667a4ec">More...</a><br /></td></tr>
<tr class="separator:a635423e09630b4d31b2fa4259667a4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28bd9b81856b6a93861576fff0933bb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a28bd9b81856b6a93861576fff0933bb9">exportToProj4</a> (char **) const </td></tr>
<tr class="memdesc:a28bd9b81856b6a93861576fff0933bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export coordinate system in PROJ.4 format.  <a href="classOGRSpatialReference.html#a28bd9b81856b6a93861576fff0933bb9">More...</a><br /></td></tr>
<tr class="separator:a28bd9b81856b6a93861576fff0933bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91c0f34ebfe6fd08001ced4d805b201"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#ad91c0f34ebfe6fd08001ced4d805b201">exportToPCI</a> (char **, char **, double **) const </td></tr>
<tr class="memdesc:ad91c0f34ebfe6fd08001ced4d805b201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export coordinate system in PCI projection definition.  <a href="classOGRSpatialReference.html#ad91c0f34ebfe6fd08001ced4d805b201">More...</a><br /></td></tr>
<tr class="separator:ad91c0f34ebfe6fd08001ced4d805b201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ab13a2ec4ceffd6f802422f95e8f15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a04ab13a2ec4ceffd6f802422f95e8f15">exportToUSGS</a> (long *, long *, double **, long *) const </td></tr>
<tr class="memdesc:a04ab13a2ec4ceffd6f802422f95e8f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export coordinate system in USGS GCTP projection definition.  <a href="classOGRSpatialReference.html#a04ab13a2ec4ceffd6f802422f95e8f15">More...</a><br /></td></tr>
<tr class="separator:a04ab13a2ec4ceffd6f802422f95e8f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2f21b51f176a0cf6b4a331c3090f46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#aac2f21b51f176a0cf6b4a331c3090f46">exportToXML</a> (char **, const char *=nullptr) const </td></tr>
<tr class="memdesc:aac2f21b51f176a0cf6b4a331c3090f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export coordinate system in XML format.  <a href="classOGRSpatialReference.html#aac2f21b51f176a0cf6b4a331c3090f46">More...</a><br /></td></tr>
<tr class="separator:aac2f21b51f176a0cf6b4a331c3090f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2172f6cf2ea15a417474ef114f91397c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a2172f6cf2ea15a417474ef114f91397c">exportToPanorama</a> (long *, long *, long *, long *, double *) const </td></tr>
<tr class="memdesc:a2172f6cf2ea15a417474ef114f91397c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export coordinate system in "Panorama" GIS projection definition.  <a href="classOGRSpatialReference.html#a2172f6cf2ea15a417474ef114f91397c">More...</a><br /></td></tr>
<tr class="separator:a2172f6cf2ea15a417474ef114f91397c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574b5f221ae0b41bc4f82baeb8ab2f1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a574b5f221ae0b41bc4f82baeb8ab2f1c">exportToERM</a> (char *pszProj, char *pszDatum, char *pszUnits)</td></tr>
<tr class="memdesc:a574b5f221ae0b41bc4f82baeb8ab2f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert coordinate system to ERMapper format.  <a href="classOGRSpatialReference.html#a574b5f221ae0b41bc4f82baeb8ab2f1c">More...</a><br /></td></tr>
<tr class="separator:a574b5f221ae0b41bc4f82baeb8ab2f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2908cd5ca33609844ef0c0ff2186ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a1f2908cd5ca33609844ef0c0ff2186ea">exportToMICoordSys</a> (char **) const </td></tr>
<tr class="memdesc:a1f2908cd5ca33609844ef0c0ff2186ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export coordinate system in Mapinfo style CoordSys format.  <a href="classOGRSpatialReference.html#a1f2908cd5ca33609844ef0c0ff2186ea">More...</a><br /></td></tr>
<tr class="separator:a1f2908cd5ca33609844ef0c0ff2186ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74cfc985bd05404a4c61d2d633a6343"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#ab74cfc985bd05404a4c61d2d633a6343">importFromWkt</a> (char **)</td></tr>
<tr class="memdesc:ab74cfc985bd05404a4c61d2d633a6343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import from WKT string.  <a href="classOGRSpatialReference.html#ab74cfc985bd05404a4c61d2d633a6343">More...</a><br /></td></tr>
<tr class="separator:ab74cfc985bd05404a4c61d2d633a6343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f982e416f26935d5273e36b3a4f673a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a4f982e416f26935d5273e36b3a4f673a">importFromWkt</a> (const char **)</td></tr>
<tr class="memdesc:a4f982e416f26935d5273e36b3a4f673a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import from WKT string.  <a href="classOGRSpatialReference.html#a4f982e416f26935d5273e36b3a4f673a">More...</a><br /></td></tr>
<tr class="separator:a4f982e416f26935d5273e36b3a4f673a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f20dde8674af858f9399f8a7df6460"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a46f20dde8674af858f9399f8a7df6460">importFromWkt</a> (const char *)</td></tr>
<tr class="memdesc:a46f20dde8674af858f9399f8a7df6460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import from WKT string.  <a href="classOGRSpatialReference.html#a46f20dde8674af858f9399f8a7df6460">More...</a><br /></td></tr>
<tr class="separator:a46f20dde8674af858f9399f8a7df6460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a29550373c2c14bd11514641e58e7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#af1a29550373c2c14bd11514641e58e7c">importFromProj4</a> (const char *)</td></tr>
<tr class="memdesc:af1a29550373c2c14bd11514641e58e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import PROJ.4 coordinate string.  <a href="classOGRSpatialReference.html#af1a29550373c2c14bd11514641e58e7c">More...</a><br /></td></tr>
<tr class="separator:af1a29550373c2c14bd11514641e58e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5b8c9a205eedc6b88a14aa0c219969"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a8a5b8c9a205eedc6b88a14aa0c219969">importFromEPSG</a> (int)</td></tr>
<tr class="memdesc:a8a5b8c9a205eedc6b88a14aa0c219969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize SRS based on EPSG GCS or PCS code.  <a href="classOGRSpatialReference.html#a8a5b8c9a205eedc6b88a14aa0c219969">More...</a><br /></td></tr>
<tr class="separator:a8a5b8c9a205eedc6b88a14aa0c219969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa6965a1df98cdc673dfb20697eab613"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#aaa6965a1df98cdc673dfb20697eab613">importFromEPSGA</a> (int)</td></tr>
<tr class="memdesc:aaa6965a1df98cdc673dfb20697eab613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize SRS based on EPSG GCS or PCS code.  <a href="classOGRSpatialReference.html#aaa6965a1df98cdc673dfb20697eab613">More...</a><br /></td></tr>
<tr class="separator:aaa6965a1df98cdc673dfb20697eab613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91af2639702e2793daf93ffe231b577"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#af91af2639702e2793daf93ffe231b577">importFromESRI</a> (char **)</td></tr>
<tr class="memdesc:af91af2639702e2793daf93ffe231b577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import coordinate system from ESRI .prj format(s).  <a href="classOGRSpatialReference.html#af91af2639702e2793daf93ffe231b577">More...</a><br /></td></tr>
<tr class="separator:af91af2639702e2793daf93ffe231b577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4739e78e7e2c81d61bb5fc9d9cdde8ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a4739e78e7e2c81d61bb5fc9d9cdde8ee">importFromPCI</a> (const char *, const char *=nullptr, double *=nullptr)</td></tr>
<tr class="memdesc:a4739e78e7e2c81d61bb5fc9d9cdde8ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import coordinate system from PCI projection definition.  <a href="classOGRSpatialReference.html#a4739e78e7e2c81d61bb5fc9d9cdde8ee">More...</a><br /></td></tr>
<tr class="separator:a4739e78e7e2c81d61bb5fc9d9cdde8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a971615901e5c4a028e6b49fb5918d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a4a971615901e5c4a028e6b49fb5918d9">importFromUSGS</a> (long iProjSys, long iZone, double *padfPrjParams, long iDatum, int nUSGSAngleFormat=<a class="el" href="ogr__spatialref_8h.html#aa98003ee785627b86a8bfc53e309b0bd">USGS_ANGLE_PACKEDDMS</a>)</td></tr>
<tr class="memdesc:a4a971615901e5c4a028e6b49fb5918d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import coordinate system from USGS projection definition.  <a href="classOGRSpatialReference.html#a4a971615901e5c4a028e6b49fb5918d9">More...</a><br /></td></tr>
<tr class="separator:a4a971615901e5c4a028e6b49fb5918d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a534e7d862a17c92a31d821848533c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a6a534e7d862a17c92a31d821848533c8">importFromPanorama</a> (long, long, long, double *)</td></tr>
<tr class="memdesc:a6a534e7d862a17c92a31d821848533c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import coordinate system from "Panorama" GIS projection definition.  <a href="classOGRSpatialReference.html#a6a534e7d862a17c92a31d821848533c8">More...</a><br /></td></tr>
<tr class="separator:a6a534e7d862a17c92a31d821848533c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c754327d7081c25358e1a4a6dcf002"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a84c754327d7081c25358e1a4a6dcf002">importFromOzi</a> (const char *const *papszLines)</td></tr>
<tr class="memdesc:a84c754327d7081c25358e1a4a6dcf002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import coordinate system from OziExplorer projection definition.  <a href="classOGRSpatialReference.html#a84c754327d7081c25358e1a4a6dcf002">More...</a><br /></td></tr>
<tr class="separator:a84c754327d7081c25358e1a4a6dcf002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1d4cf6b5d2e62ca2fd2162dc80624c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a8d1d4cf6b5d2e62ca2fd2162dc80624c">importFromWMSAUTO</a> (const char *pszAutoDef)</td></tr>
<tr class="memdesc:a8d1d4cf6b5d2e62ca2fd2162dc80624c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize from WMSAUTO string.  <a href="classOGRSpatialReference.html#a8d1d4cf6b5d2e62ca2fd2162dc80624c">More...</a><br /></td></tr>
<tr class="separator:a8d1d4cf6b5d2e62ca2fd2162dc80624c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a9b831b90c3984f96f47936b114adb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#ae4a9b831b90c3984f96f47936b114adb">importFromXML</a> (const char *)</td></tr>
<tr class="memdesc:ae4a9b831b90c3984f96f47936b114adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import coordinate system from XML format (GML only currently).  <a href="classOGRSpatialReference.html#ae4a9b831b90c3984f96f47936b114adb">More...</a><br /></td></tr>
<tr class="separator:ae4a9b831b90c3984f96f47936b114adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6daf2b64d379a4484413fc9755cc7f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#ad6daf2b64d379a4484413fc9755cc7f6">importFromDict</a> (const char *pszDict, const char *pszCode)</td></tr>
<tr class="memdesc:ad6daf2b64d379a4484413fc9755cc7f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read SRS from WKT dictionary.  <a href="classOGRSpatialReference.html#ad6daf2b64d379a4484413fc9755cc7f6">More...</a><br /></td></tr>
<tr class="separator:ad6daf2b64d379a4484413fc9755cc7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca72094be024d06925d0e610c298cce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a6ca72094be024d06925d0e610c298cce">importFromURN</a> (const char *)</td></tr>
<tr class="memdesc:a6ca72094be024d06925d0e610c298cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize from OGC URN.  <a href="classOGRSpatialReference.html#a6ca72094be024d06925d0e610c298cce">More...</a><br /></td></tr>
<tr class="separator:a6ca72094be024d06925d0e610c298cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c127a25699d8b59e79866b1167d07b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a6c127a25699d8b59e79866b1167d07b4">importFromCRSURL</a> (const char *)</td></tr>
<tr class="memdesc:a6c127a25699d8b59e79866b1167d07b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize from OGC URL.  <a href="classOGRSpatialReference.html#a6c127a25699d8b59e79866b1167d07b4">More...</a><br /></td></tr>
<tr class="separator:a6c127a25699d8b59e79866b1167d07b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4588813e3034a0d920a5787ff71a32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#aae4588813e3034a0d920a5787ff71a32">importFromERM</a> (const char *pszProj, const char *pszDatum, const char *pszUnits)</td></tr>
<tr class="memdesc:aae4588813e3034a0d920a5787ff71a32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create OGR WKT from ERMapper projection definitions.  <a href="classOGRSpatialReference.html#aae4588813e3034a0d920a5787ff71a32">More...</a><br /></td></tr>
<tr class="separator:aae4588813e3034a0d920a5787ff71a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d00386ac9ce5db2f9b6e651afa442f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a93d00386ac9ce5db2f9b6e651afa442f">importFromUrl</a> (const char *)</td></tr>
<tr class="memdesc:a93d00386ac9ce5db2f9b6e651afa442f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set spatial reference from a URL.  <a href="classOGRSpatialReference.html#a93d00386ac9ce5db2f9b6e651afa442f">More...</a><br /></td></tr>
<tr class="separator:a93d00386ac9ce5db2f9b6e651afa442f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1acf0f6cac3125cc878a99433033c140"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a1acf0f6cac3125cc878a99433033c140">importFromMICoordSys</a> (const char *)</td></tr>
<tr class="memdesc:a1acf0f6cac3125cc878a99433033c140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import Mapinfo style CoordSys definition.  <a href="classOGRSpatialReference.html#a1acf0f6cac3125cc878a99433033c140">More...</a><br /></td></tr>
<tr class="separator:a1acf0f6cac3125cc878a99433033c140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac948450b15fa3d8814ab440b9f705b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#aac948450b15fa3d8814ab440b9f705b7">morphToESRI</a> ()</td></tr>
<tr class="memdesc:aac948450b15fa3d8814ab440b9f705b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert in place to ESRI WKT format.  <a href="classOGRSpatialReference.html#aac948450b15fa3d8814ab440b9f705b7">More...</a><br /></td></tr>
<tr class="separator:aac948450b15fa3d8814ab440b9f705b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad556dfdc04d9ec5f1714fc6b5e0eb6a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#ad556dfdc04d9ec5f1714fc6b5e0eb6a6">morphFromESRI</a> ()</td></tr>
<tr class="memdesc:ad556dfdc04d9ec5f1714fc6b5e0eb6a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert in place from ESRI WKT format.  <a href="classOGRSpatialReference.html#ad556dfdc04d9ec5f1714fc6b5e0eb6a6">More...</a><br /></td></tr>
<tr class="separator:ad556dfdc04d9ec5f1714fc6b5e0eb6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8d997b7830bdbe129272b2dd155476"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a6d8d997b7830bdbe129272b2dd155476">convertToOtherProjection</a> (const char *pszTargetProjection, const char *const *papszOptions=nullptr) const </td></tr>
<tr class="memdesc:a6d8d997b7830bdbe129272b2dd155476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to another equivalent projection.  <a href="classOGRSpatialReference.html#a6d8d997b7830bdbe129272b2dd155476">More...</a><br /></td></tr>
<tr class="separator:a6d8d997b7830bdbe129272b2dd155476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c78a4cb401cccaa82a9e65f1b5d5c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a16c78a4cb401cccaa82a9e65f1b5d5c4">Validate</a> () const </td></tr>
<tr class="memdesc:a16c78a4cb401cccaa82a9e65f1b5d5c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate SRS tokens.  <a href="classOGRSpatialReference.html#a16c78a4cb401cccaa82a9e65f1b5d5c4">More...</a><br /></td></tr>
<tr class="separator:a16c78a4cb401cccaa82a9e65f1b5d5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819badadb4b462e6ce2b4779427fee8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a819badadb4b462e6ce2b4779427fee8e">StripCTParms</a> (<a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> *=nullptr)</td></tr>
<tr class="memdesc:a819badadb4b462e6ce2b4779427fee8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strip OGC CT Parameters.  <a href="classOGRSpatialReference.html#a819badadb4b462e6ce2b4779427fee8e">More...</a><br /></td></tr>
<tr class="separator:a819badadb4b462e6ce2b4779427fee8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff482ab330681678d7baff602389e7fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#aff482ab330681678d7baff602389e7fc">StripVertical</a> ()</td></tr>
<tr class="memdesc:aff482ab330681678d7baff602389e7fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a compound cs into a horizontal CS.  <a href="classOGRSpatialReference.html#aff482ab330681678d7baff602389e7fc">More...</a><br /></td></tr>
<tr class="separator:aff482ab330681678d7baff602389e7fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b29a686944ae51ed924aa5138b45ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#ae1b29a686944ae51ed924aa5138b45ba">FixupOrdering</a> ()</td></tr>
<tr class="memdesc:ae1b29a686944ae51ed924aa5138b45ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Correct parameter ordering to match CT Specification.  <a href="classOGRSpatialReference.html#ae1b29a686944ae51ed924aa5138b45ba">More...</a><br /></td></tr>
<tr class="separator:ae1b29a686944ae51ed924aa5138b45ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429b0446798982c6c19efcb7042a8cbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a429b0446798982c6c19efcb7042a8cbc">Fixup</a> ()</td></tr>
<tr class="memdesc:a429b0446798982c6c19efcb7042a8cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixup as needed.  <a href="classOGRSpatialReference.html#a429b0446798982c6c19efcb7042a8cbc">More...</a><br /></td></tr>
<tr class="separator:a429b0446798982c6c19efcb7042a8cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0747cf1e8d323d69c94d6cb217f4382b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a0747cf1e8d323d69c94d6cb217f4382b">EPSGTreatsAsLatLong</a> () const </td></tr>
<tr class="memdesc:a0747cf1e8d323d69c94d6cb217f4382b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns TRUE if EPSG feels this geographic coordinate system should be treated as having lat/long coordinate ordering.  <a href="classOGRSpatialReference.html#a0747cf1e8d323d69c94d6cb217f4382b">More...</a><br /></td></tr>
<tr class="separator:a0747cf1e8d323d69c94d6cb217f4382b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221dc380de8db4eca44337aa5a157acb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a221dc380de8db4eca44337aa5a157acb">EPSGTreatsAsNorthingEasting</a> () const </td></tr>
<tr class="memdesc:a221dc380de8db4eca44337aa5a157acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns TRUE if EPSG feels this projected coordinate system should be treated as having northing/easting coordinate ordering.  <a href="classOGRSpatialReference.html#a221dc380de8db4eca44337aa5a157acb">More...</a><br /></td></tr>
<tr class="separator:a221dc380de8db4eca44337aa5a157acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485ca347702eea566fc239782a6b74fa"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a485ca347702eea566fc239782a6b74fa">GetAxis</a> (const char *pszTargetKey, int iAxis, <a class="el" href="ogr__srs__api_8h.html#ae247bb1b37409553c72a78bd3b6d65b6">OGRAxisOrientation</a> *peOrientation) const </td></tr>
<tr class="memdesc:a485ca347702eea566fc239782a6b74fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the orientation of one axis.  <a href="classOGRSpatialReference.html#a485ca347702eea566fc239782a6b74fa">More...</a><br /></td></tr>
<tr class="separator:a485ca347702eea566fc239782a6b74fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2298795cd7efad5ff24ebbefa3606c0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a2298795cd7efad5ff24ebbefa3606c0e">SetAxes</a> (const char *pszTargetKey, const char *pszXAxisName, <a class="el" href="ogr__srs__api_8h.html#ae247bb1b37409553c72a78bd3b6d65b6">OGRAxisOrientation</a> eXAxisOrientation, const char *pszYAxisName, <a class="el" href="ogr__srs__api_8h.html#ae247bb1b37409553c72a78bd3b6d65b6">OGRAxisOrientation</a> eYAxisOrientation)</td></tr>
<tr class="memdesc:a2298795cd7efad5ff24ebbefa3606c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the axes for a coordinate system.  <a href="classOGRSpatialReference.html#a2298795cd7efad5ff24ebbefa3606c0e">More...</a><br /></td></tr>
<tr class="separator:a2298795cd7efad5ff24ebbefa3606c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2dca44c9130416bc5ea545ad3378dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd2dca44c9130416bc5ea545ad3378dd"></a>
<a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#afd2dca44c9130416bc5ea545ad3378dd">GetRoot</a> ()</td></tr>
<tr class="memdesc:afd2dca44c9130416bc5ea545ad3378dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return root node. <br /></td></tr>
<tr class="separator:afd2dca44c9130416bc5ea545ad3378dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e995a6bde3c9d81cfe074cbe127994"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42e995a6bde3c9d81cfe074cbe127994"></a>
const <a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a42e995a6bde3c9d81cfe074cbe127994">GetRoot</a> () const </td></tr>
<tr class="memdesc:a42e995a6bde3c9d81cfe074cbe127994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return root node. <br /></td></tr>
<tr class="separator:a42e995a6bde3c9d81cfe074cbe127994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28eeee5688ff6cea07e74ccd4c18a3b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a28eeee5688ff6cea07e74ccd4c18a3b0">SetRoot</a> (<a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> *)</td></tr>
<tr class="memdesc:a28eeee5688ff6cea07e74ccd4c18a3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the root SRS node.  <a href="classOGRSpatialReference.html#a28eeee5688ff6cea07e74ccd4c18a3b0">More...</a><br /></td></tr>
<tr class="separator:a28eeee5688ff6cea07e74ccd4c18a3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529996d77052abd060d95883ad27258d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a529996d77052abd060d95883ad27258d">GetAttrNode</a> (const char *)</td></tr>
<tr class="memdesc:a529996d77052abd060d95883ad27258d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find named node in tree.  <a href="classOGRSpatialReference.html#a529996d77052abd060d95883ad27258d">More...</a><br /></td></tr>
<tr class="separator:a529996d77052abd060d95883ad27258d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f692973b2a388a1046d63290a6900fc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a5f692973b2a388a1046d63290a6900fc">GetAttrNode</a> (const char *) const </td></tr>
<tr class="memdesc:a5f692973b2a388a1046d63290a6900fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find named node in tree.  <a href="classOGRSpatialReference.html#a5f692973b2a388a1046d63290a6900fc">More...</a><br /></td></tr>
<tr class="separator:a5f692973b2a388a1046d63290a6900fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc815e7bd21c1c052304368c0eefe8be"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#acc815e7bd21c1c052304368c0eefe8be">GetAttrValue</a> (const char *, int=0) const </td></tr>
<tr class="memdesc:acc815e7bd21c1c052304368c0eefe8be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch indicated attribute of named node.  <a href="classOGRSpatialReference.html#acc815e7bd21c1c052304368c0eefe8be">More...</a><br /></td></tr>
<tr class="separator:acc815e7bd21c1c052304368c0eefe8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de745a68a65e0471df833b2f930538c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a5de745a68a65e0471df833b2f930538c">SetNode</a> (const char *, const char *)</td></tr>
<tr class="memdesc:a5de745a68a65e0471df833b2f930538c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set attribute value in spatial reference.  <a href="classOGRSpatialReference.html#a5de745a68a65e0471df833b2f930538c">More...</a><br /></td></tr>
<tr class="separator:a5de745a68a65e0471df833b2f930538c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f09586aa8fc5d02ec1aa1bc39e3d3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a38f09586aa8fc5d02ec1aa1bc39e3d3c">SetNode</a> (const char *, double)</td></tr>
<tr class="memdesc:a38f09586aa8fc5d02ec1aa1bc39e3d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set attribute value in spatial reference.  <a href="classOGRSpatialReference.html#a38f09586aa8fc5d02ec1aa1bc39e3d3c">More...</a><br /></td></tr>
<tr class="separator:a38f09586aa8fc5d02ec1aa1bc39e3d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaab3d6e836f93974022bd78e221c4b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#adaab3d6e836f93974022bd78e221c4b4">SetLinearUnitsAndUpdateParameters</a> (const char *pszName, double dfInMeters)</td></tr>
<tr class="memdesc:adaab3d6e836f93974022bd78e221c4b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the linear units for the projection.  <a href="classOGRSpatialReference.html#adaab3d6e836f93974022bd78e221c4b4">More...</a><br /></td></tr>
<tr class="separator:adaab3d6e836f93974022bd78e221c4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2016fee7b234666c5e94d528661e6729"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a2016fee7b234666c5e94d528661e6729">SetLinearUnits</a> (const char *pszName, double dfInMeters)</td></tr>
<tr class="memdesc:a2016fee7b234666c5e94d528661e6729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the linear units for the projection.  <a href="classOGRSpatialReference.html#a2016fee7b234666c5e94d528661e6729">More...</a><br /></td></tr>
<tr class="separator:a2016fee7b234666c5e94d528661e6729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2c45c441de09c329ea0676d4e2e9d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a6a2c45c441de09c329ea0676d4e2e9d8">SetTargetLinearUnits</a> (const char *pszTargetKey, const char *pszName, double dfInMeters)</td></tr>
<tr class="memdesc:a6a2c45c441de09c329ea0676d4e2e9d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the linear units for the projection.  <a href="classOGRSpatialReference.html#a6a2c45c441de09c329ea0676d4e2e9d8">More...</a><br /></td></tr>
<tr class="separator:a6a2c45c441de09c329ea0676d4e2e9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefbcac403652e15cfcb1d864d84a3706"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#aefbcac403652e15cfcb1d864d84a3706">GetLinearUnits</a> (char **) const CPL_WARN_DEPRECATED(&quot;Use GetLinearUnits( const char**) instead&quot;)</td></tr>
<tr class="memdesc:aefbcac403652e15cfcb1d864d84a3706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch linear projection units.  <a href="classOGRSpatialReference.html#aefbcac403652e15cfcb1d864d84a3706">More...</a><br /></td></tr>
<tr class="separator:aefbcac403652e15cfcb1d864d84a3706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c173500813894e627b0bc558a4ea9ff"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a2c173500813894e627b0bc558a4ea9ff">GetLinearUnits</a> (const char **=nullptr) const </td></tr>
<tr class="memdesc:a2c173500813894e627b0bc558a4ea9ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch linear projection units.  <a href="classOGRSpatialReference.html#a2c173500813894e627b0bc558a4ea9ff">More...</a><br /></td></tr>
<tr class="separator:a2c173500813894e627b0bc558a4ea9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9903149d99cf5df66439fbb8f23660d6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a9903149d99cf5df66439fbb8f23660d6">GetTargetLinearUnits</a> (const char *pszTargetKey, char **ppszRetName) const CPL_WARN_DEPRECATED(&quot;Use GetTargetLinearUnits( const char*</td></tr>
<tr class="memdesc:a9903149d99cf5df66439fbb8f23660d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch linear units for target.  <a href="classOGRSpatialReference.html#a9903149d99cf5df66439fbb8f23660d6">More...</a><br /></td></tr>
<tr class="separator:a9903149d99cf5df66439fbb8f23660d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aeac856f32ef82670bda91e6623c110"><td class="memItemLeft" align="right" valign="top">double const char **double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a1aeac856f32ef82670bda91e6623c110">GetTargetLinearUnits</a> (const char *pszTargetKey, const char **ppszRetName=nullptr) const </td></tr>
<tr class="memdesc:a1aeac856f32ef82670bda91e6623c110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch linear units for target.  <a href="classOGRSpatialReference.html#a1aeac856f32ef82670bda91e6623c110">More...</a><br /></td></tr>
<tr class="separator:a1aeac856f32ef82670bda91e6623c110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23784d4bfc74a92ba816edeeab90d225"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a23784d4bfc74a92ba816edeeab90d225">SetAngularUnits</a> (const char *pszName, double dfInRadians)</td></tr>
<tr class="memdesc:a23784d4bfc74a92ba816edeeab90d225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the angular units for the geographic coordinate system.  <a href="classOGRSpatialReference.html#a23784d4bfc74a92ba816edeeab90d225">More...</a><br /></td></tr>
<tr class="separator:a23784d4bfc74a92ba816edeeab90d225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252e7c15b702d638d7e25b8f8f784496"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a252e7c15b702d638d7e25b8f8f784496">GetAngularUnits</a> (char **) const CPL_WARN_DEPRECATED(&quot;Use GetAngularUnits( const char**) instead&quot;)</td></tr>
<tr class="memdesc:a252e7c15b702d638d7e25b8f8f784496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch angular geographic coordinate system units.  <a href="classOGRSpatialReference.html#a252e7c15b702d638d7e25b8f8f784496">More...</a><br /></td></tr>
<tr class="separator:a252e7c15b702d638d7e25b8f8f784496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e333217daf9e7f68d236350422ade5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a25e333217daf9e7f68d236350422ade5">GetAngularUnits</a> (const char **=nullptr) const </td></tr>
<tr class="memdesc:a25e333217daf9e7f68d236350422ade5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch angular geographic coordinate system units.  <a href="classOGRSpatialReference.html#a25e333217daf9e7f68d236350422ade5">More...</a><br /></td></tr>
<tr class="separator:a25e333217daf9e7f68d236350422ade5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27c3dec297c064afa0d29270f374375"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#ad27c3dec297c064afa0d29270f374375">GetPrimeMeridian</a> (char **) const CPL_WARN_DEPRECATED(&quot;Use GetPrimeMeridian( const char**) instead&quot;)</td></tr>
<tr class="memdesc:ad27c3dec297c064afa0d29270f374375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch prime meridian info.  <a href="classOGRSpatialReference.html#ad27c3dec297c064afa0d29270f374375">More...</a><br /></td></tr>
<tr class="separator:ad27c3dec297c064afa0d29270f374375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0c3481848c837f8850389a2f8e9b8c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#aba0c3481848c837f8850389a2f8e9b8c">GetPrimeMeridian</a> (const char **=nullptr) const </td></tr>
<tr class="memdesc:aba0c3481848c837f8850389a2f8e9b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch prime meridian info.  <a href="classOGRSpatialReference.html#aba0c3481848c837f8850389a2f8e9b8c">More...</a><br /></td></tr>
<tr class="separator:aba0c3481848c837f8850389a2f8e9b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764ba5d91530ad721d78ac629c0eaba8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a764ba5d91530ad721d78ac629c0eaba8">IsGeographic</a> () const </td></tr>
<tr class="memdesc:a764ba5d91530ad721d78ac629c0eaba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if geographic coordinate system.  <a href="classOGRSpatialReference.html#a764ba5d91530ad721d78ac629c0eaba8">More...</a><br /></td></tr>
<tr class="separator:a764ba5d91530ad721d78ac629c0eaba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1186e3473d7ac2f81ec2ca5d0c4ec027"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a1186e3473d7ac2f81ec2ca5d0c4ec027">IsProjected</a> () const </td></tr>
<tr class="memdesc:a1186e3473d7ac2f81ec2ca5d0c4ec027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if projected coordinate system.  <a href="classOGRSpatialReference.html#a1186e3473d7ac2f81ec2ca5d0c4ec027">More...</a><br /></td></tr>
<tr class="separator:a1186e3473d7ac2f81ec2ca5d0c4ec027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65d61b89b5b8087433175344d460fd4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#ae65d61b89b5b8087433175344d460fd4">IsGeocentric</a> () const </td></tr>
<tr class="memdesc:ae65d61b89b5b8087433175344d460fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if geocentric coordinate system.  <a href="classOGRSpatialReference.html#ae65d61b89b5b8087433175344d460fd4">More...</a><br /></td></tr>
<tr class="separator:ae65d61b89b5b8087433175344d460fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1820ea6fe590dc39e22b5474464ca02a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a1820ea6fe590dc39e22b5474464ca02a">IsLocal</a> () const </td></tr>
<tr class="memdesc:a1820ea6fe590dc39e22b5474464ca02a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if local coordinate system.  <a href="classOGRSpatialReference.html#a1820ea6fe590dc39e22b5474464ca02a">More...</a><br /></td></tr>
<tr class="separator:a1820ea6fe590dc39e22b5474464ca02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16afe94b0d129c0b47e04a6f8b78bef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#ac16afe94b0d129c0b47e04a6f8b78bef">IsVertical</a> () const </td></tr>
<tr class="memdesc:ac16afe94b0d129c0b47e04a6f8b78bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if vertical coordinate system.  <a href="classOGRSpatialReference.html#ac16afe94b0d129c0b47e04a6f8b78bef">More...</a><br /></td></tr>
<tr class="separator:ac16afe94b0d129c0b47e04a6f8b78bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8b989c98938e6c4e27eeb6f9871936"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a7d8b989c98938e6c4e27eeb6f9871936">IsCompound</a> () const </td></tr>
<tr class="memdesc:a7d8b989c98938e6c4e27eeb6f9871936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if coordinate system is compound.  <a href="classOGRSpatialReference.html#a7d8b989c98938e6c4e27eeb6f9871936">More...</a><br /></td></tr>
<tr class="separator:a7d8b989c98938e6c4e27eeb6f9871936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6df2af4faf5de4af8cc935e9b38be5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a8b6df2af4faf5de4af8cc935e9b38be5">IsSameGeogCS</a> (const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *) const </td></tr>
<tr class="memdesc:a8b6df2af4faf5de4af8cc935e9b38be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do the GeogCS'es match?  <a href="classOGRSpatialReference.html#a8b6df2af4faf5de4af8cc935e9b38be5">More...</a><br /></td></tr>
<tr class="separator:a8b6df2af4faf5de4af8cc935e9b38be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191643d7e707a9b72b33450b225a73a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a191643d7e707a9b72b33450b225a73a2">IsSameGeogCS</a> (const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *, const char *const *papszOptions) const </td></tr>
<tr class="memdesc:a191643d7e707a9b72b33450b225a73a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do the GeogCS'es match?  <a href="classOGRSpatialReference.html#a191643d7e707a9b72b33450b225a73a2">More...</a><br /></td></tr>
<tr class="separator:a191643d7e707a9b72b33450b225a73a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac886436c45b2e7e18c14ed3cb33ee058"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#ac886436c45b2e7e18c14ed3cb33ee058">IsSameVertCS</a> (const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *) const </td></tr>
<tr class="memdesc:ac886436c45b2e7e18c14ed3cb33ee058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do the VertCS'es match?  <a href="classOGRSpatialReference.html#ac886436c45b2e7e18c14ed3cb33ee058">More...</a><br /></td></tr>
<tr class="separator:ac886436c45b2e7e18c14ed3cb33ee058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17fd82b2f58a976a30358b076a2fc966"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a17fd82b2f58a976a30358b076a2fc966">IsSame</a> (const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *) const </td></tr>
<tr class="memdesc:a17fd82b2f58a976a30358b076a2fc966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do these two spatial references describe the same system ?  <a href="classOGRSpatialReference.html#a17fd82b2f58a976a30358b076a2fc966">More...</a><br /></td></tr>
<tr class="separator:a17fd82b2f58a976a30358b076a2fc966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d916c0a06d27eb441f99aaaabbed368"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a1d916c0a06d27eb441f99aaaabbed368">IsSame</a> (const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *, const char *const *papszOptions) const </td></tr>
<tr class="memdesc:a1d916c0a06d27eb441f99aaaabbed368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do these two spatial references describe the same system ?  <a href="classOGRSpatialReference.html#a1d916c0a06d27eb441f99aaaabbed368">More...</a><br /></td></tr>
<tr class="separator:a1d916c0a06d27eb441f99aaaabbed368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d2695768309948130772917b47366b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#ab9d2695768309948130772917b47366b">Clear</a> ()</td></tr>
<tr class="memdesc:ab9d2695768309948130772917b47366b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wipe current definition.  <a href="classOGRSpatialReference.html#ab9d2695768309948130772917b47366b">More...</a><br /></td></tr>
<tr class="separator:ab9d2695768309948130772917b47366b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aad2472b5c38757a3bc606ee048c1c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a3aad2472b5c38757a3bc606ee048c1c7">SetLocalCS</a> (const char *)</td></tr>
<tr class="memdesc:a3aad2472b5c38757a3bc606ee048c1c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the user visible LOCAL_CS name.  <a href="classOGRSpatialReference.html#a3aad2472b5c38757a3bc606ee048c1c7">More...</a><br /></td></tr>
<tr class="separator:a3aad2472b5c38757a3bc606ee048c1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208118581246feb29646acf2ea5d4237"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a208118581246feb29646acf2ea5d4237">SetProjCS</a> (const char *)</td></tr>
<tr class="memdesc:a208118581246feb29646acf2ea5d4237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the user visible PROJCS name.  <a href="classOGRSpatialReference.html#a208118581246feb29646acf2ea5d4237">More...</a><br /></td></tr>
<tr class="separator:a208118581246feb29646acf2ea5d4237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45fc71e8c327e9aa274cb699b16f51ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a45fc71e8c327e9aa274cb699b16f51ef">SetProjection</a> (const char *)</td></tr>
<tr class="memdesc:a45fc71e8c327e9aa274cb699b16f51ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a projection name.  <a href="classOGRSpatialReference.html#a45fc71e8c327e9aa274cb699b16f51ef">More...</a><br /></td></tr>
<tr class="separator:a45fc71e8c327e9aa274cb699b16f51ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af909159bd41fd01ea9b42621dfd5bc18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#af909159bd41fd01ea9b42621dfd5bc18">SetGeocCS</a> (const char *pszGeocName)</td></tr>
<tr class="memdesc:af909159bd41fd01ea9b42621dfd5bc18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the user visible GEOCCS name.  <a href="classOGRSpatialReference.html#af909159bd41fd01ea9b42621dfd5bc18">More...</a><br /></td></tr>
<tr class="separator:af909159bd41fd01ea9b42621dfd5bc18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2997a3a7a33cd740c716c5618ac2c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#afb2997a3a7a33cd740c716c5618ac2c9">SetGeogCS</a> (const char *pszGeogName, const char *pszDatumName, const char *pszEllipsoidName, double dfSemiMajor, double dfInvFlattening, const char *pszPMName=nullptr, double dfPMOffset=0.0, const char *pszUnits=nullptr, double dfConvertToRadians=0.0)</td></tr>
<tr class="memdesc:afb2997a3a7a33cd740c716c5618ac2c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set geographic coordinate system.  <a href="classOGRSpatialReference.html#afb2997a3a7a33cd740c716c5618ac2c9">More...</a><br /></td></tr>
<tr class="separator:afb2997a3a7a33cd740c716c5618ac2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096b8dde4fd2eb475acd376060940b02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a096b8dde4fd2eb475acd376060940b02">SetWellKnownGeogCS</a> (const char *)</td></tr>
<tr class="memdesc:a096b8dde4fd2eb475acd376060940b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a GeogCS based on well known name.  <a href="classOGRSpatialReference.html#a096b8dde4fd2eb475acd376060940b02">More...</a><br /></td></tr>
<tr class="separator:a096b8dde4fd2eb475acd376060940b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0172f9c1d69f347cbe429f7d39a3fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a2f0172f9c1d69f347cbe429f7d39a3fa">CopyGeogCSFrom</a> (const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *poSrcSRS)</td></tr>
<tr class="memdesc:a2f0172f9c1d69f347cbe429f7d39a3fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy GEOGCS from another <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a>.  <a href="classOGRSpatialReference.html#a2f0172f9c1d69f347cbe429f7d39a3fa">More...</a><br /></td></tr>
<tr class="separator:a2f0172f9c1d69f347cbe429f7d39a3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4764cca1641b045a63afa95d01922add"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a4764cca1641b045a63afa95d01922add">SetVertCS</a> (const char *pszVertCSName, const char *pszVertDatumName, int nVertDatumClass=2005)</td></tr>
<tr class="memdesc:a4764cca1641b045a63afa95d01922add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the user visible VERT_CS name.  <a href="classOGRSpatialReference.html#a4764cca1641b045a63afa95d01922add">More...</a><br /></td></tr>
<tr class="separator:a4764cca1641b045a63afa95d01922add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb94a55501d2444b9f93eacd8ff0411"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a6cb94a55501d2444b9f93eacd8ff0411">SetCompoundCS</a> (const char *pszName, const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *poHorizSRS, const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *poVertSRS)</td></tr>
<tr class="memdesc:a6cb94a55501d2444b9f93eacd8ff0411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup a compound coordinate system.  <a href="classOGRSpatialReference.html#a6cb94a55501d2444b9f93eacd8ff0411">More...</a><br /></td></tr>
<tr class="separator:a6cb94a55501d2444b9f93eacd8ff0411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3c6a49533fe457ddc763d699ff8796"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#aec3c6a49533fe457ddc763d699ff8796">SetFromUserInput</a> (const char *)</td></tr>
<tr class="memdesc:aec3c6a49533fe457ddc763d699ff8796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set spatial reference from various text formats.  <a href="classOGRSpatialReference.html#aec3c6a49533fe457ddc763d699ff8796">More...</a><br /></td></tr>
<tr class="separator:aec3c6a49533fe457ddc763d699ff8796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8be55999021cd06a75fb86416097156"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#af8be55999021cd06a75fb86416097156">SetTOWGS84</a> (double, double, double, double=0.0, double=0.0, double=0.0, double=0.0)</td></tr>
<tr class="memdesc:af8be55999021cd06a75fb86416097156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Bursa-Wolf conversion to WGS84.  <a href="classOGRSpatialReference.html#af8be55999021cd06a75fb86416097156">More...</a><br /></td></tr>
<tr class="separator:af8be55999021cd06a75fb86416097156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa947bf7c5c7240d2de30afe11086a19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#aaa947bf7c5c7240d2de30afe11086a19">GetTOWGS84</a> (double *padfCoef, int nCoeff=7) const </td></tr>
<tr class="memdesc:aaa947bf7c5c7240d2de30afe11086a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch TOWGS84 parameters, if available.  <a href="classOGRSpatialReference.html#aaa947bf7c5c7240d2de30afe11086a19">More...</a><br /></td></tr>
<tr class="separator:aaa947bf7c5c7240d2de30afe11086a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b57ccaa09b54707b951d0e4822ce2e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a89b57ccaa09b54707b951d0e4822ce2e">GetSemiMajor</a> (<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> *=nullptr) const </td></tr>
<tr class="memdesc:a89b57ccaa09b54707b951d0e4822ce2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get spheroid semi major axis.  <a href="classOGRSpatialReference.html#a89b57ccaa09b54707b951d0e4822ce2e">More...</a><br /></td></tr>
<tr class="separator:a89b57ccaa09b54707b951d0e4822ce2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2649ebcb99c191ef6ddf36804d129516"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a2649ebcb99c191ef6ddf36804d129516">GetSemiMinor</a> (<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> *=nullptr) const </td></tr>
<tr class="memdesc:a2649ebcb99c191ef6ddf36804d129516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get spheroid semi minor axis.  <a href="classOGRSpatialReference.html#a2649ebcb99c191ef6ddf36804d129516">More...</a><br /></td></tr>
<tr class="separator:a2649ebcb99c191ef6ddf36804d129516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26b093d7901cb5b32e07b15a4247d10"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#aa26b093d7901cb5b32e07b15a4247d10">GetInvFlattening</a> (<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> *=nullptr) const </td></tr>
<tr class="memdesc:aa26b093d7901cb5b32e07b15a4247d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get spheroid inverse flattening.  <a href="classOGRSpatialReference.html#aa26b093d7901cb5b32e07b15a4247d10">More...</a><br /></td></tr>
<tr class="separator:aa26b093d7901cb5b32e07b15a4247d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa631c657f26c904320c8a23534cc5f50"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#aa631c657f26c904320c8a23534cc5f50">GetEccentricity</a> () const </td></tr>
<tr class="memdesc:aa631c657f26c904320c8a23534cc5f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get spheroid eccentricity.  <a href="classOGRSpatialReference.html#aa631c657f26c904320c8a23534cc5f50">More...</a><br /></td></tr>
<tr class="separator:aa631c657f26c904320c8a23534cc5f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28f60794657815a70e673d1d17894db"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#af28f60794657815a70e673d1d17894db">GetSquaredEccentricity</a> () const </td></tr>
<tr class="memdesc:af28f60794657815a70e673d1d17894db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get spheroid squared eccentricity.  <a href="classOGRSpatialReference.html#af28f60794657815a70e673d1d17894db">More...</a><br /></td></tr>
<tr class="separator:af28f60794657815a70e673d1d17894db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6918e6680d8de01c6e435235a8a222c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a6918e6680d8de01c6e435235a8a222c7">SetAuthority</a> (const char *pszTargetKey, const char *pszAuthority, int nCode)</td></tr>
<tr class="memdesc:a6918e6680d8de01c6e435235a8a222c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the authority for a node.  <a href="classOGRSpatialReference.html#a6918e6680d8de01c6e435235a8a222c7">More...</a><br /></td></tr>
<tr class="separator:a6918e6680d8de01c6e435235a8a222c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0373c83927bfd694048da6f79e33ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#acb0373c83927bfd694048da6f79e33ea">AutoIdentifyEPSG</a> ()</td></tr>
<tr class="memdesc:acb0373c83927bfd694048da6f79e33ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set EPSG authority info if possible.  <a href="classOGRSpatialReference.html#acb0373c83927bfd694048da6f79e33ea">More...</a><br /></td></tr>
<tr class="separator:acb0373c83927bfd694048da6f79e33ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb83a2ed838ee5e81a2dba8ac640b63c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#abb83a2ed838ee5e81a2dba8ac640b63c">FindMatches</a> (char **papszOptions, int *pnEntries, int **ppanMatchConfidence) const </td></tr>
<tr class="memdesc:abb83a2ed838ee5e81a2dba8ac640b63c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to identify a match between the passed SRS and a related SRS in a catalog (currently EPSG only)  <a href="classOGRSpatialReference.html#abb83a2ed838ee5e81a2dba8ac640b63c">More...</a><br /></td></tr>
<tr class="separator:abb83a2ed838ee5e81a2dba8ac640b63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aeaacda77ad389d6f0d9ae460c38d7e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a3aeaacda77ad389d6f0d9ae460c38d7e">GetEPSGGeogCS</a> () const </td></tr>
<tr class="memdesc:a3aeaacda77ad389d6f0d9ae460c38d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to establish what the EPSG code for this coordinate systems GEOGCS might be.  <a href="classOGRSpatialReference.html#a3aeaacda77ad389d6f0d9ae460c38d7e">More...</a><br /></td></tr>
<tr class="separator:a3aeaacda77ad389d6f0d9ae460c38d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178f4593ef4ee661f2df9d221feaa803"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a178f4593ef4ee661f2df9d221feaa803">GetAuthorityCode</a> (const char *pszTargetKey) const </td></tr>
<tr class="memdesc:a178f4593ef4ee661f2df9d221feaa803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the authority code for a node.  <a href="classOGRSpatialReference.html#a178f4593ef4ee661f2df9d221feaa803">More...</a><br /></td></tr>
<tr class="separator:a178f4593ef4ee661f2df9d221feaa803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6524f36ace6a7be7b3e2a20790a82f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a3f6524f36ace6a7be7b3e2a20790a82f">GetAuthorityName</a> (const char *pszTargetKey) const </td></tr>
<tr class="memdesc:a3f6524f36ace6a7be7b3e2a20790a82f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the authority name for a node.  <a href="classOGRSpatialReference.html#a3f6524f36ace6a7be7b3e2a20790a82f">More...</a><br /></td></tr>
<tr class="separator:a3f6524f36ace6a7be7b3e2a20790a82f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d2cdae2d6b175051b2f76cb50c84a0"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a12d2cdae2d6b175051b2f76cb50c84a0">GetExtension</a> (const char *pszTargetKey, const char *pszName, const char *pszDefault=nullptr) const </td></tr>
<tr class="memdesc:a12d2cdae2d6b175051b2f76cb50c84a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch extension value.  <a href="classOGRSpatialReference.html#a12d2cdae2d6b175051b2f76cb50c84a0">More...</a><br /></td></tr>
<tr class="separator:a12d2cdae2d6b175051b2f76cb50c84a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca469ce2caecc420cc564e661b8325d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a2ca469ce2caecc420cc564e661b8325d">SetExtension</a> (const char *pszTargetKey, const char *pszName, const char *pszValue)</td></tr>
<tr class="memdesc:a2ca469ce2caecc420cc564e661b8325d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set extension value.  <a href="classOGRSpatialReference.html#a2ca469ce2caecc420cc564e661b8325d">More...</a><br /></td></tr>
<tr class="separator:a2ca469ce2caecc420cc564e661b8325d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5350ca443f5d631d86cc71b1b86977"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#aba5350ca443f5d631d86cc71b1b86977">FindProjParm</a> (const char *pszParameter, const <a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> *poPROJCS=nullptr) const </td></tr>
<tr class="memdesc:aba5350ca443f5d631d86cc71b1b86977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the child index of the named projection parameter on its parent PROJCS node.  <a href="classOGRSpatialReference.html#aba5350ca443f5d631d86cc71b1b86977">More...</a><br /></td></tr>
<tr class="separator:aba5350ca443f5d631d86cc71b1b86977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2027f62b01d61d9aab83629dd86cda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#aaa2027f62b01d61d9aab83629dd86cda">SetProjParm</a> (const char *, double)</td></tr>
<tr class="memdesc:aaa2027f62b01d61d9aab83629dd86cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a projection parameter value.  <a href="classOGRSpatialReference.html#aaa2027f62b01d61d9aab83629dd86cda">More...</a><br /></td></tr>
<tr class="separator:aaa2027f62b01d61d9aab83629dd86cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60d56e89dbcb515a5ee576b02474470"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#ac60d56e89dbcb515a5ee576b02474470">GetProjParm</a> (const char *, double=0.0, <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> *=nullptr) const </td></tr>
<tr class="memdesc:ac60d56e89dbcb515a5ee576b02474470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a projection parameter value.  <a href="classOGRSpatialReference.html#ac60d56e89dbcb515a5ee576b02474470">More...</a><br /></td></tr>
<tr class="separator:ac60d56e89dbcb515a5ee576b02474470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a050293b297acba00bd3da7d71d7ea0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a9a050293b297acba00bd3da7d71d7ea0">SetNormProjParm</a> (const char *, double)</td></tr>
<tr class="memdesc:a9a050293b297acba00bd3da7d71d7ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a projection parameter with a normalized value.  <a href="classOGRSpatialReference.html#a9a050293b297acba00bd3da7d71d7ea0">More...</a><br /></td></tr>
<tr class="separator:a9a050293b297acba00bd3da7d71d7ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41526ef7451dc71f81e1ad3396eb138"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#ae41526ef7451dc71f81e1ad3396eb138">GetNormProjParm</a> (const char *, double=0.0, <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> *=nullptr) const </td></tr>
<tr class="memdesc:ae41526ef7451dc71f81e1ad3396eb138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a normalized projection parameter value.  <a href="classOGRSpatialReference.html#ae41526ef7451dc71f81e1ad3396eb138">More...</a><br /></td></tr>
<tr class="separator:ae41526ef7451dc71f81e1ad3396eb138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a826075cf8aeb97db58f1d505eb3a11cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a826075cf8aeb97db58f1d505eb3a11cb"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a826075cf8aeb97db58f1d505eb3a11cb">SetACEA</a> (double dfStdP1, double dfStdP2, double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:a826075cf8aeb97db58f1d505eb3a11cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Albers Conic Equal Area. <br /></td></tr>
<tr class="separator:a826075cf8aeb97db58f1d505eb3a11cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db1b1a2e484ea9666d5009f19c6437e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9db1b1a2e484ea9666d5009f19c6437e"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a9db1b1a2e484ea9666d5009f19c6437e">SetAE</a> (double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:a9db1b1a2e484ea9666d5009f19c6437e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Azimuthal Equidistant. <br /></td></tr>
<tr class="separator:a9db1b1a2e484ea9666d5009f19c6437e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d789f381ef5a368437e641d20dc82d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29d789f381ef5a368437e641d20dc82d"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a29d789f381ef5a368437e641d20dc82d">SetBonne</a> (double dfStdP1, double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:a29d789f381ef5a368437e641d20dc82d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bonne. <br /></td></tr>
<tr class="separator:a29d789f381ef5a368437e641d20dc82d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00037fe7f593033ba0a4c123d989370b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00037fe7f593033ba0a4c123d989370b"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a00037fe7f593033ba0a4c123d989370b">SetCEA</a> (double dfStdP1, double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:a00037fe7f593033ba0a4c123d989370b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cylindrical Equal Area. <br /></td></tr>
<tr class="separator:a00037fe7f593033ba0a4c123d989370b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d403772226f49e4a16bdc40416809c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d403772226f49e4a16bdc40416809c0"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a3d403772226f49e4a16bdc40416809c0">SetCS</a> (double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:a3d403772226f49e4a16bdc40416809c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cassini-Soldner. <br /></td></tr>
<tr class="separator:a3d403772226f49e4a16bdc40416809c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229e9bfaf27c92f27db454f7186d7efc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a229e9bfaf27c92f27db454f7186d7efc"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a229e9bfaf27c92f27db454f7186d7efc">SetEC</a> (double dfStdP1, double dfStdP2, double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:a229e9bfaf27c92f27db454f7186d7efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equidistant Conic. <br /></td></tr>
<tr class="separator:a229e9bfaf27c92f27db454f7186d7efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d229aa12921f761a3395ddec27f0e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21d229aa12921f761a3395ddec27f0e7"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a21d229aa12921f761a3395ddec27f0e7">SetEckert</a> (int nVariation, double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:a21d229aa12921f761a3395ddec27f0e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eckert I. <br /></td></tr>
<tr class="separator:a21d229aa12921f761a3395ddec27f0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3b337eb75415e39f1b5da45aad11a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a3b337eb75415e39f1b5da45aad11a3"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a1a3b337eb75415e39f1b5da45aad11a3">SetEckertIV</a> (double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:a1a3b337eb75415e39f1b5da45aad11a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eckert IV. <br /></td></tr>
<tr class="separator:a1a3b337eb75415e39f1b5da45aad11a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c566237db4956d279d89b47943639b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c566237db4956d279d89b47943639b2"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a2c566237db4956d279d89b47943639b2">SetEckertVI</a> (double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:a2c566237db4956d279d89b47943639b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eckert VI. <br /></td></tr>
<tr class="separator:a2c566237db4956d279d89b47943639b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c780ca8dc53fc91a99153290cc426a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10c780ca8dc53fc91a99153290cc426a"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a10c780ca8dc53fc91a99153290cc426a">SetEquirectangular</a> (double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:a10c780ca8dc53fc91a99153290cc426a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equirectangular. <br /></td></tr>
<tr class="separator:a10c780ca8dc53fc91a99153290cc426a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4d317d4a4054d9674b14ea0c7401b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c4d317d4a4054d9674b14ea0c7401b6"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a9c4d317d4a4054d9674b14ea0c7401b6">SetEquirectangular2</a> (double dfCenterLat, double dfCenterLong, double dfPseudoStdParallel1, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:a9c4d317d4a4054d9674b14ea0c7401b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equirectangular generalized form : <br /></td></tr>
<tr class="separator:a9c4d317d4a4054d9674b14ea0c7401b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021258d1eb2fbbe819014a52a6f62969"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a021258d1eb2fbbe819014a52a6f62969"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a021258d1eb2fbbe819014a52a6f62969">SetGEOS</a> (double dfCentralMeridian, double dfSatelliteHeight, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:a021258d1eb2fbbe819014a52a6f62969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Geostationary Satellite. <br /></td></tr>
<tr class="separator:a021258d1eb2fbbe819014a52a6f62969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e691c115046b500326fe5aa049f3c3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e691c115046b500326fe5aa049f3c3a"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a8e691c115046b500326fe5aa049f3c3a">SetGH</a> (double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:a8e691c115046b500326fe5aa049f3c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Goode Homolosine. <br /></td></tr>
<tr class="separator:a8e691c115046b500326fe5aa049f3c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbb2cd843017628363f30c9f7c23e21"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2cbb2cd843017628363f30c9f7c23e21"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a2cbb2cd843017628363f30c9f7c23e21">SetIGH</a> ()</td></tr>
<tr class="memdesc:a2cbb2cd843017628363f30c9f7c23e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupted Goode Homolosine. <br /></td></tr>
<tr class="separator:a2cbb2cd843017628363f30c9f7c23e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6524e9752602ddc605093ee1bcecd21b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6524e9752602ddc605093ee1bcecd21b"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a6524e9752602ddc605093ee1bcecd21b">SetGS</a> (double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:a6524e9752602ddc605093ee1bcecd21b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gall Stereograpic. <br /></td></tr>
<tr class="separator:a6524e9752602ddc605093ee1bcecd21b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e633e426cedaa17b757e4b1619f5c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28e633e426cedaa17b757e4b1619f5c3"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a28e633e426cedaa17b757e4b1619f5c3">SetGaussSchreiberTMercator</a> (double dfCenterLat, double dfCenterLong, double dfScale, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:a28e633e426cedaa17b757e4b1619f5c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gauss Schreiber Transverse Mercator. <br /></td></tr>
<tr class="separator:a28e633e426cedaa17b757e4b1619f5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a58ae2d5f8196f50fe10fd7b2b447d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67a58ae2d5f8196f50fe10fd7b2b447d"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a67a58ae2d5f8196f50fe10fd7b2b447d">SetGnomonic</a> (double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:a67a58ae2d5f8196f50fe10fd7b2b447d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gnomonic. <br /></td></tr>
<tr class="separator:a67a58ae2d5f8196f50fe10fd7b2b447d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d13105847002639f0f448167dc922a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a4d13105847002639f0f448167dc922a0">SetHOM</a> (double dfCenterLat, double dfCenterLong, double dfAzimuth, double dfRectToSkew, double dfScale, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:a4d13105847002639f0f448167dc922a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hotine Oblique Mercator.  <a href="classOGRSpatialReference.html#a4d13105847002639f0f448167dc922a0">More...</a><br /></td></tr>
<tr class="separator:a4d13105847002639f0f448167dc922a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66530428642a5e5e16f7791c7474fd21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a66530428642a5e5e16f7791c7474fd21">SetHOM2PNO</a> (double dfCenterLat, double dfLat1, double dfLong1, double dfLat2, double dfLong2, double dfScale, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:a66530428642a5e5e16f7791c7474fd21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hotine Oblique Mercator 2 points.  <a href="classOGRSpatialReference.html#a66530428642a5e5e16f7791c7474fd21">More...</a><br /></td></tr>
<tr class="separator:a66530428642a5e5e16f7791c7474fd21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b34e9b2030ff8b07e14b988db95ab4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a0b34e9b2030ff8b07e14b988db95ab4f">SetHOMAC</a> (double dfCenterLat, double dfCenterLong, double dfAzimuth, double dfRectToSkew, double dfScale, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:a0b34e9b2030ff8b07e14b988db95ab4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hotine Oblique Mercator Azimuth Center / Variant B.  <a href="classOGRSpatialReference.html#a0b34e9b2030ff8b07e14b988db95ab4f">More...</a><br /></td></tr>
<tr class="separator:a0b34e9b2030ff8b07e14b988db95ab4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a555f427030e3bb1b0754a7ab64e826a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a555f427030e3bb1b0754a7ab64e826a3"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a555f427030e3bb1b0754a7ab64e826a3">SetIWMPolyconic</a> (double dfLat1, double dfLat2, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:a555f427030e3bb1b0754a7ab64e826a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">International Map of the World Polyconic. <br /></td></tr>
<tr class="separator:a555f427030e3bb1b0754a7ab64e826a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc48d54196d40a64489b55afa993d2d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc48d54196d40a64489b55afa993d2d7"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#abc48d54196d40a64489b55afa993d2d7">SetKrovak</a> (double dfCenterLat, double dfCenterLong, double dfAzimuth, double dfPseudoStdParallelLat, double dfScale, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:abc48d54196d40a64489b55afa993d2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Krovak Oblique Conic Conformal. <br /></td></tr>
<tr class="separator:abc48d54196d40a64489b55afa993d2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb729026c3ff6e6729c6cab4cd4e7b82"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb729026c3ff6e6729c6cab4cd4e7b82"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#abb729026c3ff6e6729c6cab4cd4e7b82">SetLAEA</a> (double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:abb729026c3ff6e6729c6cab4cd4e7b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lambert Azimuthal Equal-Area. <br /></td></tr>
<tr class="separator:abb729026c3ff6e6729c6cab4cd4e7b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eddea3ec66447a764c0a80e181b224b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6eddea3ec66447a764c0a80e181b224b"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a6eddea3ec66447a764c0a80e181b224b">SetLCC</a> (double dfStdP1, double dfStdP2, double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:a6eddea3ec66447a764c0a80e181b224b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lambert Conformal Conic. <br /></td></tr>
<tr class="separator:a6eddea3ec66447a764c0a80e181b224b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89db924598873ff279cf9cd1f5402c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae89db924598873ff279cf9cd1f5402c7"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#ae89db924598873ff279cf9cd1f5402c7">SetLCC1SP</a> (double dfCenterLat, double dfCenterLong, double dfScale, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:ae89db924598873ff279cf9cd1f5402c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lambert Conformal Conic 1SP. <br /></td></tr>
<tr class="separator:ae89db924598873ff279cf9cd1f5402c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bff5316b8cad210b62a78694a6a4224"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bff5316b8cad210b62a78694a6a4224"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a3bff5316b8cad210b62a78694a6a4224">SetLCCB</a> (double dfStdP1, double dfStdP2, double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:a3bff5316b8cad210b62a78694a6a4224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lambert Conformal Conic (Belgium) <br /></td></tr>
<tr class="separator:a3bff5316b8cad210b62a78694a6a4224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abffbf6b7dade5c4f89461d581ec34f81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abffbf6b7dade5c4f89461d581ec34f81"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#abffbf6b7dade5c4f89461d581ec34f81">SetMC</a> (double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:abffbf6b7dade5c4f89461d581ec34f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Miller Cylindrical. <br /></td></tr>
<tr class="separator:abffbf6b7dade5c4f89461d581ec34f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a165cdfa893a9e621df1e5ba5d584e8ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a165cdfa893a9e621df1e5ba5d584e8ec"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a165cdfa893a9e621df1e5ba5d584e8ec">SetMercator</a> (double dfCenterLat, double dfCenterLong, double dfScale, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:a165cdfa893a9e621df1e5ba5d584e8ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mercator 1SP. <br /></td></tr>
<tr class="separator:a165cdfa893a9e621df1e5ba5d584e8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b19a914a5cf0b24fab1a9ca92bf2cd3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b19a914a5cf0b24fab1a9ca92bf2cd3"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a6b19a914a5cf0b24fab1a9ca92bf2cd3">SetMercator2SP</a> (double dfStdP1, double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:a6b19a914a5cf0b24fab1a9ca92bf2cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mercator 2SP. <br /></td></tr>
<tr class="separator:a6b19a914a5cf0b24fab1a9ca92bf2cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836ae0eb0484b8538b5ebbec51ff549b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a836ae0eb0484b8538b5ebbec51ff549b"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a836ae0eb0484b8538b5ebbec51ff549b">SetMollweide</a> (double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:a836ae0eb0484b8538b5ebbec51ff549b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mollweide. <br /></td></tr>
<tr class="separator:a836ae0eb0484b8538b5ebbec51ff549b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645b8d8ad374866405be723d3925c0eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a645b8d8ad374866405be723d3925c0eb"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a645b8d8ad374866405be723d3925c0eb">SetNZMG</a> (double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:a645b8d8ad374866405be723d3925c0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">New Zealand Map Grid. <br /></td></tr>
<tr class="separator:a645b8d8ad374866405be723d3925c0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9cd1357b9b90b7f614de1a42cc8ee5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b9cd1357b9b90b7f614de1a42cc8ee5"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a6b9cd1357b9b90b7f614de1a42cc8ee5">SetOS</a> (double dfOriginLat, double dfCMeridian, double dfScale, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:a6b9cd1357b9b90b7f614de1a42cc8ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Oblique Stereographic. <br /></td></tr>
<tr class="separator:a6b9cd1357b9b90b7f614de1a42cc8ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60a3f7a4fcd0b2e05b491004f7b4b00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa60a3f7a4fcd0b2e05b491004f7b4b00"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#aa60a3f7a4fcd0b2e05b491004f7b4b00">SetOrthographic</a> (double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:aa60a3f7a4fcd0b2e05b491004f7b4b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orthographic. <br /></td></tr>
<tr class="separator:aa60a3f7a4fcd0b2e05b491004f7b4b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90387616358d7ccfbf021248b63bf55d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90387616358d7ccfbf021248b63bf55d"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a90387616358d7ccfbf021248b63bf55d">SetPolyconic</a> (double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:a90387616358d7ccfbf021248b63bf55d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polyconic. <br /></td></tr>
<tr class="separator:a90387616358d7ccfbf021248b63bf55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ef801c3bece207b4972ad25229e866"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7ef801c3bece207b4972ad25229e866"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#aa7ef801c3bece207b4972ad25229e866">SetPS</a> (double dfCenterLat, double dfCenterLong, double dfScale, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:aa7ef801c3bece207b4972ad25229e866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polar Stereographic. <br /></td></tr>
<tr class="separator:aa7ef801c3bece207b4972ad25229e866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371ea654e13a284a67862674655d930f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a371ea654e13a284a67862674655d930f"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a371ea654e13a284a67862674655d930f">SetRobinson</a> (double dfCenterLong, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:a371ea654e13a284a67862674655d930f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Robinson. <br /></td></tr>
<tr class="separator:a371ea654e13a284a67862674655d930f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3ceed1839820c00a45b31411046446"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d3ceed1839820c00a45b31411046446"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a2d3ceed1839820c00a45b31411046446">SetSinusoidal</a> (double dfCenterLong, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:a2d3ceed1839820c00a45b31411046446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sinusoidal. <br /></td></tr>
<tr class="separator:a2d3ceed1839820c00a45b31411046446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cee263b477072d49648b3320b240f25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7cee263b477072d49648b3320b240f25"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a7cee263b477072d49648b3320b240f25">SetStereographic</a> (double dfCenterLat, double dfCenterLong, double dfScale, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:a7cee263b477072d49648b3320b240f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stereographic. <br /></td></tr>
<tr class="separator:a7cee263b477072d49648b3320b240f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2fd66fae7d41793c750d25070094a8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2fd66fae7d41793c750d25070094a8a"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#ab2fd66fae7d41793c750d25070094a8a">SetSOC</a> (double dfLatitudeOfOrigin, double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:ab2fd66fae7d41793c750d25070094a8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swiss Oblique Cylindrical. <br /></td></tr>
<tr class="separator:ab2fd66fae7d41793c750d25070094a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6822d6fd4dc947ccb89ef4020d7323"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b6822d6fd4dc947ccb89ef4020d7323"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a5b6822d6fd4dc947ccb89ef4020d7323">SetTM</a> (double dfCenterLat, double dfCenterLong, double dfScale, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:a5b6822d6fd4dc947ccb89ef4020d7323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transverse Mercator. <br /></td></tr>
<tr class="separator:a5b6822d6fd4dc947ccb89ef4020d7323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a6fa2ec0371725279c7f11dbe7b98f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#ae3a6fa2ec0371725279c7f11dbe7b98f">SetTMVariant</a> (const char *pszVariantName, double dfCenterLat, double dfCenterLong, double dfScale, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:ae3a6fa2ec0371725279c7f11dbe7b98f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transverse Mercator variants.  <a href="classOGRSpatialReference.html#ae3a6fa2ec0371725279c7f11dbe7b98f">More...</a><br /></td></tr>
<tr class="separator:ae3a6fa2ec0371725279c7f11dbe7b98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe110e083fb4550660ccabe69eaa0c1b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe110e083fb4550660ccabe69eaa0c1b"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#abe110e083fb4550660ccabe69eaa0c1b">SetTMG</a> (double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:abe110e083fb4550660ccabe69eaa0c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tunesia Mining Grid. <br /></td></tr>
<tr class="separator:abe110e083fb4550660ccabe69eaa0c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9060b4d8eadf22e146619c5714dac2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf9060b4d8eadf22e146619c5714dac2"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#abf9060b4d8eadf22e146619c5714dac2">SetTMSO</a> (double dfCenterLat, double dfCenterLong, double dfScale, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:abf9060b4d8eadf22e146619c5714dac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transverse Mercator (South Oriented) <br /></td></tr>
<tr class="separator:abf9060b4d8eadf22e146619c5714dac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ecda5156bdb754ca576509d21d2e1f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ecda5156bdb754ca576509d21d2e1f0"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a9ecda5156bdb754ca576509d21d2e1f0">SetTPED</a> (double dfLat1, double dfLong1, double dfLat2, double dfLong2, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:a9ecda5156bdb754ca576509d21d2e1f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two Point Equidistant. <br /></td></tr>
<tr class="separator:a9ecda5156bdb754ca576509d21d2e1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc0572f3a97a5a9aaad41916b56def9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aefc0572f3a97a5a9aaad41916b56def9"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#aefc0572f3a97a5a9aaad41916b56def9">SetVDG</a> (double dfCenterLong, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:aefc0572f3a97a5a9aaad41916b56def9"><td class="mdescLeft">&#160;</td><td class="mdescRight">VanDerGrinten. <br /></td></tr>
<tr class="separator:aefc0572f3a97a5a9aaad41916b56def9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4f6fcab663c9eb6d465787cad3833c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a0c4f6fcab663c9eb6d465787cad3833c">SetUTM</a> (int nZone, int bNorth=TRUE)</td></tr>
<tr class="memdesc:a0c4f6fcab663c9eb6d465787cad3833c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Universal Transverse Mercator.  <a href="classOGRSpatialReference.html#a0c4f6fcab663c9eb6d465787cad3833c">More...</a><br /></td></tr>
<tr class="separator:a0c4f6fcab663c9eb6d465787cad3833c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a137a1f15ba0d18b84e7fc4104c74cdb9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a137a1f15ba0d18b84e7fc4104c74cdb9">GetUTMZone</a> (int *pbNorth=nullptr) const </td></tr>
<tr class="memdesc:a137a1f15ba0d18b84e7fc4104c74cdb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get utm zone information.  <a href="classOGRSpatialReference.html#a137a1f15ba0d18b84e7fc4104c74cdb9">More...</a><br /></td></tr>
<tr class="separator:a137a1f15ba0d18b84e7fc4104c74cdb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf567c9fe6bb8bfb1d758947a4d5daf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abcf567c9fe6bb8bfb1d758947a4d5daf"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#abcf567c9fe6bb8bfb1d758947a4d5daf">SetWagner</a> (int nVariation, double dfCenterLat, double dfFalseEasting, double dfFalseNorthing)</td></tr>
<tr class="memdesc:abcf567c9fe6bb8bfb1d758947a4d5daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wagner I &ndash; VII. <br /></td></tr>
<tr class="separator:abcf567c9fe6bb8bfb1d758947a4d5daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2618058ab68772b0cd9a2837e613a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c2618058ab68772b0cd9a2837e613a6"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a9c2618058ab68772b0cd9a2837e613a6">SetQSC</a> (double dfCenterLat, double dfCenterLong)</td></tr>
<tr class="memdesc:a9c2618058ab68772b0cd9a2837e613a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quadrilateralized Spherical Cube. <br /></td></tr>
<tr class="separator:a9c2618058ab68772b0cd9a2837e613a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e976715fc475e4dcb5ecb9f74a75475"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e976715fc475e4dcb5ecb9f74a75475"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a7e976715fc475e4dcb5ecb9f74a75475">SetSCH</a> (double dfPegLat, double dfPegLong, double dfPegHeading, double dfPegHgt)</td></tr>
<tr class="memdesc:a7e976715fc475e4dcb5ecb9f74a75475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spherical, Cross-track, Height. <br /></td></tr>
<tr class="separator:a7e976715fc475e4dcb5ecb9f74a75475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0f1e23207c157f72388717c35be88c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a4e0f1e23207c157f72388717c35be88c">SetStatePlane</a> (int nZone, int bNAD83=TRUE, const char *pszOverrideUnitName=nullptr, double dfOverrideUnit=0.0)</td></tr>
<tr class="memdesc:a4e0f1e23207c157f72388717c35be88c"><td class="mdescLeft">&#160;</td><td class="mdescRight">State Plane.  <a href="classOGRSpatialReference.html#a4e0f1e23207c157f72388717c35be88c">More...</a><br /></td></tr>
<tr class="separator:a4e0f1e23207c157f72388717c35be88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef5eb37f913b18ec4253412da99f95e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ef5eb37f913b18ec4253412da99f95e"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a4ef5eb37f913b18ec4253412da99f95e">ImportFromESRIStatePlaneWKT</a> (int nCode, const char *pszDatumName, const char *pszUnitsName, int nPCSCode, const char *pszCSName=nullptr)</td></tr>
<tr class="memdesc:a4ef5eb37f913b18ec4253412da99f95e"><td class="mdescLeft">&#160;</td><td class="mdescRight">ImportFromESRIStatePlaneWKT. <br /></td></tr>
<tr class="separator:a4ef5eb37f913b18ec4253412da99f95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f9b4765ccd95a8361c3b4d13fd5d86"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8f9b4765ccd95a8361c3b4d13fd5d86"></a>
<a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#af8f9b4765ccd95a8361c3b4d13fd5d86">ImportFromESRIWisconsinWKT</a> (const char *pszPrjName, double dfCentralMeridian, double dfLatOfOrigin, const char *pszUnitsName, const char *pszCSName=nullptr)</td></tr>
<tr class="memdesc:af8f9b4765ccd95a8361c3b4d13fd5d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">ImportFromESRIWisconsinWKT. <br /></td></tr>
<tr class="separator:af8f9b4765ccd95a8361c3b4d13fd5d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:adda5434b145cd2728c907e74b795edcf"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#adda5434b145cd2728c907e74b795edcf">DestroySpatialReference</a> (<a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *poSRS)</td></tr>
<tr class="memdesc:adda5434b145cd2728c907e74b795edcf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a> destructor.  <a href="classOGRSpatialReference.html#adda5434b145cd2728c907e74b795edcf">More...</a><br /></td></tr>
<tr class="separator:adda5434b145cd2728c907e74b795edcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9965cec08c4333bd90c81fa13556c45e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a9965cec08c4333bd90c81fa13556c45e">IsAngularParameter</a> (const char *)</td></tr>
<tr class="memdesc:a9965cec08c4333bd90c81fa13556c45e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the passed projection parameter an angular one?  <a href="classOGRSpatialReference.html#a9965cec08c4333bd90c81fa13556c45e">More...</a><br /></td></tr>
<tr class="separator:a9965cec08c4333bd90c81fa13556c45e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5c06ef84e5c97ecf117c81e8058deb"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a1e5c06ef84e5c97ecf117c81e8058deb">IsLongitudeParameter</a> (const char *)</td></tr>
<tr class="memdesc:a1e5c06ef84e5c97ecf117c81e8058deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the passed projection parameter an angular longitude (relative to a prime meridian)?  <a href="classOGRSpatialReference.html#a1e5c06ef84e5c97ecf117c81e8058deb">More...</a><br /></td></tr>
<tr class="separator:a1e5c06ef84e5c97ecf117c81e8058deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7914541a3b475b8e5a8f5ffcf2c247c6"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a7914541a3b475b8e5a8f5ffcf2c247c6">IsLinearParameter</a> (const char *)</td></tr>
<tr class="memdesc:a7914541a3b475b8e5a8f5ffcf2c247c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the passed projection parameter an linear one measured in meters or some similar linear measure.  <a href="classOGRSpatialReference.html#a7914541a3b475b8e5a8f5ffcf2c247c6">More...</a><br /></td></tr>
<tr class="separator:a7914541a3b475b8e5a8f5ffcf2c247c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af960d7b1f894a2d7158bed6086459f01"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#af960d7b1f894a2d7158bed6086459f01">GetWGS84SRS</a> ()</td></tr>
<tr class="memdesc:af960d7b1f894a2d7158bed6086459f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an instance of a SRS object with WGS84 WKT.  <a href="classOGRSpatialReference.html#af960d7b1f894a2d7158bed6086459f01">More...</a><br /></td></tr>
<tr class="separator:af960d7b1f894a2d7158bed6086459f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e6011bfa17da9e2f926a8f500ec31b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a39e6011bfa17da9e2f926a8f500ec31b">ToHandle</a> (<a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *poSRS)</td></tr>
<tr class="memdesc:a39e6011bfa17da9e2f926a8f500ec31b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a OGRSpatialReference* to a OGRSpatialReferenceH.  <a href="classOGRSpatialReference.html#a39e6011bfa17da9e2f926a8f500ec31b">More...</a><br /></td></tr>
<tr class="separator:a39e6011bfa17da9e2f926a8f500ec31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379939d011a31203d0251481b5af07b9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRSpatialReference.html#a379939d011a31203d0251481b5af07b9">FromHandle</a> (<a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a> hSRS)</td></tr>
<tr class="memdesc:a379939d011a31203d0251481b5af07b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a OGRSpatialReferenceH to a OGRSpatialReference*.  <a href="classOGRSpatialReference.html#a379939d011a31203d0251481b5af07b9">More...</a><br /></td></tr>
<tr class="separator:a379939d011a31203d0251481b5af07b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class represents an OpenGIS Spatial Reference System, and contains methods for converting between this object organization and well known text (WKT) format. </p>
<p>This object is reference counted as one instance of the object is normally shared between many <a class="el" href="classOGRGeometry.html" title="Abstract base class for all geometry classes. ">OGRGeometry</a> objects.</p>
<p>Normally application code can fetch needed parameter values for this SRS using <a class="el" href="classOGRSpatialReference.html#acc815e7bd21c1c052304368c0eefe8be" title="Fetch indicated attribute of named node. ">GetAttrValue()</a>, but in special cases the underlying parse tree (or <a class="el" href="classOGR__SRSNode.html" title="Objects of this class are used to represent value nodes in the parsed representation of the WKT SRS f...">OGR_SRSNode</a> objects) can be accessed more directly.</p>
<p>See <a href="osr_tutorial.html">the tutorial</a> for more information on how to use this class.</p>
<p>Consult also the <a href="wktproblems.html">OGC WKT Coordinate System Issues</a> page for implementation details of WKT in OGR. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a324654be9d3912fadc73c1cf352916cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRSpatialReference::OGRSpatialReference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> &amp;&#160;</td>
          <td class="paramname"><em>oOther</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple copy constructor. </p>
<p>See also <a class="el" href="classOGRSpatialReference.html#a859adfd14d3a050337dcda7d5bdd5a79" title="Make a duplicate of this OGRSpatialReference. ">Clone()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oOther</td><td>other spatial reference </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aef7b8cd219d905ae7983052119fe63b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OGRSpatialReference::OGRSpatialReference </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszWKT</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>This constructor takes an optional string argument which if passed should be a WKT representation of an SRS. Passing this is equivalent to not passing it, and then calling <a class="el" href="classOGRSpatialReference.html#ab74cfc985bd05404a4c61d2d633a6343" title="Import from WKT string. ">importFromWkt()</a> with the WKT string.</p>
<p>Note that newly created objects are given a reference count of one.</p>
<p>The C function <a class="el" href="ogr__srs__api_8h.html#a80d2790f618a9800a126e736afb1198e" title="Constructor. ">OSRNewSpatialReference()</a> does the same thing as this constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszWKT</td><td>well known text definition to which the object should be initialized, or NULL (the default). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1bb4c483a6b7bf1c3fe9de0b7b00e1e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OGRSpatialReference::~OGRSpatialReference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a> destructor. </p>
<p>The C function <a class="el" href="ogr__srs__api_8h.html#aa1485e7c17fb7edc15a0dfda63f77333" title="OGRSpatialReference destructor. ">OSRDestroySpatialReference()</a> does the same thing as this method. Preferred C++ method : <a class="el" href="classOGRSpatialReference.html#adda5434b145cd2728c907e74b795edcf" title="OGRSpatialReference destructor. ">OGRSpatialReference::DestroySpatialReference()</a></p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000016">Deprecated:</a></b></dt><dd></dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="acb0373c83927bfd694048da6f79e33ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::AutoIdentifyEPSG </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set EPSG authority info if possible. </p>
<p>This method inspects a WKT definition, and adds EPSG authority nodes where an aspect of the coordinate system can be easily and safely corresponded with an EPSG identifier. In practice, this method will evolve over time. In theory it can add authority nodes for any object (i.e. spheroid, datum, GEOGCS, units, and PROJCS) that could have an authority node. Mostly this is useful to inserting appropriate PROJCS codes for common formulations (like UTM n WGS84).</p>
<p>If it success the <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a> is updated in place, and the method return OGRERR_NONE. If the method fails to identify the general coordinate system OGRERR_UNSUPPORTED_SRS is returned but no error message is posted via <a class="el" href="cpl__error_8h.html#afda4d86428c1c533449ae6a69cdf430d" title="Report an error. ">CPLError()</a>.</p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#a8870b1853254904c8517b945fe7204c3" title="Set EPSG authority info if possible. ">OSRAutoIdentifyEPSG()</a>.</p>
<p>Since GDAL 2.3, the <a class="el" href="classOGRSpatialReference.html#abb83a2ed838ee5e81a2dba8ac640b63c" title="Try to identify a match between the passed SRS and a related SRS in a catalog (currently EPSG only) ...">FindMatches()</a> method can also be used for improved matching by researching the EPSG catalog.</p>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE or OGRERR_UNSUPPORTED_SRS. </dd></dl>

</div>
</div>
<a class="anchor" id="ab9d2695768309948130772917b47366b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRSpatialReference::Clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wipe current definition. </p>
<p>Returns <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a> to a state with no definition, as it exists when first created. It does not affect reference counts. </p>

</div>
</div>
<a class="anchor" id="a859adfd14d3a050337dcda7d5bdd5a79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> * OGRSpatialReference::Clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a duplicate of this <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a>. </p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#af2ba3f2974ec67d6b9f971301387613b" title="Make a duplicate of this OGRSpatialReference. ">OSRClone()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a new SRS, which becomes the responsibility of the caller. </dd></dl>

</div>
</div>
<a class="anchor" id="a0c1e2b108255487f91ae448f5c11f67c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> * OGRSpatialReference::CloneGeogCS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a duplicate of the GEOGCS node of this <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a> object. </p>
<dl class="section return"><dt>Returns</dt><dd>a new SRS, which becomes the responsibility of the caller. </dd></dl>

</div>
</div>
<a class="anchor" id="a6d8d997b7830bdbe129272b2dd155476"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> * OGRSpatialReference::convertToOtherProjection </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszTargetProjection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to another equivalent projection. </p>
<p>Currently implemented: </p><ul>
<li>
SRS_PT_MERCATOR_1SP to SRS_PT_MERCATOR_2SP </li>
<li>
SRS_PT_MERCATOR_2SP to SRS_PT_MERCATOR_1SP </li>
<li>
SRS_PT_LAMBERT_CONFORMAL_CONIC_1SP to SRS_PT_LAMBERT_CONFORMAL_CONIC_2SP </li>
<li>
SRS_PT_LAMBERT_CONFORMAL_CONIC_2SP to SRS_PT_LAMBERT_CONFORMAL_CONIC_1SP </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszTargetProjection</td><td>target projection. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>lists of options. None supported currently. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new SRS, or NULL in case of error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a2f0172f9c1d69f347cbe429f7d39a3fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::CopyGeogCSFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&#160;</td>
          <td class="paramname"><em>poSrcSRS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy GEOGCS from another <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a>. </p>
<p>The GEOGCS information is copied into this <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a> from another. If this object has a PROJCS root already, the GEOGCS is installed within it, otherwise it is installed as the root.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poSrcSRS</td><td>the spatial reference to copy the GEOGCS information from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or an error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ade185ac8ef1724fea5ec3c0e68eaae81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRSpatialReference::Dereference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrements the reference count by one. </p>
<p>The method does the same thing as the C function <a class="el" href="ogr__srs__api_8h.html#aae579eb4bdb653ead302a2850921ac77" title="Decrements the reference count by one. ">OSRDereference()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the updated reference count. </dd></dl>

</div>
</div>
<a class="anchor" id="adda5434b145cd2728c907e74b795edcf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRSpatialReference::DestroySpatialReference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&#160;</td>
          <td class="paramname"><em>poSRS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a> destructor. </p>
<p>This static method will destroy a <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a>. It is equivalent to calling delete on the object, but it ensures that the deallocation is properly executed within the OGR libraries heap on platforms where this can matter (win32).</p>
<p>This function is the same as <a class="el" href="ogr__srs__api_8h.html#aa1485e7c17fb7edc15a0dfda63f77333" title="OGRSpatialReference destructor. ">OSRDestroySpatialReference()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poSRS</td><td>the object to delete</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.7.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a0747cf1e8d323d69c94d6cb217f4382b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRSpatialReference::EPSGTreatsAsLatLong </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method returns TRUE if EPSG feels this geographic coordinate system should be treated as having lat/long coordinate ordering. </p>
<p>Currently this returns TRUE for all geographic coordinate systems with an EPSG code set, and AXIS values set defining it as lat, long. Note that coordinate systems with an EPSG code and no axis settings will be assumed to not be lat/long.</p>
<p>FALSE will be returned for all coordinate systems that are not geographic, or that do not have an EPSG code set.</p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#a005a0534c41bafad5c5c7a3fa179dcd6" title="This function returns TRUE if EPSG feels this geographic coordinate system should be treated as havin...">OSREPSGTreatsAsLatLong()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE or FALSE. </dd></dl>

</div>
</div>
<a class="anchor" id="a221dc380de8db4eca44337aa5a157acb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRSpatialReference::EPSGTreatsAsNorthingEasting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method returns TRUE if EPSG feels this projected coordinate system should be treated as having northing/easting coordinate ordering. </p>
<p>Currently this returns TRUE for all projected coordinate systems with an EPSG code set, and AXIS values set defining it as northing, easting.</p>
<p>FALSE will be returned for all coordinate systems that are not projected, or that do not have an EPSG code set.</p>
<p>This method is the same as the C function <a class="el" href="classOGRSpatialReference.html#a221dc380de8db4eca44337aa5a157acb" title="This method returns TRUE if EPSG feels this projected coordinate system should be treated as having n...">EPSGTreatsAsNorthingEasting()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE or FALSE.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.10.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a574b5f221ae0b41bc4f82baeb8ab2f1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::exportToERM </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pszProj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pszDatum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pszUnits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert coordinate system to ERMapper format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszProj</td><td>32 character buffer to receive projection name. </td></tr>
    <tr><td class="paramname">pszDatum</td><td>32 character buffer to receive datum name. </td></tr>
    <tr><td class="paramname">pszUnits</td><td>32 character buffer to receive units name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success, OGRERR_SRS_UNSUPPORTED if not translation is found, or OGRERR_FAILURE on other failures. </dd></dl>

</div>
</div>
<a class="anchor" id="a1f2908cd5ca33609844ef0c0ff2186ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::exportToMICoordSys </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppszResult</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export coordinate system in Mapinfo style CoordSys format. </p>
<p>Note that the returned WKT string should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree() ">CPLFree()</a> when no longer needed. It is the responsibility of the caller.</p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#a28b4dc4b0a303ee6a7665ae798fc6cae" title="Export coordinate system in Mapinfo style CoordSys format. ">OSRExportToMICoordSys()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppszResult</td><td>pointer to which dynamically allocated Mapinfo CoordSys definition will be assigned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success, OGRERR_FAILURE on failure, OGRERR_UNSUPPORTED_OPERATION if MITAB library was not linked in. </dd></dl>

</div>
</div>
<a class="anchor" id="a2172f6cf2ea15a417474ef114f91397c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::exportToPanorama </td>
          <td>(</td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>piProjSys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>piDatum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>piEllips</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>piZone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>padfPrjParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export coordinate system in "Panorama" GIS projection definition. </p>
<p>This method is the equivalent of the C function <a class="el" href="ogr__srs__api_8h.html#ad388f4a1effc60b53b915b8720678818" title="Export coordinate system in &quot;Panorama&quot; GIS projection definition. ">OSRExportToPanorama()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">piProjSys</td><td>Pointer to variable, where the projection system code will be returned.</td></tr>
    <tr><td class="paramname">piDatum</td><td>Pointer to variable, where the coordinate system code will be returned.</td></tr>
    <tr><td class="paramname">piEllips</td><td>Pointer to variable, where the spheroid code will be returned.</td></tr>
    <tr><td class="paramname">piZone</td><td>Pointer to variable, where the zone for UTM projection system will be returned.</td></tr>
    <tr><td class="paramname">padfPrjParams</td><td>an existing 7 double buffer into which the projection parameters will be placed. See <a class="el" href="classOGRSpatialReference.html#a6a534e7d862a17c92a31d821848533c8" title="Import coordinate system from &quot;Panorama&quot; GIS projection definition. ">importFromPanorama()</a> for the list of parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or an error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ad91c0f34ebfe6fd08001ced4d805b201"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::exportToPCI </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppszProj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppszUnits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>ppadfPrjParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export coordinate system in PCI projection definition. </p>
<p>Converts the loaded coordinate reference system into PCI projection definition to the extent possible. The strings returned in ppszProj, ppszUnits and ppadfPrjParams array should be deallocated by the caller with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree() ">CPLFree()</a> when no longer needed.</p>
<p>LOCAL_CS coordinate systems are not translatable. An empty string will be returned along with OGRERR_NONE.</p>
<p>This method is the equivalent of the C function <a class="el" href="ogr__srs__api_8h.html#aab032277e5f449045eb4bcf0b62d9070" title="Export coordinate system in PCI projection definition. ">OSRExportToPCI()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppszProj</td><td>pointer to which dynamically allocated PCI projection definition will be assigned.</td></tr>
    <tr><td class="paramname">ppszUnits</td><td>pointer to which dynamically allocated units definition will be assigned.</td></tr>
    <tr><td class="paramname">ppadfPrjParams</td><td>pointer to which dynamically allocated array of 17 projection parameters will be assigned. See <a class="el" href="classOGRSpatialReference.html#a4739e78e7e2c81d61bb5fc9d9cdde8ee" title="Import coordinate system from PCI projection definition. ">importFromPCI()</a> for the list of parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or an error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a635423e09630b4d31b2fa4259667a4ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::exportToPrettyWkt </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppszResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bSimplify</em> = <code>FALSE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert this SRS into a nicely formatted WKT string for display to a person. </p>
<p>Consult also the <a href="wktproblems.html">OGC WKT Coordinate System Issues</a> page for implementation details of WKT in OGR.</p>
<p>Note that the returned WKT string should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree() ">CPLFree()</a> when no longer needed. It is the responsibility of the caller.</p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#a2394b976d309aa64e2d70d87c542dae3" title="Convert this SRS into a nicely formatted WKT string for display to a person. ">OSRExportToPrettyWkt()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppszResult</td><td>the resulting string is returned in this pointer. </td></tr>
    <tr><td class="paramname">bSimplify</td><td>TRUE if the AXIS, AUTHORITY and EXTENSION nodes should be stripped off.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>currently OGRERR_NONE is always returned, but the future it is possible error conditions will develop. </dd></dl>

</div>
</div>
<a class="anchor" id="a28bd9b81856b6a93861576fff0933bb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::exportToProj4 </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppszProj4</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export coordinate system in PROJ.4 format. </p>
<p>Converts the loaded coordinate reference system into PROJ.4 format to the extent possible. The string returned in ppszProj4 should be deallocated by the caller with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree() ">CPLFree()</a> when no longer needed.</p>
<p>LOCAL_CS coordinate systems are not translatable. An empty string will be returned along with OGRERR_NONE.</p>
<p>Special processing for Transverse Mercator with GDAL &gt;= 1.10 and PROJ &gt;= 4.8 : If the OSR_USE_ETMERC configuration option is set to YES, the PROJ.4 definition built from the SRS will use the 'etmerc' projection method, rather than the default 'tmerc'. This will give better accuracy (at the expense of computational speed) when reprojection occurs near the edges of the validity area for the projection. Starting with GDAL &gt;= 2.2, setting OSR_USE_ETMERC to NO will expand to the 'tmerc' projection method (useful with PROJ &gt;= 4.9.3, where utm uses etmerc)</p>
<p>This method is the equivalent of the C function <a class="el" href="ogr__srs__api_8h.html#ae410c0b0bb86b7d7903193828db8a1f5" title="Export coordinate system in PROJ.4 format. ">OSRExportToProj4()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppszProj4</td><td>pointer to which dynamically allocated PROJ.4 definition will be assigned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or an error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a04ab13a2ec4ceffd6f802422f95e8f15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::exportToUSGS </td>
          <td>(</td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>piProjSys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>piZone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>ppadfPrjParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>piDatum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export coordinate system in USGS GCTP projection definition. </p>
<p>This method is the equivalent of the C function <a class="el" href="ogr__srs__api_8h.html#a6e50ea67235a4796edcbd3e14113f6aa" title="Export coordinate system in USGS GCTP projection definition. ">OSRExportToUSGS()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">piProjSys</td><td>Pointer to variable, where the projection system code will be returned.</td></tr>
    <tr><td class="paramname">piZone</td><td>Pointer to variable, where the zone for UTM and State Plane projection systems will be returned.</td></tr>
    <tr><td class="paramname">ppadfPrjParams</td><td>Pointer to which dynamically allocated array of 15 projection parameters will be assigned. See <a class="el" href="classOGRSpatialReference.html#a4a971615901e5c4a028e6b49fb5918d9" title="Import coordinate system from USGS projection definition. ">importFromUSGS()</a> for the list of parameters. Caller responsible to free this array.</td></tr>
    <tr><td class="paramname">piDatum</td><td>Pointer to variable, where the datum code will be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or an error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a596b8e527d66a5054408159f0006fdac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::exportToWkt </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppszResult</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert this SRS into WKT format. </p>
<p>Consult also the <a href="wktproblems.html">OGC WKT Coordinate System Issues</a> page for implementation details of WKT in OGR.</p>
<p>Note that the returned WKT string should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree() ">CPLFree()</a> when no longer needed. It is the responsibility of the caller.</p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#aa7dae0f3fac7ee553771d33c020ec86b" title="Convert this SRS into WKT format. ">OSRExportToWkt()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppszResult</td><td>the resulting string is returned in this pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>currently OGRERR_NONE is always returned, but the future it is possible error conditions will develop. </dd></dl>

</div>
</div>
<a class="anchor" id="aac2f21b51f176a0cf6b4a331c3090f46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::exportToXML </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppszRawXML</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDialect</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export coordinate system in XML format. </p>
<p>Converts the loaded coordinate reference system into XML format to the extent possible. The string returned in ppszRawXML should be deallocated by the caller with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree() ">CPLFree()</a> when no longer needed.</p>
<p>LOCAL_CS coordinate systems are not translatable. An empty string will be returned along with OGRERR_NONE.</p>
<p>This method is the equivalent of the C function <a class="el" href="ogr__srs__api_8h.html#ad62d01e6cda312408b167260c2bd45fd" title="Export coordinate system in XML format. ">OSRExportToXML()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppszRawXML</td><td>pointer to which dynamically allocated XML definition will be assigned. </td></tr>
    <tr><td class="paramname">pszDialect</td><td>currently ignored. The dialect used is GML based.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or an error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="abb83a2ed838ee5e81a2dba8ac640b63c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a> * OGRSpatialReference::FindMatches </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnEntries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>ppanMatchConfidence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to identify a match between the passed SRS and a related SRS in a catalog (currently EPSG only) </p>
<p>Matching may be partial, or may fail. Returned entries will be sorted by decreasing match confidence (first entry has the highest match confidence).</p>
<p>The exact way matching is done may change in future versions.</p>
<p>The current algorithm is:</p><ul>
<li>try first <a class="el" href="classOGRSpatialReference.html#acb0373c83927bfd694048da6f79e33ea" title="Set EPSG authority info if possible. ">AutoIdentifyEPSG()</a>. If it succeeds, return the corresponding SRS</li>
<li>otherwise iterate over all SRS from the EPSG catalog (as found in GDAL pcs.csv and gcs.csv files+esri_extra.wkt), and find those that match the input SRS using the <a class="el" href="classOGRSpatialReference.html#a17fd82b2f58a976a30358b076a2fc966" title="Do these two spatial references describe the same system ? ">IsSame()</a> function (ignoring TOWGS84 clauses)</li>
<li>if there is a single match using <a class="el" href="classOGRSpatialReference.html#a17fd82b2f58a976a30358b076a2fc966" title="Do these two spatial references describe the same system ? ">IsSame()</a> or one of the matches has the same SRS name, return it with 100% confidence</li>
<li>if a SRS has the same SRS name, but does not pass the <a class="el" href="classOGRSpatialReference.html#a17fd82b2f58a976a30358b076a2fc966" title="Do these two spatial references describe the same system ? ">IsSame()</a> criteria, return it with 50% confidence.</li>
<li>otherwise return all candidate SRS that pass the <a class="el" href="classOGRSpatialReference.html#a17fd82b2f58a976a30358b076a2fc966" title="Do these two spatial references describe the same system ? ">IsSame()</a> criteria with a 90% confidence.</li>
</ul>
<p>A pre-built SRS cache in ~/.gdal/X.Y/srs_cache will be used if existing, otherwise it will be built at the first run of this function.</p>
<p>This method is the same as <a class="el" href="ogr__srs__api_8h.html#afb64acc80626c9ea0f9ec75017a10169" title="Try to identify a match between the passed SRS and a related SRS in a catalog (currently EPSG only) ...">OSRFindMatches()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of options or NULL </td></tr>
    <tr><td class="paramname">pnEntries</td><td>Output parameter. Number of values in the returned array. </td></tr>
    <tr><td class="paramname">ppanMatchConfidence</td><td>Output parameter (or NULL). *ppanMatchConfidence will be allocated to an array of *pnEntries whose values between 0 and 100 indicate the confidence in the match. 100 is the highest confidence level. The array must be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree() ">CPLFree()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of SRS that match the passed SRS, or NULL. Must be freed with <a class="el" href="ogr__srs__api_8h.html#a0d2f386cc06888e791df28828aaeae00" title="Free return of OSRIdentifyMatches() ">OSRFreeSRSArray()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="aba5350ca443f5d631d86cc71b1b86977"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRSpatialReference::FindProjParm </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszParameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> *&#160;</td>
          <td class="paramname"><em>poPROJCS</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the child index of the named projection parameter on its parent PROJCS node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszParameter</td><td>projection parameter to look for </td></tr>
    <tr><td class="paramname">poPROJCS</td><td>projection CS node to look in. If NULL is passed, the PROJCS node of the SpatialReference object will be searched.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the child index of the named projection parameter. -1 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a429b0446798982c6c19efcb7042a8cbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::Fixup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fixup as needed. </p>
<p>Some mechanisms to create WKT using <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a>, and some imported WKT, are not valid according to the OGC CT specification. This method attempts to fill in any missing defaults that are required, and fixup ordering problems (using <a class="el" href="ogr__srs__api_8h.html#a2a994977dd25d61b4d94806a23cfc4eb" title="Correct parameter ordering to match CT Specification. ">OSRFixupOrdering()</a>) so that the resulting WKT is valid.</p>
<p>This method should be expected to evolve over time to as problems are discovered. The following are among the fixup actions this method will take:</p>
<ul>
<li>Fixup the ordering of nodes to match the BNF WKT ordering, using the <a class="el" href="classOGRSpatialReference.html#ae1b29a686944ae51ed924aa5138b45ba" title="Correct parameter ordering to match CT Specification. ">FixupOrdering()</a> method.</li>
<li>Add missing linear or angular units nodes.</li>
</ul>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#a554fd8abbd5ef63ad5b32c511a690328" title="Fixup as needed. ">OSRFixup()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or an error code if something goes wrong. </dd></dl>

</div>
</div>
<a class="anchor" id="ae1b29a686944ae51ed924aa5138b45ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::FixupOrdering </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Correct parameter ordering to match CT Specification. </p>
<p>Some mechanisms to create WKT using <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a>, and some imported WKT fail to maintain the order of parameters required according to the BNF definitions in the OpenGIS SF-SQL and CT Specifications. This method attempts to massage things back into the required order.</p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#a2a994977dd25d61b4d94806a23cfc4eb" title="Correct parameter ordering to match CT Specification. ">OSRFixupOrdering()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or an error code if something goes wrong. </dd></dl>

</div>
</div>
<a class="anchor" id="a379939d011a31203d0251481b5af07b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a>* OGRSpatialReference::FromHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>&#160;</td>
          <td class="paramname"><em>hSRS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a OGRSpatialReferenceH to a OGRSpatialReference*. </p>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a252e7c15b702d638d7e25b8f8f784496"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGRSpatialReference::GetAngularUnits </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppszName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch angular geographic coordinate system units. </p>
<p>If no units are available, a value of "degree" and SRS_UA_DEGREE_CONV will be assumed. This method only checks directly under the GEOGCS node for units.</p>
<p>This method does the same thing as the C function <a class="el" href="ogr__srs__api_8h.html#a3e17bcdca0f0d6b582e1ae2b691c4999" title="Fetch angular geographic coordinate system units. ">OSRGetAngularUnits()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppszName</td><td>a pointer to be updated with the pointer to the units name. The returned value remains internal to the <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a> and should not be freed, or modified. It may be invalidated on the next <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a> call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value to multiply by angular distances to transform them to radians. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a25e333217daf9e7f68d236350422ade5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGRSpatialReference::GetAngularUnits </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>ppszName</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch angular geographic coordinate system units. </p>
<p>If no units are available, a value of "degree" and SRS_UA_DEGREE_CONV will be assumed. This method only checks directly under the GEOGCS node for units.</p>
<p>This method does the same thing as the C function <a class="el" href="ogr__srs__api_8h.html#a3e17bcdca0f0d6b582e1ae2b691c4999" title="Fetch angular geographic coordinate system units. ">OSRGetAngularUnits()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppszName</td><td>a pointer to be updated with the pointer to the units name. The returned value remains internal to the <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a> and should not be freed, or modified. It may be invalidated on the next <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a> call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value to multiply by angular distances to transform them to radians. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000018">Deprecated:</a></b></dt><dd>GDAL 2.3.0. Use <a class="el" href="classOGRSpatialReference.html#a25e333217daf9e7f68d236350422ade5" title="Fetch angular geographic coordinate system units. ">GetAngularUnits(const char**) const</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a529996d77052abd060d95883ad27258d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> * OGRSpatialReference::GetAttrNode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszNodePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find named node in tree. </p>
<p>This method does a pre-order traversal of the node tree searching for a node with this exact value (case insensitive), and returns it. Leaf nodes are not considered, under the assumption that they are just attribute value nodes.</p>
<p>If a node appears more than once in the tree (such as UNIT for instance), the first encountered will be returned. Use GetNode() on a subtree to be more specific.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszNodePath</td><td>the name of the node to search for. May contain multiple components such as "GEOGCS|UNIT".</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the node found, or NULL if none. </dd></dl>

</div>
</div>
<a class="anchor" id="a5f692973b2a388a1046d63290a6900fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> * OGRSpatialReference::GetAttrNode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszNodePath</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find named node in tree. </p>
<p>This method does a pre-order traversal of the node tree searching for a node with this exact value (case insensitive), and returns it. Leaf nodes are not considered, under the assumption that they are just attribute value nodes.</p>
<p>If a node appears more than once in the tree (such as UNIT for instance), the first encountered will be returned. Use GetNode() on a subtree to be more specific.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszNodePath</td><td>the name of the node to search for. May contain multiple components such as "GEOGCS|UNIT".</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the node found, or NULL if none. </dd></dl>

</div>
</div>
<a class="anchor" id="acc815e7bd21c1c052304368c0eefe8be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * OGRSpatialReference::GetAttrValue </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszNodeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iAttr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch indicated attribute of named node. </p>
<p>This method uses <a class="el" href="classOGRSpatialReference.html#a529996d77052abd060d95883ad27258d" title="Find named node in tree. ">GetAttrNode()</a> to find the named node, and then extracts the value of the indicated child. Thus a call to GetAttrValue("UNIT",1) would return the second child of the UNIT node, which is normally the length of the linear unit in meters.</p>
<p>This method does the same thing as the C function <a class="el" href="ogr__srs__api_8h.html#a22dd5ca9a242959a1cc8cbe1e7dc8b9c" title="Fetch indicated attribute of named node. ">OSRGetAttrValue()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszNodeName</td><td>the tree node to look for (case insensitive). </td></tr>
    <tr><td class="paramname">iAttr</td><td>the child of the node to fetch (zero based).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested value, or NULL if it fails for any reason. </dd></dl>

</div>
</div>
<a class="anchor" id="a178f4593ef4ee661f2df9d221feaa803"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * OGRSpatialReference::GetAuthorityCode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszTargetKey</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the authority code for a node. </p>
<p>This method is used to query an AUTHORITY[] node from within the WKT tree, and fetch the code value.</p>
<p>While in theory values may be non-numeric, for the EPSG authority all code values should be integral.</p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#a1a3f712d95263bf9d564fbd795064188" title="Get the authority code for a node. ">OSRGetAuthorityCode()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszTargetKey</td><td>the partial or complete path to the node to get an authority from. i.e. "PROJCS", "GEOGCS", "GEOGCS|UNIT" or NULL to search for an authority node on the root element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value code from authority node, or NULL on failure. The value returned is internal and should not be freed or modified. </dd></dl>

</div>
</div>
<a class="anchor" id="a3f6524f36ace6a7be7b3e2a20790a82f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * OGRSpatialReference::GetAuthorityName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszTargetKey</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the authority name for a node. </p>
<p>This method is used to query an AUTHORITY[] node from within the WKT tree, and fetch the authority name value.</p>
<p>The most common authority is "EPSG".</p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#a938078788e10ddb57c0f55c619adc210" title="Get the authority name for a node. ">OSRGetAuthorityName()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszTargetKey</td><td>the partial or complete path to the node to get an authority from. i.e. "PROJCS", "GEOGCS", "GEOGCS|UNIT" or NULL to search for an authority node on the root element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value code from authority node, or NULL on failure. The value returned is internal and should not be freed or modified. </dd></dl>

</div>
</div>
<a class="anchor" id="a485ca347702eea566fc239782a6b74fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * OGRSpatialReference::GetAxis </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszTargetKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iAxis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__srs__api_8h.html#ae247bb1b37409553c72a78bd3b6d65b6">OGRAxisOrientation</a> *&#160;</td>
          <td class="paramname"><em>peOrientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the orientation of one axis. </p>
<p>Fetches the request axis (iAxis - zero based) from the indicated portion of the coordinate system (pszTargetKey) which should be either "GEOGCS" or "PROJCS".</p>
<p>No CPLError is issued on routine failures (such as not finding the AXIS).</p>
<p>This method is equivalent to the C function <a class="el" href="ogr__srs__api_8h.html#ad1eb792fec17ee08c7d47f8a5c8c68dc" title="Fetch the orientation of one axis. ">OSRGetAxis()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszTargetKey</td><td>the coordinate system part to query ("PROJCS" or "GEOGCS"). </td></tr>
    <tr><td class="paramname">iAxis</td><td>the axis to query (0 for first, 1 for second). </td></tr>
    <tr><td class="paramname">peOrientation</td><td>location into which to place the fetch orientation, may be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name of the axis or NULL on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="aa631c657f26c904320c8a23534cc5f50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGRSpatialReference::GetEccentricity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get spheroid eccentricity. </p>
<dl class="section return"><dt>Returns</dt><dd>eccentricity (or -1 in case of error) </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a3aeaacda77ad389d6f0d9ae460c38d7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRSpatialReference::GetEPSGGeogCS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to establish what the EPSG code for this coordinate systems GEOGCS might be. </p>
<p>Returns -1 if no reasonable guess can be made.</p>
<dl class="section return"><dt>Returns</dt><dd>EPSG code </dd></dl>

</div>
</div>
<a class="anchor" id="a12d2cdae2d6b175051b2f76cb50c84a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * OGRSpatialReference::GetExtension </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszTargetKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDefault</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch extension value. </p>
<p>Fetch the value of the named EXTENSION item for the identified target node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszTargetKey</td><td>the name or path to the parent node of the EXTENSION. </td></tr>
    <tr><td class="paramname">pszName</td><td>the name of the extension being fetched. </td></tr>
    <tr><td class="paramname">pszDefault</td><td>the value to return if the extension is not found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>node value if successful or pszDefault on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="aa26b093d7901cb5b32e07b15a4247d10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGRSpatialReference::GetInvFlattening </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> *&#160;</td>
          <td class="paramname"><em>pnErr</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get spheroid inverse flattening. </p>
<p>This method does the same thing as the C function <a class="el" href="ogr__srs__api_8h.html#a79746a1da88d9a7e41557df82165c08a" title="Get spheroid inverse flattening. ">OSRGetInvFlattening()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pnErr</td><td>if non-NULL set to OGRERR_FAILURE if no inverse flattening can be found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>inverse flattening, or SRS_WGS84_INVFLATTENING if it can't be found. </dd></dl>

</div>
</div>
<a class="anchor" id="aefbcac403652e15cfcb1d864d84a3706"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGRSpatialReference::GetLinearUnits </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppszName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch linear projection units. </p>
<p>If no units are available, a value of "Meters" and 1.0 will be assumed. This method only checks directly under the PROJCS, GEOCCS or LOCAL_CS node for units.</p>
<p>This method does the same thing as the C function <a class="el" href="ogr__srs__api_8h.html#a4ac8ada088020302ac565ebe00378ab9" title="Fetch linear projection units. ">OSRGetLinearUnits()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppszName</td><td>a pointer to be updated with the pointer to the units name. The returned value remains internal to the <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a> and should not be freed, or modified. It may be invalidated on the next <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a> call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value to multiply by linear distances to transform them to meters. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000019">Deprecated:</a></b></dt><dd>GDAL 2.3.0. Use <a class="el" href="classOGRSpatialReference.html#a2c173500813894e627b0bc558a4ea9ff" title="Fetch linear projection units. ">GetLinearUnits(const char**) const</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a2c173500813894e627b0bc558a4ea9ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGRSpatialReference::GetLinearUnits </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>ppszName</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch linear projection units. </p>
<p>If no units are available, a value of "Meters" and 1.0 will be assumed. This method only checks directly under the PROJCS, GEOCCS or LOCAL_CS node for units.</p>
<p>This method does the same thing as the C function <a class="el" href="ogr__srs__api_8h.html#a4ac8ada088020302ac565ebe00378ab9" title="Fetch linear projection units. ">OSRGetLinearUnits()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppszName</td><td>a pointer to be updated with the pointer to the units name. The returned value remains internal to the <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a> and should not be freed, or modified. It may be invalidated on the next <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a> call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value to multiply by linear distances to transform them to meters. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ae41526ef7451dc71f81e1ad3396eb138"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGRSpatialReference::GetNormProjParm </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfDefaultValue</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> *&#160;</td>
          <td class="paramname"><em>pnErr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch a normalized projection parameter value. </p>
<p>This method is the same as <a class="el" href="classOGRSpatialReference.html#ac60d56e89dbcb515a5ee576b02474470" title="Fetch a projection parameter value. ">GetProjParm()</a> except that the value of the parameter is "normalized" into degrees or meters depending on whether it is linear or angular.</p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#a6ad286760ff074e13041203a6956782f" title="This function is the same as OGRSpatialReference:: ">OSRGetNormProjParm()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszName</td><td>the name of the parameter to fetch, from the set of SRS_PP codes in <a class="el" href="ogr__srs__api_8h.html" title="C spatial reference system services and defines. ">ogr_srs_api.h</a>.</td></tr>
    <tr><td class="paramname">dfDefaultValue</td><td>the value to return if this parameter doesn't exist.</td></tr>
    <tr><td class="paramname">pnErr</td><td>place to put error code on failure. Ignored if NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of parameter. </dd></dl>

</div>
</div>
<a class="anchor" id="ad27c3dec297c064afa0d29270f374375"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGRSpatialReference::GetPrimeMeridian </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppszName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch prime meridian info. </p>
<p>Returns the offset of the prime meridian from greenwich in degrees, and the prime meridian name (if requested). If no PRIMEM value exists in the coordinate system definition a value of "Greenwich" and an offset of 0.0 is assumed.</p>
<p>If the prime meridian name is returned, the pointer is to an internal copy of the name. It should not be freed, altered or depended on after the next OGR call.</p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#a45165794393738d828aa3aa57ab39b49" title="Fetch prime meridian info. ">OSRGetPrimeMeridian()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppszName</td><td>return location for prime meridian name. If NULL, name is not returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the offset to the GEOGCS prime meridian from greenwich in decimal degrees. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3.0 </dd></dl>

</div>
</div>
<a class="anchor" id="aba0c3481848c837f8850389a2f8e9b8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGRSpatialReference::GetPrimeMeridian </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>ppszName</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch prime meridian info. </p>
<p>Returns the offset of the prime meridian from greenwich in degrees, and the prime meridian name (if requested). If no PRIMEM value exists in the coordinate system definition a value of "Greenwich" and an offset of 0.0 is assumed.</p>
<p>If the prime meridian name is returned, the pointer is to an internal copy of the name. It should not be freed, altered or depended on after the next OGR call.</p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#a45165794393738d828aa3aa57ab39b49" title="Fetch prime meridian info. ">OSRGetPrimeMeridian()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppszName</td><td>return location for prime meridian name. If NULL, name is not returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the offset to the GEOGCS prime meridian from greenwich in decimal degrees. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000021">Deprecated:</a></b></dt><dd>GDAL 2.3.0. Use <a class="el" href="classOGRSpatialReference.html#aba0c3481848c837f8850389a2f8e9b8c" title="Fetch prime meridian info. ">GetPrimeMeridian(const char**) const</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ac60d56e89dbcb515a5ee576b02474470"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGRSpatialReference::GetProjParm </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfDefaultValue</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> *&#160;</td>
          <td class="paramname"><em>pnErr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch a projection parameter value. </p>
<p>NOTE: This code should be modified to translate non degree angles into degrees based on the GEOGCS unit. This has not yet been done.</p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#aee052050fbdf32fb5a1a0bfa9cad9bfc" title="Fetch a projection parameter value. ">OSRGetProjParm()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszName</td><td>the name of the parameter to fetch, from the set of SRS_PP codes in <a class="el" href="ogr__srs__api_8h.html" title="C spatial reference system services and defines. ">ogr_srs_api.h</a>.</td></tr>
    <tr><td class="paramname">dfDefaultValue</td><td>the value to return if this parameter doesn't exist.</td></tr>
    <tr><td class="paramname">pnErr</td><td>place to put error code on failure. Ignored if NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of parameter. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b4e29e50d8591aa2c75620367eb2123"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OGRSpatialReference::GetReferenceCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch current reference count. </p>
<dl class="section return"><dt>Returns</dt><dd>the current reference count. </dd></dl>

</div>
</div>
<a class="anchor" id="a89b57ccaa09b54707b951d0e4822ce2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGRSpatialReference::GetSemiMajor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> *&#160;</td>
          <td class="paramname"><em>pnErr</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get spheroid semi major axis. </p>
<p>This method does the same thing as the C function <a class="el" href="ogr__srs__api_8h.html#aa7f8b84bb6d99e04f362ae1b2590ca33" title="Get spheroid semi major axis. ">OSRGetSemiMajor()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pnErr</td><td>if non-NULL set to OGRERR_FAILURE if semi major axis can be found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>semi-major axis, or SRS_WGS84_SEMIMAJOR if it can't be found. </dd></dl>

</div>
</div>
<a class="anchor" id="a2649ebcb99c191ef6ddf36804d129516"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGRSpatialReference::GetSemiMinor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> *&#160;</td>
          <td class="paramname"><em>pnErr</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get spheroid semi minor axis. </p>
<p>This method does the same thing as the C function <a class="el" href="ogr__srs__api_8h.html#a432e4d2fb6ac0bff03d9e0777cebe258" title="Get spheroid semi minor axis. ">OSRGetSemiMinor()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pnErr</td><td>if non-NULL set to OGRERR_FAILURE if semi minor axis can be found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>semi-minor axis, or WGS84 semi minor if it can't be found. </dd></dl>

</div>
</div>
<a class="anchor" id="af28f60794657815a70e673d1d17894db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGRSpatialReference::GetSquaredEccentricity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get spheroid squared eccentricity. </p>
<dl class="section return"><dt>Returns</dt><dd>squared eccentricity (or -1 in case of error) </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a9903149d99cf5df66439fbb8f23660d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGRSpatialReference::GetTargetLinearUnits </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszTargetKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppszName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch linear units for target. </p>
<p>If no units are available, a value of "Meters" and 1.0 will be assumed.</p>
<p>This method does the same thing as the C function <a class="el" href="ogr__srs__api_8h.html#a99b89446d22531546d40e03e42b84ad1" title="Fetch linear projection units. ">OSRGetTargetLinearUnits()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszTargetKey</td><td>the key to look on. i.e. "PROJCS" or "VERT_CS". Might be NULL, in which case PROJCS will be implied (and if not found, LOCAL_CS, GEOCCS and VERT_CS are looked up) </td></tr>
    <tr><td class="paramname">ppszName</td><td>a pointer to be updated with the pointer to the units name. The returned value remains internal to the <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a> and should not be freed, or modified. It may be invalidated on the next <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a> call. ppszName can be set to NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value to multiply by linear distances to transform them to meters.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a1aeac856f32ef82670bda91e6623c110"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGRSpatialReference::GetTargetLinearUnits </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszTargetKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>ppszName</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch linear units for target. </p>
<p>If no units are available, a value of "Meters" and 1.0 will be assumed.</p>
<p>This method does the same thing as the C function <a class="el" href="ogr__srs__api_8h.html#a99b89446d22531546d40e03e42b84ad1" title="Fetch linear projection units. ">OSRGetTargetLinearUnits()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszTargetKey</td><td>the key to look on. i.e. "PROJCS" or "VERT_CS". Might be NULL, in which case PROJCS will be implied (and if not found, LOCAL_CS, GEOCCS and VERT_CS are looked up) </td></tr>
    <tr><td class="paramname">ppszName</td><td>a pointer to be updated with the pointer to the units name. The returned value remains internal to the <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a> and should not be freed, or modified. It may be invalidated on the next <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a> call. ppszName can be set to NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value to multiply by linear distances to transform them to meters.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000020">Deprecated:</a></b></dt><dd>GDAL 2.3.0. Use <a class="el" href="classOGRSpatialReference.html#a1aeac856f32ef82670bda91e6623c110" title="Fetch linear units for target. ">GetTargetLinearUnits(const char*, const char**) const</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aaa947bf7c5c7240d2de30afe11086a19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::GetTOWGS84 </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>padfCoeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nCoeffCount</em> = <code>7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch TOWGS84 parameters, if available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">padfCoeff</td><td>array into which up to 7 coefficients are placed. </td></tr>
    <tr><td class="paramname">nCoeffCount</td><td>size of padfCoeff - defaults to 7.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success, or OGRERR_FAILURE if there is no TOWGS84 node available. </dd></dl>

</div>
</div>
<a class="anchor" id="a137a1f15ba0d18b84e7fc4104c74cdb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRSpatialReference::GetUTMZone </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pbNorth</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get utm zone information. </p>
<p>This is the same as the C function <a class="el" href="ogr__srs__api_8h.html#ad21364295012631454ff6bdbfd8cd48e" title="Get utm zone information. ">OSRGetUTMZone()</a>.</p>
<p>In SWIG bindings (Python, Java, etc) the <a class="el" href="classOGRSpatialReference.html#a137a1f15ba0d18b84e7fc4104c74cdb9" title="Get utm zone information. ">GetUTMZone()</a> method returns a zone which is negative in the southern hemisphere instead of having the pbNorth flag used in the C and C++ interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pbNorth</td><td>pointer to in to set to TRUE if northern hemisphere, or FALSE if southern.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UTM zone number or zero if this isn't a UTM definition. </dd></dl>

</div>
</div>
<a class="anchor" id="af960d7b1f894a2d7158bed6086459f01"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> * OGRSpatialReference::GetWGS84SRS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an instance of a SRS object with WGS84 WKT. </p>
<p>The reference counter of the returned object is not increased by this operation.</p>
<dl class="section return"><dt>Returns</dt><dd>instance. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a6c127a25699d8b59e79866b1167d07b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::importFromCRSURL </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszURL</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize from OGC URL. </p>
<p>Initializes this spatial reference from a coordinate system defined by an OGC URL prefixed with "http://opengis.net/def/crs" per best practice paper 11-135. Currently EPSG and OGC authority values are supported, including OGC auto codes, but not including CRS1 or CRS88 (NAVD88).</p>
<p>This method is also supported through <a class="el" href="classOGRSpatialReference.html#aec3c6a49533fe457ddc763d699ff8796" title="Set spatial reference from various text formats. ">SetFromUserInput()</a> which can normally be used for URLs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszURL</td><td>the URL string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or an error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ad6daf2b64d379a4484413fc9755cc7f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::importFromDict </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDictFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read SRS from WKT dictionary. </p>
<p>This method will attempt to find the indicated coordinate system identity in the indicated dictionary file. If found, the WKT representation is imported and used to initialize this <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a>.</p>
<p>More complete information on the format of the dictionary files can be found in the epsg.wkt file in the GDAL data tree. The dictionary files are searched for in the "GDAL" domain using <a class="el" href="cpl__conv_8h.html#a86d703dd3f7f137d1590b55d7a7e4fb8" title="CPLFindFile. ">CPLFindFile()</a>. Normally this results in searching /usr/local/share/gdal or somewhere similar.</p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#acdd5705d417a42c5e487422fd6913545" title="Read SRS from WKT dictionary. ">OSRImportFromDict()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszDictFile</td><td>the name of the dictionary file to load.</td></tr>
    <tr><td class="paramname">pszCode</td><td>the code to lookup in the dictionary.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success, or OGRERR_SRS_UNSUPPORTED if the code isn't found, and OGRERR_SRS_FAILURE if something more dramatic goes wrong. </dd></dl>

</div>
</div>
<a class="anchor" id="a8a5b8c9a205eedc6b88a14aa0c219969"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::importFromEPSG </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize SRS based on EPSG GCS or PCS code. </p>
<p>This method will initialize the spatial reference based on the passed in EPSG GCS or PCS code. The coordinate system definitions are normally read from the EPSG derived support files such as pcs.csv, gcs.csv, pcs.override.csv, gcs.override.csv and falling back to search for a PROJ.4 epsg init file or a definition in epsg.wkt.</p>
<p>These support files are normally searched for in /usr/local/share/gdal or in the directory identified by the GDAL_DATA configuration option. See <a class="el" href="cpl__conv_8h.html#a86d703dd3f7f137d1590b55d7a7e4fb8" title="CPLFindFile. ">CPLFindFile()</a> for details.</p>
<p>This method is relatively expensive, and generally involves quite a bit of text file scanning. Reasonable efforts should be made to avoid calling it many times for the same coordinate system.</p>
<p>This method is similar to <a class="el" href="classOGRSpatialReference.html#aaa6965a1df98cdc673dfb20697eab613" title="Initialize SRS based on EPSG GCS or PCS code. ">importFromEPSGA()</a> except that EPSG preferred axis ordering will <em>not</em> be applied for geographic coordinate systems. EPSG normally defines geographic coordinate systems to use lat/long contrary to typical GIS use). Since OGR 1.10.0, EPSG preferred axis ordering will also <em>not</em> be applied for projected coordinate systems that use northing/easting order.</p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#a02b89339400e5c5df84e535d54865ea0" title="Initialize SRS based on EPSG GCS or PCS code. ">OSRImportFromEPSG()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nCode</td><td>a GCS or PCS code from the horizontal coordinate system table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success, or an error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="aaa6965a1df98cdc673dfb20697eab613"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::importFromEPSGA </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize SRS based on EPSG GCS or PCS code. </p>
<p>This method will initialize the spatial reference based on the passed in EPSG GCS or PCS code.</p>
<p>This method is similar to <a class="el" href="classOGRSpatialReference.html#a8a5b8c9a205eedc6b88a14aa0c219969" title="Initialize SRS based on EPSG GCS or PCS code. ">importFromEPSG()</a> except that EPSG preferred axis ordering <em>will</em> be applied for geographic and projected coordinate systems. EPSG normally defines geographic coordinate systems to use lat/long, and also there are also a few projected coordinate systems that use northing/easting order contrary to typical GIS use). See <a class="el" href="classOGRSpatialReference.html#a8a5b8c9a205eedc6b88a14aa0c219969" title="Initialize SRS based on EPSG GCS or PCS code. ">OGRSpatialReference::importFromEPSG()</a> for more details on operation of this method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#ac9055a15f525928635e067b569c60143" title="Initialize SRS based on EPSG GCS or PCS code. ">OSRImportFromEPSGA()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nCode</td><td>a GCS or PCS code from the horizontal coordinate system table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success, or an error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="aae4588813e3034a0d920a5787ff71a32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::importFromERM </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszProj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDatum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszUnits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create OGR WKT from ERMapper projection definitions. </p>
<p>Generates an <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a> definition from an ERMapper datum and projection name. Based on the ecw_cs.wkt dictionary file from gdal/data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszProj</td><td>the projection name, such as "NUTM11" or "GEOGRAPHIC". </td></tr>
    <tr><td class="paramname">pszDatum</td><td>the datum name, such as "NAD83". </td></tr>
    <tr><td class="paramname">pszUnits</td><td>the linear units "FEET" or "METERS".</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or OGRERR_UNSUPPORTED_SRS if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="af91af2639702e2793daf93ffe231b577"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::importFromESRI </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszPrj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import coordinate system from ESRI .prj format(s). </p>
<p>This function will read the text loaded from an ESRI .prj file, and translate it into an <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a> definition. This should support many (but by no means all) old style (Arc/Info 7.x) .prj files, as well as the newer pseudo-OGC WKT .prj files. Note that new style .prj files are in OGC WKT format, but require some manipulation to correct datum names, and units on some projection parameters. This is addressed within <a class="el" href="classOGRSpatialReference.html#af91af2639702e2793daf93ffe231b577" title="Import coordinate system from ESRI .prj format(s). ">importFromESRI()</a> by an automatic call to <a class="el" href="classOGRSpatialReference.html#ad556dfdc04d9ec5f1714fc6b5e0eb6a6" title="Convert in place from ESRI WKT format. ">morphFromESRI()</a>.</p>
<p>Currently only GEOGRAPHIC, UTM, STATEPLANE, GREATBRITIAN_GRID, ALBERS, EQUIDISTANT_CONIC, TRANSVERSE (mercator), POLAR, MERCATOR and POLYCONIC projections are supported from old style files.</p>
<p>At this time there is no equivalent exportToESRI() method. Writing old style .prj files is not supported by <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a>. However the <a class="el" href="classOGRSpatialReference.html#aac948450b15fa3d8814ab440b9f705b7" title="Convert in place to ESRI WKT format. ">morphToESRI()</a> and <a class="el" href="classOGRSpatialReference.html#a596b8e527d66a5054408159f0006fdac" title="Convert this SRS into WKT format. ">exportToWkt()</a> methods can be used to generate output suitable to write to new style (Arc 8) .prj files.</p>
<p>This function is the equivalent of the C function <a class="el" href="ogr__srs__api_8h.html#acfd57b2a82d46ac397ad7c88421e0033" title="Import coordinate system from ESRI .prj format(s). ">OSRImportFromESRI()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszPrj</td><td>NULL terminated list of strings containing the definition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or an error code in case of failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a1acf0f6cac3125cc878a99433033c140"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::importFromMICoordSys </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszCoordSys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import Mapinfo style CoordSys definition. </p>
<p>The <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a> is initialized from the passed Mapinfo style CoordSys definition string.</p>
<p>This method is the equivalent of the C function <a class="el" href="ogr__srs__api_8h.html#a18dd08b904ee99dd777721c5963d1726" title="Import Mapinfo style CoordSys definition. ">OSRImportFromMICoordSys()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszCoordSys</td><td>Mapinfo style CoordSys definition string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success, OGRERR_FAILURE on failure, OGRERR_UNSUPPORTED_OPERATION if MITAB library was not linked in. </dd></dl>

</div>
</div>
<a class="anchor" id="a84c754327d7081c25358e1a4a6dcf002"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::importFromOzi </td>
          <td>(</td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>papszLines</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import coordinate system from OziExplorer projection definition. </p>
<p>This method will import projection definition in style, used by OziExplorer software.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszLines</td><td>Map file lines. This is an array of strings containing the whole OziExplorer .MAP file. The array is terminated by a NULL pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or an error code in case of failure.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.10 </dd></dl>

</div>
</div>
<a class="anchor" id="a6a534e7d862a17c92a31d821848533c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::importFromPanorama </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>iProjSys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>iDatum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>iEllips</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>padfPrjParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import coordinate system from "Panorama" GIS projection definition. </p>
<p>This method will import projection definition in style, used by "Panorama" GIS.</p>
<p>This function is the equivalent of the C function <a class="el" href="ogr__srs__api_8h.html#a8686cfebd0a29f9e4b591dce6822d387" title="Import coordinate system from &quot;Panorama&quot; GIS projection definition. ">OSRImportFromPanorama()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iProjSys</td><td>Input projection system code, used in GIS "Panorama". <pre class="fragment"> &lt;h4&gt;Supported Projections&lt;/h4&gt;
</pre> <pre>
     1:  Gauss-Kruger (Transverse Mercator)
     2:  Lambert Conformal Conic 2SP
     5:  Stereographic
     6:  Azimuthal Equidistant (Postel)
     8:  Mercator
     10: Polyconic
     13: Polar Stereographic
     15: Gnomonic
     17: Universal Transverse Mercator (UTM)
     18: Wagner I (Kavraisky VI)
     19: Mollweide
     20: Equidistant Conic
     24: Lambert Azimuthal Equal Area
     27: Equirectangular
     28: Cylindrical Equal Area (Lambert)
     29: International Map of the World Polyconic
</pre></td></tr>
    <tr><td class="paramname">iDatum</td><td>Input coordinate system. <pre class="fragment"> &lt;h4&gt;Supported Datums&lt;/h4&gt;
</pre> <pre>
      1: Pulkovo, 1942
      2: WGS, 1984
      3: OSGB 1936 (British National Grid)
      9: Pulkovo, 1995
</pre></td></tr>
    <tr><td class="paramname">iEllips</td><td>Input spheroid. <pre class="fragment"> &lt;h4&gt;Supported Spheroids&lt;/h4&gt;
</pre> <pre>
      1: Krassovsky, 1940
      2: WGS, 1972
      3: International, 1924 (Hayford, 1909)
      4: Clarke, 1880
      5: Clarke, 1866 (NAD1927)
      6: Everest, 1830
      7: Bessel, 1841
      8: Airy, 1830
      9: WGS, 1984 (GPS)
</pre></td></tr>
    <tr><td class="paramname">padfPrjParams</td><td>Array of 8 coordinate system parameters:</td></tr>
  </table>
  </dd>
</dl>
<pre>
     [0]  Latitude of the first standard parallel (radians)
     [1]  Latitude of the second standard parallel (radians)
     [2]  Latitude of center of projection (radians)
     [3]  Longitude of center of projection (radians)
     [4]  Scaling factor
     [5]  False Easting
     [6]  False Northing
     [7]  Zone number
</pre><p>Particular projection uses different parameters, unused ones may be set to zero. If NULL supplied instead of array pointer default values will be used (i.e., zeroes).</p>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or an error code in case of failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a4739e78e7e2c81d61bb5fc9d9cdde8ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::importFromPCI </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszProj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszUnits</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>padfPrjParams</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import coordinate system from PCI projection definition. </p>
<p>PCI software uses 16-character string to specify coordinate system and datum/ellipsoid. You should supply at least this string to the <a class="el" href="classOGRSpatialReference.html#a4739e78e7e2c81d61bb5fc9d9cdde8ee" title="Import coordinate system from PCI projection definition. ">importFromPCI()</a> function.</p>
<p>This function is the equivalent of the C function <a class="el" href="ogr__srs__api_8h.html#a348621e754694226a862ab59123c8beb" title="Import coordinate system from PCI projection definition. ">OSRImportFromPCI()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszProj</td><td>NULL terminated string containing the definition. Looks like "pppppppppppp Ennn" or "pppppppppppp Dnnn", where "pppppppppppp" is a projection code, "Ennn" is an ellipsoid code, "Dnnn" &mdash; a datum code.</td></tr>
    <tr><td class="paramname">pszUnits</td><td>Grid units code ("DEGREE" or "METRE"). If NULL "METRE" will be used.</td></tr>
    <tr><td class="paramname">padfPrjParams</td><td>Array of 17 coordinate system parameters:</td></tr>
  </table>
  </dd>
</dl>
<p>[0] Spheroid semi major axis [1] Spheroid semi minor axis [2] Reference Longitude [3] Reference Latitude [4] First Standard Parallel [5] Second Standard Parallel [6] False Easting [7] False Northing [8] Scale Factor [9] Height above sphere surface [10] Longitude of 1st point on center line [11] Latitude of 1st point on center line [12] Longitude of 2nd point on center line [13] Latitude of 2nd point on center line [14] Azimuth east of north for center line [15] Landsat satellite number [16] Landsat path number</p>
<p>Particular projection uses different parameters, unused ones may be set to zero. If NULL is supplied instead of an array pointer, default values will be used (i.e., zeroes).</p>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or an error code in case of failure. </dd></dl>

</div>
</div>
<a class="anchor" id="af1a29550373c2c14bd11514641e58e7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::importFromProj4 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszProj4</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import PROJ.4 coordinate string. </p>
<p>The <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a> is initialized from the passed PROJ.4 style coordinate system string. In addition to many +proj formulations which have OGC equivalents, it is also possible to import "+init=epsg:n" style definitions. These are passed to <a class="el" href="classOGRSpatialReference.html#a8a5b8c9a205eedc6b88a14aa0c219969" title="Initialize SRS based on EPSG GCS or PCS code. ">importFromEPSG()</a>. Other init strings (such as the state plane zones) are not currently supported.</p>
<p>Example: pszProj4 = "+proj=utm +zone=11 +datum=WGS84"</p>
<p>Some parameters, such as grids, recognized by PROJ.4 may not be well understood and translated into the <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a> model. It is possible to add the +wktext parameter which is a special keyword that OGR recognized as meaning "embed the entire PROJ.4 string in the WKT and use it literally
when converting back to PROJ.4 format".</p>
<p>For example: "+proj=nzmg +lat_0=-41 +lon_0=173 +x_0=2510000 +y_0=6023150 +ellps=intl
 +units=m +nadgrids=nzgd2kgrid0005.gsb +wktext"</p>
<p>will be translated as : </p><div class="fragment"><div class="line">PROJCS[<span class="stringliteral">&quot;unnamed&quot;</span>,</div>
<div class="line">   GEOGCS[<span class="stringliteral">&quot;International 1909 (Hayford)&quot;</span>,</div>
<div class="line">       DATUM[<span class="stringliteral">&quot;unknown&quot;</span>,</div>
<div class="line">           SPHEROID[<span class="stringliteral">&quot;intl&quot;</span>,6378388,297]],</div>
<div class="line">       PRIMEM[<span class="stringliteral">&quot;Greenwich&quot;</span>,0],</div>
<div class="line">       UNIT[<span class="stringliteral">&quot;degree&quot;</span>,0.0174532925199433]],</div>
<div class="line">   PROJECTION[<span class="stringliteral">&quot;New_Zealand_Map_Grid&quot;</span>],</div>
<div class="line">   PARAMETER[<span class="stringliteral">&quot;latitude_of_origin&quot;</span>,-41],</div>
<div class="line">   PARAMETER[<span class="stringliteral">&quot;central_meridian&quot;</span>,173],</div>
<div class="line">   PARAMETER[<span class="stringliteral">&quot;false_easting&quot;</span>,2510000],</div>
<div class="line">   PARAMETER[<span class="stringliteral">&quot;false_northing&quot;</span>,6023150],</div>
<div class="line">   UNIT[<span class="stringliteral">&quot;Meter&quot;</span>,1],</div>
<div class="line">   EXTENSION[<span class="stringliteral">&quot;PROJ4&quot;</span>,<span class="stringliteral">&quot;+proj=nzmg +lat_0=-41 +lon_0=173 +x_0=2510000</span></div>
<div class="line"><span class="stringliteral">              +y_0=6023150 +ellps=intl  +units=m +nadgrids=nzgd2kgrid0005.gsb +wktext&quot;</span>]]</div>
</div><!-- fragment --><p>Special processing for 'etmerc' (GDAL &gt;= 1.10 ): if +proj=etmerc is found in the passed string, the SRS built will use the WKT representation for a standard Transverse Mercator, but will aso include a PROJ4 EXTENSION node to preserve the etmerc projection method.</p>
<p>For example: "+proj=etmerc +lat_0=0 +lon_0=9 +k=0.9996 +units=m +x_0=500000 +datum=WGS84"</p>
<p>will be translated as : </p><div class="fragment"><div class="line">PROJCS[<span class="stringliteral">&quot;unnamed&quot;</span>,</div>
<div class="line">    GEOGCS[<span class="stringliteral">&quot;WGS 84&quot;</span>,</div>
<div class="line">        DATUM[<span class="stringliteral">&quot;WGS_1984&quot;</span>,</div>
<div class="line">            SPHEROID[<span class="stringliteral">&quot;WGS 84&quot;</span>,6378137,298.257223563,</div>
<div class="line">                AUTHORITY[<span class="stringliteral">&quot;EPSG&quot;</span>,<span class="stringliteral">&quot;7030&quot;</span>]],</div>
<div class="line">            TOWGS84[0,0,0,0,0,0,0],</div>
<div class="line">            AUTHORITY[<span class="stringliteral">&quot;EPSG&quot;</span>,<span class="stringliteral">&quot;6326&quot;</span>]],</div>
<div class="line">        PRIMEM[<span class="stringliteral">&quot;Greenwich&quot;</span>,0,</div>
<div class="line">            AUTHORITY[<span class="stringliteral">&quot;EPSG&quot;</span>,<span class="stringliteral">&quot;8901&quot;</span>]],</div>
<div class="line">        UNIT[<span class="stringliteral">&quot;degree&quot;</span>,0.0174532925199433,</div>
<div class="line">            AUTHORITY[<span class="stringliteral">&quot;EPSG&quot;</span>,<span class="stringliteral">&quot;9108&quot;</span>]],</div>
<div class="line">        AUTHORITY[<span class="stringliteral">&quot;EPSG&quot;</span>,<span class="stringliteral">&quot;4326&quot;</span>]],</div>
<div class="line">    PROJECTION[<span class="stringliteral">&quot;Transverse_Mercator&quot;</span>],</div>
<div class="line">    PARAMETER[<span class="stringliteral">&quot;latitude_of_origin&quot;</span>,0],</div>
<div class="line">    PARAMETER[<span class="stringliteral">&quot;central_meridian&quot;</span>,9],</div>
<div class="line">    PARAMETER[<span class="stringliteral">&quot;scale_factor&quot;</span>,0.9996],</div>
<div class="line">    PARAMETER[<span class="stringliteral">&quot;false_easting&quot;</span>,500000],</div>
<div class="line">    PARAMETER[<span class="stringliteral">&quot;false_northing&quot;</span>,0],</div>
<div class="line">    UNIT[<span class="stringliteral">&quot;Meter&quot;</span>,1],</div>
<div class="line">    EXTENSION[<span class="stringliteral">&quot;PROJ4&quot;</span>,<span class="stringliteral">&quot;+proj=etmerc +lat_0=0 +lon_0=9 +k=0.9996 +units=m +x_0=500000 +datum=WGS84 +nodefs&quot;</span>]]</div>
</div><!-- fragment --><p>This method is the equivalent of the C function <a class="el" href="ogr__srs__api_8h.html#a4087bdeb58fce4892fa70fa823d267c5" title="Import PROJ.4 coordinate string. ">OSRImportFromProj4()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszProj4</td><td>the PROJ.4 style string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or OGRERR_CORRUPT_DATA on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a93d00386ac9ce5db2f9b6e651afa442f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::importFromUrl </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszUrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set spatial reference from a URL. </p>
<p>This method will download the spatial reference at a given URL and feed it into SetFromUserInput for you.</p>
<p>This method does the same thing as the <a class="el" href="ogr__srs__api_8h.html#afc58492e53a11feb45ab9399f871a280" title="Set spatial reference from a URL. ">OSRImportFromUrl()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszUrl</td><td>text definition to try to deduce SRS from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success, or an error code with the curl error message if it is unable to dowload data. </dd></dl>

</div>
</div>
<a class="anchor" id="a6ca72094be024d06925d0e610c298cce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::importFromURN </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszURN</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize from OGC URN. </p>
<p>Initializes this spatial reference from a coordinate system defined by an OGC URN prefixed with "urn:ogc:def:crs:" per recommendation paper 06-023r1. Currently EPSG and OGC authority values are supported, including OGC auto codes, but not including CRS1 or CRS88 (NAVD88).</p>
<p>This method is also support through <a class="el" href="classOGRSpatialReference.html#aec3c6a49533fe457ddc763d699ff8796" title="Set spatial reference from various text formats. ">SetFromUserInput()</a> which can normally be used for URNs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszURN</td><td>the urn string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or an error code. </dd></dl>

</div>
</div>
<a class="anchor" id="a4a971615901e5c4a028e6b49fb5918d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::importFromUSGS </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>iProjSys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>iZone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>padfPrjParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>iDatum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nUSGSAngleFormat</em> = <code><a class="el" href="ogr__spatialref_8h.html#aa98003ee785627b86a8bfc53e309b0bd">USGS_ANGLE_PACKEDDMS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import coordinate system from USGS projection definition. </p>
<p>This method will import projection definition in style, used by USGS GCTP software. GCTP operates on angles in packed DMS format (see <a class="el" href="cpl__conv_8h.html#a97b69cc886a1a5c9618612d8205600e4" title="Convert decimal degrees into packed DMS value (DDDMMMSSS.SS). ">CPLDecToPackedDMS()</a> function for details), so all angle values (latitudes, longitudes, azimuths, etc.) specified in the padfPrjParams array should be in the packed DMS format, unless bAnglesInPackedDMSFormat is set to FALSE.</p>
<p>This function is the equivalent of the C function <a class="el" href="ogr__srs__api_8h.html#a62d08d5bc8db8f73a443365005847c6e" title="Import coordinate system from USGS projection definition. ">OSRImportFromUSGS()</a>. Note that the bAnglesInPackedDMSFormat parameter is only present in the C++ method. The C function assumes bAnglesInPackedFormat = TRUE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iProjSys</td><td>Input projection system code, used in GCTP.</td></tr>
    <tr><td class="paramname">iZone</td><td>Input zone for UTM and State Plane projection systems. For Southern Hemisphere UTM use a negative zone code. iZone ignored for all other projections.</td></tr>
    <tr><td class="paramname">padfPrjParams</td><td>Array of 15 coordinate system parameters. These parameters differs for different projections.</td></tr>
  </table>
  </dd>
</dl>
<h4>Projection Transformation Package Projection Parameters</h4>
<pre>
----------------------------------------------------------------------------
                        |                    Array Element
 Code &amp; Projection Id   |---------------------------------------------------
                        |   0  |   1  |  2   |  3   |   4   |    5    |6 | 7
----------------------------------------------------------------------------
 0 Geographic           |      |      |      |      |       |         |  |
 1 U T M                |Lon/Z |Lat/Z |      |      |       |         |  |
 2 State Plane          |      |      |      |      |       |         |  |
 3 Albers Equal Area    |SMajor|SMinor|STDPR1|STDPR2|CentMer|OriginLat|FE|FN
 4 Lambert Conformal C  |SMajor|SMinor|STDPR1|STDPR2|CentMer|OriginLat|FE|FN
 5 Mercator             |SMajor|SMinor|      |      |CentMer|TrueScale|FE|FN
 6 Polar Stereographic  |SMajor|SMinor|      |      |LongPol|TrueScale|FE|FN
 7 Polyconic            |SMajor|SMinor|      |      |CentMer|OriginLat|FE|FN
 8 Equid. Conic A       |SMajor|SMinor|STDPAR|      |CentMer|OriginLat|FE|FN
   Equid. Conic B       |SMajor|SMinor|STDPR1|STDPR2|CentMer|OriginLat|FE|FN
 9 Transverse Mercator  |SMajor|SMinor|Factor|      |CentMer|OriginLat|FE|FN
10 Stereographic        |Sphere|      |      |      |CentLon|CenterLat|FE|FN
11 Lambert Azimuthal    |Sphere|      |      |      |CentLon|CenterLat|FE|FN
12 Azimuthal            |Sphere|      |      |      |CentLon|CenterLat|FE|FN
13 Gnomonic             |Sphere|      |      |      |CentLon|CenterLat|FE|FN
14 Orthographic         |Sphere|      |      |      |CentLon|CenterLat|FE|FN
15 Gen. Vert. Near Per  |Sphere|      |Height|      |CentLon|CenterLat|FE|FN
16 Sinusoidal           |Sphere|      |      |      |CentMer|         |FE|FN
17 Equirectangular      |Sphere|      |      |      |CentMer|TrueScale|FE|FN
18 Miller Cylindrical   |Sphere|      |      |      |CentMer|         |FE|FN
19 Van der Grinten      |Sphere|      |      |      |CentMer|OriginLat|FE|FN
20 Hotin Oblique Merc A |SMajor|SMinor|Factor|      |       |OriginLat|FE|FN
   Hotin Oblique Merc B |SMajor|SMinor|Factor|AziAng|AzmthPt|OriginLat|FE|FN
21 Robinson             |Sphere|      |      |      |CentMer|         |FE|FN
22 Space Oblique Merc A |SMajor|SMinor|      |IncAng|AscLong|         |FE|FN
   Space Oblique Merc B |SMajor|SMinor|Satnum|Path  |       |         |FE|FN
23 Alaska Conformal     |SMajor|SMinor|      |      |       |         |FE|FN
24 Interrupted Goode    |Sphere|      |      |      |       |         |  |
25 Mollweide            |Sphere|      |      |      |CentMer|         |FE|FN
26 Interrupt Mollweide  |Sphere|      |      |      |       |         |  |
27 Hammer               |Sphere|      |      |      |CentMer|         |FE|FN
28 Wagner IV            |Sphere|      |      |      |CentMer|         |FE|FN
29 Wagner VII           |Sphere|      |      |      |CentMer|         |FE|FN
30 Oblated Equal Area   |Sphere|      |Shapem|Shapen|CentLon|CenterLat|FE|FN
----------------------------------------------------------------------------</pre><pre>      ----------------------------------------------------
                              |      Array Element       |
        Code &amp; Projection Id  |---------------------------
                              |  8  |  9 |  10 | 11 | 12 |
      ----------------------------------------------------
       0 Geographic           |     |    |     |    |    |
       1 U T M                |     |    |     |    |    |
       2 State Plane          |     |    |     |    |    |
       3 Albers Equal Area    |     |    |     |    |    |
       4 Lambert Conformal C  |     |    |     |    |    |
       5 Mercator             |     |    |     |    |    |
       6 Polar Stereographic  |     |    |     |    |    |
       7 Polyconic            |     |    |     |    |    |
       8 Equid. Conic A       |zero |    |     |    |    |
         Equid. Conic B       |one  |    |     |    |    |
       9 Transverse Mercator  |     |    |     |    |    |
      10 Stereographic        |     |    |     |    |    |
      11 Lambert Azimuthal    |     |    |     |    |    |
      12 Azimuthal            |     |    |     |    |    |
      13 Gnomonic             |     |    |     |    |    |
      14 Orthographic         |     |    |     |    |    |
      15 Gen. Vert. Near Per  |     |    |     |    |    |
      16 Sinusoidal           |     |    |     |    |    |
      17 Equirectangular      |     |    |     |    |    |
      18 Miller Cylindrical   |     |    |     |    |    |
      19 Van der Grinten      |     |    |     |    |    |
      20 Hotin Oblique Merc A |Long1|Lat1|Long2|Lat2|zero|
         Hotin Oblique Merc B |     |    |     |    |one |
      21 Robinson             |     |    |     |    |    |
      22 Space Oblique Merc A |PSRev|LRat|PFlag|    |zero|
         Space Oblique Merc B |     |    |     |    |one |
      23 Alaska Conformal     |     |    |     |    |    |
      24 Interrupted Goode    |     |    |     |    |    |
      25 Mollweide            |     |    |     |    |    |
      26 Interrupt Mollweide  |     |    |     |    |    |
      27 Hammer               |     |    |     |    |    |
      28 Wagner IV            |     |    |     |    |    |
      29 Wagner VII           |     |    |     |    |    |
      30 Oblated Equal Area   |Angle|    |     |    |    |
      ----------------------------------------------------</pre><pre>  where</pre><pre>   Lon/Z     Longitude of any point in the UTM zone or zero.  If zero,
             a zone code must be specified.
   Lat/Z     Latitude of any point in the UTM zone or zero.  If zero, a
             zone code must be specified.
   SMajor    Semi-major axis of ellipsoid.  If zero, Clarke 1866 in meters
             is assumed.
   SMinor    Eccentricity squared of the ellipsoid if less than zero,
             if zero, a spherical form is assumed, or if greater than
             zero, the semi-minor axis of ellipsoid.
   Sphere    Radius of reference sphere.  If zero, 6370997 meters is used.
   STDPAR    Latitude of the standard parallel
   STDPR1    Latitude of the first standard parallel
   STDPR2    Latitude of the second standard parallel
   CentMer   Longitude of the central meridian
   OriginLat Latitude of the projection origin
   FE        False easting in the same units as the semi-major axis
   FN        False northing in the same units as the semi-major axis
   TrueScale Latitude of true scale
   LongPol   Longitude down below pole of map
   Factor    Scale factor at central meridian (Transverse Mercator) or
             center of projection (Hotine Oblique Mercator)
   CentLon   Longitude of center of projection
   CenterLat Latitude of center of projection
   Height    Height of perspective point
   Long1     Longitude of first point on center line (Hotine Oblique
             Mercator, format A)
   Long2     Longitude of second point on center line (Hotine Oblique
             Mercator, format A)
   Lat1      Latitude of first point on center line (Hotine Oblique
             Mercator, format A)
   Lat2      Latitude of second point on center line (Hotine Oblique
             Mercator, format A)
   AziAng    Azimuth angle east of north of center line (Hotine Oblique
             Mercator, format B)
   AzmthPt   Longitude of point on central meridian where azimuth occurs
             (Hotine Oblique Mercator, format B)
   IncAng    Inclination of orbit at ascending node, counter-clockwise
             from equator (SOM, format A)
   AscLong   Longitude of ascending orbit at equator (SOM, format A)
   PSRev     Period of satellite revolution in minutes (SOM, format A)
   LRat      Landsat ratio to compensate for confusion at northern end
             of orbit (SOM, format A -- use 0.5201613)
   PFlag     End of path flag for Landsat:  0 = start of path,
             1 = end of path (SOM, format A)
   Satnum    Landsat Satellite Number (SOM, format B)
   Path      Landsat Path Number (Use WRS-1 for Landsat 1, 2 and 3 and
             WRS-2 for Landsat 4, 5 and 6.)  (SOM, format B)
   Shapem    Oblated Equal Area oval shape parameter m
   Shapen    Oblated Equal Area oval shape parameter n
   Angle     Oblated Equal Area oval rotation angle</pre><pre>Array elements 13 and 14 are set to zero. All array elements with blank
fields are set to zero too.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iDatum</td><td>Input spheroid.</td></tr>
  </table>
  </dd>
</dl>
<p>If the datum code is negative, the first two values in the parameter array (parm) are used to define the values as follows:</p>
<ul>
<li>
<p class="startli">If padfPrjParams[0] is a non-zero value and padfPrjParams[1] is greater than one, the semimajor axis is set to padfPrjParams[0] and the semiminor axis is set to padfPrjParams[1].</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">If padfPrjParams[0] is nonzero and padfPrjParams[1] is greater than zero but less than or equal to one, the semimajor axis is set to padfPrjParams[0] and the semiminor axis is computed from the eccentricity squared value padfPrjParams[1]:</p>
<p></p>
<p>semiminor = sqrt(1.0 - ES) * semimajor</p>
<p></p>
<p>where</p>
<p></p>
<p>ES = eccentricity squared</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">If padfPrjParams[0] is nonzero and padfPrjParams[1] is equal to zero, the semimajor axis and semiminor axis are set to padfPrjParams[0].</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">If padfPrjParams[0] equals zero and padfPrjParams[1] is greater than zero, the default Clarke 1866 is used to assign values to the semimajor axis and semiminor axis.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">If padfPrjParams[0] and padfPrjParams[1] equals zero, the semimajor axis is set to 6370997.0 and the semiminor axis is set to zero.</p>
<p class="endli"></p>
</li>
</ul>
<p>If a datum code is zero or greater, the semimajor and semiminor axis are defined by the datum code as found in the following table:</p>
<h4>Supported Datums</h4>
<pre>
      0: Clarke 1866 (default)
      1: Clarke 1880
      2: Bessel
      3: International 1967
      4: International 1909
      5: WGS 72
      6: Everest
      7: WGS 66
      8: GRS 1980/WGS 84
      9: Airy
     10: Modified Everest
     11: Modified Airy
     12: WGS 84
     13: Southeast Asia
     14: Australian National
     15: Krassovsky
     16: Hough
     17: Mercury 1960
     18: Modified Mercury 1968
     19: Sphere of Radius 6370997 meters
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nUSGSAngleFormat</td><td>one of USGS_ANGLE_DECIMALDEGREES, USGS_ANGLE_PACKEDDMS, or USGS_ANGLE_RADIANS (default is USGS_ANGLE_PACKEDDMS).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or an error code in case of failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ab74cfc985bd05404a4c61d2d633a6343"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::importFromWkt </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppszInput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import from WKT string. </p>
<p>This method will wipe the existing SRS definition, and reassign it based on the contents of the passed WKT string. Only as much of the input string as needed to construct this SRS is consumed from the input string, and the input string pointer is then updated to point to the remaining (unused) input.</p>
<p>Consult also the <a href="wktproblems.html">OGC WKT Coordinate System Issues</a> page for implementation details of WKT in OGR.</p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#a37a167850021c64dfec606e24a1c1e71" title="Import from WKT string. ">OSRImportFromWkt()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppszInput</td><td>Pointer to pointer to input. The pointer is updated to point to remaining unused input text.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if import succeeds, or OGRERR_CORRUPT_DATA if it fails for any reason. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000017">Deprecated:</a></b></dt><dd>GDAL 2.3. Use <a class="el" href="classOGRSpatialReference.html#a4f982e416f26935d5273e36b3a4f673a" title="Import from WKT string. ">importFromWkt(const char**)</a> or <a class="el" href="classOGRSpatialReference.html#a46f20dde8674af858f9399f8a7df6460" title="Import from WKT string. ">importFromWkt(const char*)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4f982e416f26935d5273e36b3a4f673a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::importFromWkt </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>ppszInput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import from WKT string. </p>
<p>This method will wipe the existing SRS definition, and reassign it based on the contents of the passed WKT string. Only as much of the input string as needed to construct this SRS is consumed from the input string, and the input string pointer is then updated to point to the remaining (unused) input.</p>
<p>Consult also the <a href="wktproblems.html">OGC WKT Coordinate System Issues</a> page for implementation details of WKT in OGR.</p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#a37a167850021c64dfec606e24a1c1e71" title="Import from WKT string. ">OSRImportFromWkt()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppszInput</td><td>Pointer to pointer to input. The pointer is updated to point to remaining unused input text.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if import succeeds, or OGRERR_CORRUPT_DATA if it fails for any reason. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a46f20dde8674af858f9399f8a7df6460"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::importFromWkt </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszInput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import from WKT string. </p>
<p>This method will wipe the existing SRS definition, and reassign it based on the contents of the passed WKT string. Only as much of the input string as needed to construct this SRS is consumed from the input string, and the input string pointer is then updated to point to the remaining (unused) input.</p>
<p>Consult also the <a href="wktproblems.html">OGC WKT Coordinate System Issues</a> page for implementation details of WKT in OGR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszInput</td><td>Input WKT</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if import succeeds, or OGRERR_CORRUPT_DATA if it fails for any reason. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a8d1d4cf6b5d2e62ca2fd2162dc80624c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::importFromWMSAUTO </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDefinition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize from WMSAUTO string. </p>
<p>Note that the WMS 1.3 specification does not include the units code, while apparently earlier specs do. We try to guess around this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszDefinition</td><td>the WMSAUTO string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or an error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ae4a9b831b90c3984f96f47936b114adb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::importFromXML </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszXML</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import coordinate system from XML format (GML only currently). </p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#a207f568695989d2ce1eb693082c6370c" title="Import coordinate system from XML format (GML only currently). ">OSRImportFromXML()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszXML</td><td>XML string to import </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or OGRERR_CORRUPT_DATA on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a9965cec08c4333bd90c81fa13556c45e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OGRSpatialReference::IsAngularParameter </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszParameterName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the passed projection parameter an angular one? </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE or FALSE </dd></dl>

</div>
</div>
<a class="anchor" id="a7d8b989c98938e6c4e27eeb6f9871936"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRSpatialReference::IsCompound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if coordinate system is compound. </p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#a8b9c46d909941294dc924a6a7f050f70" title="Check if the coordinate system is compound. ">OSRIsCompound()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if this is rooted with a COMPD_CS node. </dd></dl>

</div>
</div>
<a class="anchor" id="ae65d61b89b5b8087433175344d460fd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRSpatialReference::IsGeocentric </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if geocentric coordinate system. </p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#a8e9df0f961666b9f952351b072b88e4b" title="Check if geocentric coordinate system. ">OSRIsGeocentric()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if this contains a GEOCCS node indicating a it is a geocentric coordinate system.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a764ba5d91530ad721d78ac629c0eaba8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRSpatialReference::IsGeographic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if geographic coordinate system. </p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#ae1f16b6ec2c99eb83352617c0082567d" title="Check if geographic coordinate system. ">OSRIsGeographic()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if this spatial reference is geographic ... that is the root is a GEOGCS node. </dd></dl>

</div>
</div>
<a class="anchor" id="a7914541a3b475b8e5a8f5ffcf2c247c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OGRSpatialReference::IsLinearParameter </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszParameterName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the passed projection parameter an linear one measured in meters or some similar linear measure. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE or FALSE </dd></dl>

</div>
</div>
<a class="anchor" id="a1820ea6fe590dc39e22b5474464ca02a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRSpatialReference::IsLocal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if local coordinate system. </p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#abbdbc07509c887fb98bcc88231d27336" title="Check if local coordinate system. ">OSRIsLocal()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if this spatial reference is local ... that is the root is a LOCAL_CS node. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e5c06ef84e5c97ecf117c81e8058deb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OGRSpatialReference::IsLongitudeParameter </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszParameterName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the passed projection parameter an angular longitude (relative to a prime meridian)? </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE or FALSE </dd></dl>

</div>
</div>
<a class="anchor" id="a1186e3473d7ac2f81ec2ca5d0c4ec027"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRSpatialReference::IsProjected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if projected coordinate system. </p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#a7242007d0275ba5b0e2852206f31ec57" title="Check if projected coordinate system. ">OSRIsProjected()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if this contains a PROJCS node indicating a it is a projected coordinate system. </dd></dl>

</div>
</div>
<a class="anchor" id="a17fd82b2f58a976a30358b076a2fc966"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRSpatialReference::IsSame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&#160;</td>
          <td class="paramname"><em>poOtherSRS</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do these two spatial references describe the same system ? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOtherSRS</td><td>the SRS being compared to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if equivalent or FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a1d916c0a06d27eb441f99aaaabbed368"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRSpatialReference::IsSame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&#160;</td>
          <td class="paramname"><em>poOtherSRS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do these two spatial references describe the same system ? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOtherSRS</td><td>the SRS being compared to. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>options. DATUM=STRICT/IGNORE. TOWGS84=STRICT/ONLY_IF_IN_BOTH/IGNORE</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if equivalent or FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a8b6df2af4faf5de4af8cc935e9b38be5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRSpatialReference::IsSameGeogCS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&#160;</td>
          <td class="paramname"><em>poOther</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do the GeogCS'es match? </p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#a8dc40ce571af8458fcb341e59a609ec6" title="Do the GeogCS&#39;es match? ">OSRIsSameGeogCS()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOther</td><td>the SRS being compared against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if they are the same or FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a191643d7e707a9b72b33450b225a73a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRSpatialReference::IsSameGeogCS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&#160;</td>
          <td class="paramname"><em>poOther</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do the GeogCS'es match? </p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#a8dc40ce571af8458fcb341e59a609ec6" title="Do the GeogCS&#39;es match? ">OSRIsSameGeogCS()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOther</td><td>the SRS being compared against. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>options. DATUM=STRICT/IGNORE. TOWGS84=STRICT/ONLY_IF_IN_BOTH/IGNORE</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if they are the same or FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ac886436c45b2e7e18c14ed3cb33ee058"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRSpatialReference::IsSameVertCS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&#160;</td>
          <td class="paramname"><em>poOther</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do the VertCS'es match? </p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#aaad5acd6c15b4b91ec213cb5316f9c99" title="Do the VertCS&#39;es match? ">OSRIsSameVertCS()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOther</td><td>the SRS being compared against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if they are the same or FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ac16afe94b0d129c0b47e04a6f8b78bef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRSpatialReference::IsVertical </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if vertical coordinate system. </p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#a330735e4ed923c337183f927d49d9b91" title="Check if vertical coordinate system. ">OSRIsVertical()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if this contains a VERT_CS node indicating a it is a vertical coordinate system.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ad556dfdc04d9ec5f1714fc6b5e0eb6a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::morphFromESRI </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert in place from ESRI WKT format. </p>
<p>The value notes of this coordinate system are modified in various manners to adhere more closely to the WKT standard. This mostly involves translating a variety of ESRI names for projections, arguments and datums to "standard" names, as defined by Adam Gawne-Cain's reference translation of EPSG to WKT for the CT specification.</p>
<p>Starting with GDAL 1.9.0, missing parameters in TOWGS84, DATUM or GEOGCS nodes can be added to the WKT, comparing existing WKT parameters to GDAL's databases. Note that this optional procedure is very conservative and should not introduce false information into the WKT definition (although caution should be advised when activating it). Needs the Configuration Option GDAL_FIX_ESRI_WKT be set to one of the following values (TOWGS84 is recommended for proper datum shift calculations):</p>
<p><b>GDAL_FIX_ESRI_WKT values</b> </p><table  border="0">
<tr>
<td>&#160;&#160;</td><td><b>TOWGS84</b></td><td>&#160;&#160;</td><td>Adds missing TOWGS84 parameters (necessary for datum transformations), based on named datum and spheroid values. </td></tr>
<tr>
<td>&#160;&#160;</td><td><b>DATUM</b></td><td>&#160;&#160;</td><td>Adds EPSG AUTHORITY nodes and sets SPHEROID name to OGR spec. </td></tr>
<tr>
<td>&#160;&#160;</td><td><b>GEOGCS</b></td><td>&#160;&#160;</td><td>Adds EPSG AUTHORITY nodes and sets GEOGCS, DATUM and SPHEROID names to OGR spec. Effectively replaces GEOGCS node with the result of importFromEPSG(n), using EPSG code n corresponding to the existing GEOGCS. Does not impact PROJCS values. </td></tr>
</table>
<p>This does the same as the C function <a class="el" href="ogr__srs__api_8h.html#a3e266dd3a10f874ebcad8b7b7b1c153c" title="Convert in place from ESRI WKT format. ">OSRMorphFromESRI()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE unless something goes badly wrong. </dd></dl>

</div>
</div>
<a class="anchor" id="aac948450b15fa3d8814ab440b9f705b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::morphToESRI </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert in place to ESRI WKT format. </p>
<p>The value nodes of this coordinate system are modified in various manners more closely map onto the ESRI concept of WKT format. This includes renaming a variety of projections and arguments, and stripping out nodes note recognised by ESRI (like AUTHORITY and AXIS).</p>
<p>This does the same as the C function <a class="el" href="ogr__srs__api_8h.html#af04f918b0d4f9e16ae16087dea02e03f" title="Convert in place to ESRI WKT format. ">OSRMorphToESRI()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE unless something goes badly wrong. </dd></dl>

</div>
</div>
<a class="anchor" id="a97b8c92ac66cd8519f7c5f941e307b6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> &amp; OGRSpatialReference::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> &amp;&#160;</td>
          <td class="paramname"><em>oSource</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oSource</td><td>SRS to assign to *this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this </dd></dl>

</div>
</div>
<a class="anchor" id="a4b638c33c0a2b53e59fe694f26f8f89c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRSpatialReference::Reference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increments the reference count by one. </p>
<p>The reference count is used keep track of the number of <a class="el" href="classOGRGeometry.html" title="Abstract base class for all geometry classes. ">OGRGeometry</a> objects referencing this SRS.</p>
<p>The method does the same thing as the C function <a class="el" href="ogr__srs__api_8h.html#a836d17c587f924446f3734f600758c6d" title="Increments the reference count by one. ">OSRReference()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the updated reference count. </dd></dl>

</div>
</div>
<a class="anchor" id="aef9a8378c266604b9cd09042597a649f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRSpatialReference::Release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrements the reference count by one, and destroy if zero. </p>
<p>The method does the same thing as the C function <a class="el" href="ogr__srs__api_8h.html#adb5e564701dab4e83b3d353745f4a054" title="Decrements the reference count by one, and destroy if zero. ">OSRRelease()</a>. </p>

</div>
</div>
<a class="anchor" id="a23784d4bfc74a92ba816edeeab90d225"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::SetAngularUnits </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszUnitsName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfInRadians</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the angular units for the geographic coordinate system. </p>
<p>This method creates a UNIT subnode with the specified values as a child of the GEOGCS node.</p>
<p>This method does the same as the C function <a class="el" href="ogr__srs__api_8h.html#ad07e3ac14dc34dbb951699838a434ece" title="Set the angular units for the geographic coordinate system. ">OSRSetAngularUnits()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszUnitsName</td><td>the units name to be used. Some preferred units names can be found in <a class="el" href="ogr__srs__api_8h.html" title="C spatial reference system services and defines. ">ogr_srs_api.h</a> such as SRS_UA_DEGREE.</td></tr>
    <tr><td class="paramname">dfInRadians</td><td>the value to multiple by an angle in the indicated units to transform to radians. Some standard conversion factors can be found in <a class="el" href="ogr__srs__api_8h.html" title="C spatial reference system services and defines. ">ogr_srs_api.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a6918e6680d8de01c6e435235a8a222c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::SetAuthority </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszTargetKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszAuthority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the authority for a node. </p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#aca458410eee98928c4a245cdef242f6e" title="Set the authority for a node. ">OSRSetAuthority()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszTargetKey</td><td>the partial or complete path to the node to set an authority on. i.e. "PROJCS", "GEOGCS" or "GEOGCS|UNIT".</td></tr>
    <tr><td class="paramname">pszAuthority</td><td>authority name, such as "EPSG".</td></tr>
    <tr><td class="paramname">nCode</td><td>code for value with this authority.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a2298795cd7efad5ff24ebbefa3606c0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::SetAxes </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszTargetKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszXAxisName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__srs__api_8h.html#ae247bb1b37409553c72a78bd3b6d65b6">OGRAxisOrientation</a>&#160;</td>
          <td class="paramname"><em>eXAxisOrientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszYAxisName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__srs__api_8h.html#ae247bb1b37409553c72a78bd3b6d65b6">OGRAxisOrientation</a>&#160;</td>
          <td class="paramname"><em>eYAxisOrientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the axes for a coordinate system. </p>
<p>Set the names, and orientations of the axes for either a projected (PROJCS) or geographic (GEOGCS) coordinate system.</p>
<p>This method is equivalent to the C function <a class="el" href="ogr__srs__api_8h.html#a352621b1c16cd50c29868d945e830b3b" title="Set the axes for a coordinate system. ">OSRSetAxes()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszTargetKey</td><td>either "PROJCS" or "GEOGCS", must already exist in SRS. </td></tr>
    <tr><td class="paramname">pszXAxisName</td><td>name of first axis, normally "Long" or "Easting". </td></tr>
    <tr><td class="paramname">eXAxisOrientation</td><td>normally OAO_East. </td></tr>
    <tr><td class="paramname">pszYAxisName</td><td>name of second axis, normally "Lat" or "Northing". </td></tr>
    <tr><td class="paramname">eYAxisOrientation</td><td>normally OAO_North.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or an error code. </dd></dl>

</div>
</div>
<a class="anchor" id="a6cb94a55501d2444b9f93eacd8ff0411"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::SetCompoundCS </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&#160;</td>
          <td class="paramname"><em>poHorizSRS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&#160;</td>
          <td class="paramname"><em>poVertSRS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setup a compound coordinate system. </p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#aca4c59764c2e326909f318c8ac44661a" title="Setup a compound coordinate system. ">OSRSetCompoundCS()</a>.</p>
<p>This method is replace the current SRS with a COMPD_CS coordinate system consisting of the passed in horizontal and vertical coordinate systems.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszName</td><td>the name of the compound coordinate system.</td></tr>
    <tr><td class="paramname">poHorizSRS</td><td>the horizontal SRS (PROJCS or GEOGCS).</td></tr>
    <tr><td class="paramname">poVertSRS</td><td>the vertical SRS (VERT_CS).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ca469ce2caecc420cc564e661b8325d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::SetExtension </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszTargetKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set extension value. </p>
<p>Set the value of the named EXTENSION item for the identified target node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszTargetKey</td><td>the name or path to the parent node of the EXTENSION. </td></tr>
    <tr><td class="paramname">pszName</td><td>the name of the extension being fetched. </td></tr>
    <tr><td class="paramname">pszValue</td><td>the value to set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success </dd></dl>

</div>
</div>
<a class="anchor" id="aec3c6a49533fe457ddc763d699ff8796"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::SetFromUserInput </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDefinition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set spatial reference from various text formats. </p>
<p>This method will examine the provided input, and try to deduce the format, and then use it to initialize the spatial reference system. It may take the following forms:</p>
<ol>
<li>
Well Known Text definition - passed on to <a class="el" href="classOGRSpatialReference.html#ab74cfc985bd05404a4c61d2d633a6343" title="Import from WKT string. ">importFromWkt()</a>. </li>
<li>
"EPSG:n" - number passed on to <a class="el" href="classOGRSpatialReference.html#a8a5b8c9a205eedc6b88a14aa0c219969" title="Initialize SRS based on EPSG GCS or PCS code. ">importFromEPSG()</a>. </li>
<li>
"EPSGA:n" - number passed on to <a class="el" href="classOGRSpatialReference.html#aaa6965a1df98cdc673dfb20697eab613" title="Initialize SRS based on EPSG GCS or PCS code. ">importFromEPSGA()</a>. </li>
<li>
"AUTO:proj_id,unit_id,lon0,lat0" - WMS auto projections. </li>
<li>
"urn:ogc:def:crs:EPSG::n" - ogc urns </li>
<li>
PROJ.4 definitions - passed on to <a class="el" href="classOGRSpatialReference.html#af1a29550373c2c14bd11514641e58e7c" title="Import PROJ.4 coordinate string. ">importFromProj4()</a>. </li>
<li>
filename - file read for WKT, XML or PROJ.4 definition. </li>
<li>
well known name accepted by <a class="el" href="classOGRSpatialReference.html#a096b8dde4fd2eb475acd376060940b02" title="Set a GeogCS based on well known name. ">SetWellKnownGeogCS()</a>, such as NAD27, NAD83, WGS84 or WGS72. </li>
<li>
WKT (directly or in a file) in ESRI format should be prefixed with ESRI:: to trigger an automatic <a class="el" href="classOGRSpatialReference.html#ad556dfdc04d9ec5f1714fc6b5e0eb6a6" title="Convert in place from ESRI WKT format. ">morphFromESRI()</a>. </li>
<li>
"IGNF:xxx" - "+init=IGNF:xxx" passed on to <a class="el" href="classOGRSpatialReference.html#af1a29550373c2c14bd11514641e58e7c" title="Import PROJ.4 coordinate string. ">importFromProj4()</a>. </li>
</ol>
<p>It is expected that this method will be extended in the future to support XML and perhaps a simplified "minilanguage" for indicating common UTM and State Plane definitions.</p>
<p>This method is intended to be flexible, but by its nature it is imprecise as it must guess information about the format intended. When possible applications should call the specific method appropriate if the input is known to be in a particular format.</p>
<p>This method does the same thing as the <a class="el" href="ogr__srs__api_8h.html#a927749db01cec3af8aa5e577d032956b" title="Set spatial reference from various text formats. ">OSRSetFromUserInput()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszDefinition</td><td>text definition to try to deduce SRS from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success, or an error code if the name isn't recognised, the definition is corrupt, or an EPSG value can't be successfully looked up. </dd></dl>

</div>
</div>
<a class="anchor" id="af909159bd41fd01ea9b42621dfd5bc18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::SetGeocCS </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the user visible GEOCCS name. </p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#a8a1a981b136956aba8765430a4396ba0" title="Set the user visible PROJCS name. ">OSRSetGeocCS()</a>.</p>
<p>This method will ensure a GEOCCS node is created as the root, and set the provided name on it. If used on a GEOGCS coordinate system, the DATUM and PRIMEM nodes from the GEOGCS will be transferred over to the GEOGCS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszName</td><td>the user visible name to assign. Not used as a key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

</div>
</div>
<a class="anchor" id="afb2997a3a7a33cd740c716c5618ac2c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::SetGeogCS </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszGeogName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDatumName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszSpheroidName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfSemiMajor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfInvFlattening</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPMName</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfPMOffset</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszAngularUnits</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfConvertToRadians</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set geographic coordinate system. </p>
<p>This method is used to set the datum, ellipsoid, prime meridian and angular units for a geographic coordinate system. It can be used on its own to establish a geographic spatial reference, or applied to a projected coordinate system to establish the underlying geographic coordinate system.</p>
<p>This method does the same as the C function <a class="el" href="ogr__srs__api_8h.html#a1ffa26c69dd884be497a71e3fb961e1c" title="Set geographic coordinate system. ">OSRSetGeogCS()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszGeogName</td><td>user visible name for the geographic coordinate system (not to serve as a key).</td></tr>
    <tr><td class="paramname">pszDatumName</td><td>key name for this datum. The OpenGIS specification lists some known values, and otherwise EPSG datum names with a standard transformation are considered legal keys.</td></tr>
    <tr><td class="paramname">pszSpheroidName</td><td>user visible spheroid name (not to serve as a key)</td></tr>
    <tr><td class="paramname">dfSemiMajor</td><td>the semi major axis of the spheroid.</td></tr>
    <tr><td class="paramname">dfInvFlattening</td><td>the inverse flattening for the spheroid. This can be computed from the semi minor axis as 1/f = 1.0 / (1.0 - semiminor/semimajor).</td></tr>
    <tr><td class="paramname">pszPMName</td><td>the name of the prime meridian (not to serve as a key) If this is NULL a default value of "Greenwich" will be used.</td></tr>
    <tr><td class="paramname">dfPMOffset</td><td>the longitude of Greenwich relative to this prime meridian.</td></tr>
    <tr><td class="paramname">pszAngularUnits</td><td>the angular units name (see <a class="el" href="ogr__srs__api_8h.html" title="C spatial reference system services and defines. ">ogr_srs_api.h</a> for some standard names). If NULL a value of "degrees" will be assumed.</td></tr>
    <tr><td class="paramname">dfConvertToRadians</td><td>value to multiply angular units by to transform them to radians. A value of SRS_UA_DEGREE_CONV will be used if pszAngularUnits is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a4d13105847002639f0f448167dc922a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::SetHOM </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfCenterLat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfCenterLong</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfAzimuth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfRectToSkew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfFalseEasting</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfFalseNorthing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hotine Oblique Mercator. </p>
<p>Set a Hotine Oblique Mercator projection using azimuth angle.</p>
<p>This projection corresponds to EPSG projection method 9812, also sometimes known as hotine oblique mercator (variant A)..</p>
<p>This method does the same thing as the C function <a class="el" href="ogr__srs__api_8h.html#a9f33598c756fa65efa804667ae236309" title="Hotine Oblique Mercator using azimuth angle. ">OSRSetHOM()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfCenterLat</td><td>Latitude of the projection origin. </td></tr>
    <tr><td class="paramname">dfCenterLong</td><td>Longitude of the projection origin. </td></tr>
    <tr><td class="paramname">dfAzimuth</td><td>Azimuth, measured clockwise from North, of the projection centerline. </td></tr>
    <tr><td class="paramname">dfRectToSkew</td><td>?. </td></tr>
    <tr><td class="paramname">dfScale</td><td>Scale factor applies to the projection origin. </td></tr>
    <tr><td class="paramname">dfFalseEasting</td><td>False easting. </td></tr>
    <tr><td class="paramname">dfFalseNorthing</td><td>False northing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a66530428642a5e5e16f7791c7474fd21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::SetHOM2PNO </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfCenterLat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfLat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfLong1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfLat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfLong2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfFalseEasting</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfFalseNorthing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hotine Oblique Mercator 2 points. </p>
<p>Set a Hotine Oblique Mercator projection using two points on projection centerline.</p>
<p>This method does the same thing as the C function <a class="el" href="ogr__srs__api_8h.html#acf4d4664a26e3d279e7422080e4bee62" title="Hotine Oblique Mercator using two points on centerline. ">OSRSetHOM2PNO()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfCenterLat</td><td>Latitude of the projection origin. </td></tr>
    <tr><td class="paramname">dfLat1</td><td>Latitude of the first point on center line. </td></tr>
    <tr><td class="paramname">dfLong1</td><td>Longitude of the first point on center line. </td></tr>
    <tr><td class="paramname">dfLat2</td><td>Latitude of the second point on center line. </td></tr>
    <tr><td class="paramname">dfLong2</td><td>Longitude of the second point on center line. </td></tr>
    <tr><td class="paramname">dfScale</td><td>Scale factor applies to the projection origin. </td></tr>
    <tr><td class="paramname">dfFalseEasting</td><td>False easting. </td></tr>
    <tr><td class="paramname">dfFalseNorthing</td><td>False northing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b34e9b2030ff8b07e14b988db95ab4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::SetHOMAC </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfCenterLat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfCenterLong</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfAzimuth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfRectToSkew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfFalseEasting</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfFalseNorthing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hotine Oblique Mercator Azimuth Center / Variant B. </p>
<p>Set an Hotine Oblique Mercator Azimuth Center projection using azimuth angle.</p>
<p>This projection corresponds to EPSG projection method 9815, also sometimes known as hotine oblique mercator (variant B).</p>
<p>This method does the same thing as the C function <a class="el" href="ogr__srs__api_8h.html#a98e792f89b1899d13cff2fa982af7dd4" title="Set an Oblique Mercator projection using azimuth angle. ">OSRSetHOMAC()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfCenterLat</td><td>Latitude of the projection origin. </td></tr>
    <tr><td class="paramname">dfCenterLong</td><td>Longitude of the projection origin. </td></tr>
    <tr><td class="paramname">dfAzimuth</td><td>Azimuth, measured clockwise from North, of the projection centerline. </td></tr>
    <tr><td class="paramname">dfRectToSkew</td><td>?. </td></tr>
    <tr><td class="paramname">dfScale</td><td>Scale factor applies to the projection origin. </td></tr>
    <tr><td class="paramname">dfFalseEasting</td><td>False easting. </td></tr>
    <tr><td class="paramname">dfFalseNorthing</td><td>False northing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a2016fee7b234666c5e94d528661e6729"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::SetLinearUnits </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszUnitsName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfInMeters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the linear units for the projection. </p>
<p>This method creates a UNIT subnode with the specified values as a child of the PROJCS, GEOCCS or LOCAL_CS node.</p>
<p>This method does the same as the C function <a class="el" href="ogr__srs__api_8h.html#acc2efa6fe8385be92cd900a795332809" title="Set the linear units for the projection. ">OSRSetLinearUnits()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszUnitsName</td><td>the units name to be used. Some preferred units names can be found in <a class="el" href="ogr__srs__api_8h.html" title="C spatial reference system services and defines. ">ogr_srs_api.h</a> such as SRS_UL_METER, SRS_UL_FOOT and SRS_UL_US_FOOT.</td></tr>
    <tr><td class="paramname">dfInMeters</td><td>the value to multiple by a length in the indicated units to transform to meters. Some standard conversion factors can be found in <a class="el" href="ogr__srs__api_8h.html" title="C spatial reference system services and defines. ">ogr_srs_api.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>

</div>
</div>
<a class="anchor" id="adaab3d6e836f93974022bd78e221c4b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::SetLinearUnitsAndUpdateParameters </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfInMeters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the linear units for the projection. </p>
<p>This method creates a UNIT subnode with the specified values as a child of the PROJCS or LOCAL_CS node. It works the same as the <a class="el" href="classOGRSpatialReference.html#a2016fee7b234666c5e94d528661e6729" title="Set the linear units for the projection. ">SetLinearUnits()</a> method, but it also updates all existing linear projection parameter values from the old units to the new units.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszName</td><td>the units name to be used. Some preferred units names can be found in <a class="el" href="ogr__srs__api_8h.html" title="C spatial reference system services and defines. ">ogr_srs_api.h</a> such as SRS_UL_METER, SRS_UL_FOOT and SRS_UL_US_FOOT.</td></tr>
    <tr><td class="paramname">dfInMeters</td><td>the value to multiple by a length in the indicated units to transform to meters. Some standard conversion factors can be found in <a class="el" href="ogr__srs__api_8h.html" title="C spatial reference system services and defines. ">ogr_srs_api.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a3aad2472b5c38757a3bc606ee048c1c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::SetLocalCS </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the user visible LOCAL_CS name. </p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#aacace09cd2d7c190d9768d5d0f0e79f5" title="Set the user visible LOCAL_CS name. ">OSRSetLocalCS()</a>.</p>
<p>This method will ensure a LOCAL_CS node is created as the root, and set the provided name on it. It must be used before <a class="el" href="classOGRSpatialReference.html#a2016fee7b234666c5e94d528661e6729" title="Set the linear units for the projection. ">SetLinearUnits()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszName</td><td>the user visible name to assign. Not used as a key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a5de745a68a65e0471df833b2f930538c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::SetNode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszNodePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszNewNodeValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set attribute value in spatial reference. </p>
<p>Missing intermediate nodes in the path will be created if not already in existence. If the attribute has no children one will be created and assigned the value otherwise the zeroth child will be assigned the value.</p>
<p>This method does the same as the C function <a class="el" href="ogr__srs__api_8h.html#a46f906871cc7e03eb5c066433c0b31e9" title="Set attribute value in spatial reference. ">OSRSetAttrValue()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszNodePath</td><td>full path to attribute to be set. For instance "PROJCS|GEOGCS|UNIT".</td></tr>
    <tr><td class="paramname">pszNewNodeValue</td><td>value to be assigned to node, such as "meter". This may be NULL if you just want to force creation of the intermediate path.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a38f09586aa8fc5d02ec1aa1bc39e3d3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::SetNode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszNodePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set attribute value in spatial reference. </p>
<p>Missing intermediate nodes in the path will be created if not already in existence. If the attribute has no children one will be created and assigned the value otherwise the zeroth child will be assigned the value.</p>
<p>This method does the same as the C function <a class="el" href="ogr__srs__api_8h.html#a46f906871cc7e03eb5c066433c0b31e9" title="Set attribute value in spatial reference. ">OSRSetAttrValue()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszNodePath</td><td>full path to attribute to be set. For instance "PROJCS|GEOGCS|UNIT".</td></tr>
    <tr><td class="paramname">dfValue</td><td>value to be assigned to node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a050293b297acba00bd3da7d71d7ea0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::SetNormProjParm </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a projection parameter with a normalized value. </p>
<p>This method is the same as <a class="el" href="classOGRSpatialReference.html#aaa2027f62b01d61d9aab83629dd86cda" title="Set a projection parameter value. ">SetProjParm()</a> except that the value of the parameter passed in is assumed to be in "normalized" form (decimal degrees for angular values, meters for linear values. The values are converted in a form suitable for the GEOGCS and linear units in effect.</p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#a905d6bd807bd2d2b9649478538f9819e" title="Set a projection parameter with a normalized value. ">OSRSetNormProjParm()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszName</td><td>the parameter name, which should be selected from the macros in <a class="el" href="ogr__srs__api_8h.html" title="C spatial reference system services and defines. ">ogr_srs_api.h</a>, such as SRS_PP_CENTRAL_MERIDIAN.</td></tr>
    <tr><td class="paramname">dfValue</td><td>value to assign.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a208118581246feb29646acf2ea5d4237"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::SetProjCS </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the user visible PROJCS name. </p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#a7b2a27d374690edb672a15fba6299102" title="Set the user visible PROJCS name. ">OSRSetProjCS()</a>.</p>
<p>This method will ensure a PROJCS node is created as the root, and set the provided name on it. If used on a GEOGCS coordinate system, the GEOGCS node will be demoted to be a child of the new PROJCS root.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszName</td><td>the user visible name to assign. Not used as a key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a45fc71e8c327e9aa274cb699b16f51ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::SetProjection </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszProjection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a projection name. </p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#a6769d3abaaf540e3838340d3112c2abf" title="Set a projection name. ">OSRSetProjection()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszProjection</td><td>the projection name, which should be selected from the macros in <a class="el" href="ogr__srs__api_8h.html" title="C spatial reference system services and defines. ">ogr_srs_api.h</a>, such as SRS_PT_TRANSVERSE_MERCATOR.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>

</div>
</div>
<a class="anchor" id="aaa2027f62b01d61d9aab83629dd86cda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::SetProjParm </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszParmName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a projection parameter value. </p>
<p>Adds a new PARAMETER under the PROJCS with the indicated name and value.</p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#a4d5e808bb57731e36da56626f48d1626" title="Set a projection parameter value. ">OSRSetProjParm()</a>.</p>
<p>Please check <a href="http://www.remotesensing.org/geotiff/proj_list">http://www.remotesensing.org/geotiff/proj_list</a> pages for legal parameter names for specific projections.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszParmName</td><td>the parameter name, which should be selected from the macros in <a class="el" href="ogr__srs__api_8h.html" title="C spatial reference system services and defines. ">ogr_srs_api.h</a>, such as SRS_PP_CENTRAL_MERIDIAN.</td></tr>
    <tr><td class="paramname">dfValue</td><td>value to assign.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a28eeee5688ff6cea07e74ccd4c18a3b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRSpatialReference::SetRoot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> *&#160;</td>
          <td class="paramname"><em>poNewRoot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the root SRS node. </p>
<p>If the object has an existing tree of OGR_SRSNodes, they are destroyed as part of assigning the new root. Ownership of the passed <a class="el" href="classOGR__SRSNode.html" title="Objects of this class are used to represent value nodes in the parsed representation of the WKT SRS f...">OGR_SRSNode</a> is is assumed by the <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poNewRoot</td><td>object to assign as root. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4e0f1e23207c157f72388717c35be88c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::SetStatePlane </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nZone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bNAD83</em> = <code>TRUE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszOverrideUnitName</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfOverrideUnit</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>State Plane. </p>
<p>Set State Plane projection definition.</p>
<p>This will attempt to generate a complete definition of a state plane zone based on generating the entire SRS from the EPSG tables. If the EPSG tables are unavailable, it will produce a stubbed LOCAL_CS definition and return OGRERR_FAILURE.</p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#af8bbb49338378b4789f7005f509f0159" title="Set State Plane projection definition. ">OSRSetStatePlaneWithUnits()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nZone</td><td>State plane zone number, in the USGS numbering scheme (as distinct from the Arc/Info and Erdas numbering scheme.</td></tr>
    <tr><td class="paramname">bNAD83</td><td>TRUE if the NAD83 zone definition should be used or FALSE if the NAD27 zone definition should be used.</td></tr>
    <tr><td class="paramname">pszOverrideUnitName</td><td>Linear unit name to apply overriding the legal definition for this zone.</td></tr>
    <tr><td class="paramname">dfOverrideUnit</td><td>Linear unit conversion factor to apply overriding the legal definition for this zone.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success, or OGRERR_FAILURE on failure, mostly likely due to the EPSG tables not being accessible. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a2c45c441de09c329ea0676d4e2e9d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::SetTargetLinearUnits </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszTargetKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszUnitsName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfInMeters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the linear units for the projection. </p>
<p>This method creates a UNIT subnode with the specified values as a child of the target node.</p>
<p>This method does the same as the C function <a class="el" href="ogr__srs__api_8h.html#a30110f6bb89523a1ea1e76622374b883" title="Set the linear units for the target node. ">OSRSetTargetLinearUnits()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszTargetKey</td><td>the keyword to set the linear units for. i.e. "PROJCS" or "VERT_CS"</td></tr>
    <tr><td class="paramname">pszUnitsName</td><td>the units name to be used. Some preferred units names can be found in <a class="el" href="ogr__srs__api_8h.html" title="C spatial reference system services and defines. ">ogr_srs_api.h</a> such as SRS_UL_METER, SRS_UL_FOOT and SRS_UL_US_FOOT.</td></tr>
    <tr><td class="paramname">dfInMeters</td><td>the value to multiple by a length in the indicated units to transform to meters. Some standard conversion factors can be found in <a class="el" href="ogr__srs__api_8h.html" title="C spatial reference system services and defines. ">ogr_srs_api.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ae3a6fa2ec0371725279c7f11dbe7b98f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::SetTMVariant </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszVariantName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfCenterLat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfCenterLong</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfFalseEasting</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfFalseNorthing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transverse Mercator variants. </p>

</div>
</div>
<a class="anchor" id="af8be55999021cd06a75fb86416097156"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::SetTOWGS84 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfDX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfDY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfDZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfEX</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfEY</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfEZ</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfPPM</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the Bursa-Wolf conversion to WGS84. </p>
<p>This will create the TOWGS84 node as a child of the DATUM. It will fail if there is no existing DATUM node. Unlike most <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a> methods it will insert itself in the appropriate order, and will replace an existing TOWGS84 node if there is one.</p>
<p>The parameters have the same meaning as EPSG transformation 9606 (Position Vector 7-param. transformation).</p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#aa80d301d664f0d2e0b40afaee2c03552" title="Set the Bursa-Wolf conversion to WGS84. ">OSRSetTOWGS84()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfDX</td><td>X child in meters. </td></tr>
    <tr><td class="paramname">dfDY</td><td>Y child in meters. </td></tr>
    <tr><td class="paramname">dfDZ</td><td>Z child in meters. </td></tr>
    <tr><td class="paramname">dfEX</td><td>X rotation in arc seconds (optional, defaults to zero). </td></tr>
    <tr><td class="paramname">dfEY</td><td>Y rotation in arc seconds (optional, defaults to zero). </td></tr>
    <tr><td class="paramname">dfEZ</td><td>Z rotation in arc seconds (optional, defaults to zero). </td></tr>
    <tr><td class="paramname">dfPPM</td><td>scaling factor (parts per million).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a0c4f6fcab663c9eb6d465787cad3833c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::SetUTM </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nZone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bNorth</em> = <code>TRUE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Universal Transverse Mercator. </p>
<p>Set UTM projection definition.</p>
<p>This will generate a projection definition with the full set of transverse mercator projection parameters for the given UTM zone. If no PROJCS[] description is set yet, one will be set to look like "UTM Zone %d, {Northern, Southern} Hemisphere".</p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#ad176f04d7b43e91e8aaf78d6f94082ab" title="Set UTM projection definition. ">OSRSetUTM()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nZone</td><td>UTM zone.</td></tr>
    <tr><td class="paramname">bNorth</td><td>TRUE for northern hemisphere, or FALSE for southern hemisphere.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a4764cca1641b045a63afa95d01922add"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::SetVertCS </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszVertCSName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszVertDatumName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nVertDatumType</em> = <code>2005</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the user visible VERT_CS name. </p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#a261596f6a4dceacfef55851814f8cc47" title="Setup the vertical coordinate system. ">OSRSetVertCS()</a>.</p>
<p>This method will ensure a VERT_CS node is created if needed. If the existing coordinate system is GEOGCS or PROJCS rooted, then it will be turned into a COMPD_CS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszVertCSName</td><td>the user visible name of the vertical coordinate system. Not used as a key.</td></tr>
    <tr><td class="paramname">pszVertDatumName</td><td>the user visible name of the vertical datum. It is helpful if this matches the EPSG name.</td></tr>
    <tr><td class="paramname">nVertDatumType</td><td>the OGC vertical datum type, usually 2005.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a096b8dde4fd2eb475acd376060940b02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::SetWellKnownGeogCS </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a GeogCS based on well known name. </p>
<p>This may be called on an empty <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a> to make a geographic coordinate system, or on something with an existing PROJCS node to set the underlying geographic coordinate system of a projected coordinate system.</p>
<p>The following well known text values are currently supported: </p><ul>
<li>
"WGS84": same as "EPSG:4326" but has no dependence on EPSG data files. </li>
<li>
"WGS72": same as "EPSG:4322" but has no dependence on EPSG data files. </li>
<li>
"NAD27": same as "EPSG:4267" but has no dependence on EPSG data files. </li>
<li>
"NAD83": same as "EPSG:4269" but has no dependence on EPSG data files. </li>
<li>
"EPSG:n": where n is the code a Geographic coordinate reference system. </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszName</td><td>name of well known geographic coordinate system. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success, or OGRERR_FAILURE if the name isn't recognised, the target object is already initialized, or an EPSG value can't be successfully looked up. </dd></dl>

</div>
</div>
<a class="anchor" id="a819badadb4b462e6ce2b4779427fee8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::StripCTParms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> *&#160;</td>
          <td class="paramname"><em>poCurrent</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Strip OGC CT Parameters. </p>
<p>This method will remove all components of the coordinate system that are specific to the OGC CT Specification. That is it will attempt to strip it down to being compatible with the Simple Features 1.0 specification.</p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#aa2d1f5a4fc3d492a0c30aa91545989ab" title="Strip OGC CT Parameters. ">OSRStripCTParms()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poCurrent</td><td>node to operate on. NULL to operate on whole tree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or an error code. </dd></dl>

</div>
</div>
<a class="anchor" id="aff482ab330681678d7baff602389e7fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::StripVertical </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a compound cs into a horizontal CS. </p>
<p>If this SRS is of type COMPD_CS[] then the vertical CS and the root COMPD_CS nodes are stripped resulting and only the horizontal coordinate system portion remains (normally PROJCS, GEOGCS or LOCAL_CS).</p>
<p>If this is not a compound coordinate system then nothing is changed.</p>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a39e6011bfa17da9e2f926a8f500ec31b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a> OGRSpatialReference::ToHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&#160;</td>
          <td class="paramname"><em>poSRS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a OGRSpatialReference* to a OGRSpatialReferenceH. </p>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a16c78a4cb401cccaa82a9e65f1b5d5c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRSpatialReference::Validate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate SRS tokens. </p>
<p>This method attempts to verify that the spatial reference system is well formed, and consists of known tokens. The validation is not comprehensive.</p>
<p>This method is the same as the C function <a class="el" href="ogr__srs__api_8h.html#a9ca0d0a02a7cd9933c0074cee292de38" title="Validate SRS tokens. ">OSRValidate()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if all is fine, OGRERR_CORRUPT_DATA if the SRS is not well formed, and OGRERR_UNSUPPORTED_SRS if the SRS is well formed, but contains non-standard PROJECTION[] values. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="ogr__spatialref_8h_source.html">ogr_spatialref.h</a></li>
<li>ogr_fromepsg.cpp</li>
<li>ogr_srs_dict.cpp</li>
<li>ogr_srs_erm.cpp</li>
<li>ogr_srs_esri.cpp</li>
<li>ogr_srs_ozi.cpp</li>
<li>ogr_srs_panorama.cpp</li>
<li>ogr_srs_pci.cpp</li>
<li>ogr_srs_proj4.cpp</li>
<li>ogr_srs_usgs.cpp</li>
<li>ogr_srs_validate.cpp</li>
<li>ogr_srs_xml.cpp</li>
<li>ogrspatialreference.cpp</li>
</ul>
</div><!-- contents -->
<hr>
Generated for GDAL by
<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.8.8.
</body>
</html>
