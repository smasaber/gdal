<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>GDAL: OGR_SRSNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GDAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="usergroup0.html"><span>Download</span></a></li>
      <li><a href="https://github.com/OSGeo/gdal/issues/"><span>Issue&#160;Tracker</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classOGR__SRSNode.html#pub-methods">Public Member Functions</a> &#124;
<a href="classOGR__SRSNode-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">OGR_SRSNode Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Objects of this class are used to represent value nodes in the parsed representation of the WKT SRS format.  
 <a href="classOGR__SRSNode.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ogr__spatialref_8h_source.html">ogr_spatialref.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a656ce6dca85be20c222bb8b5b42cfa32"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#a656ce6dca85be20c222bb8b5b42cfa32">OGR_SRSNode</a> (const char *=nullptr)</td></tr>
<tr class="memdesc:a656ce6dca85be20c222bb8b5b42cfa32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classOGR__SRSNode.html#a656ce6dca85be20c222bb8b5b42cfa32">More...</a><br /></td></tr>
<tr class="separator:a656ce6dca85be20c222bb8b5b42cfa32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7af4ed12bcd801b4e55185c3f37e210"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#ad7af4ed12bcd801b4e55185c3f37e210">IsLeafNode</a> () const </td></tr>
<tr class="memdesc:ad7af4ed12bcd801b4e55185c3f37e210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether this is a leaf node.  <a href="classOGR__SRSNode.html#ad7af4ed12bcd801b4e55185c3f37e210">More...</a><br /></td></tr>
<tr class="separator:ad7af4ed12bcd801b4e55185c3f37e210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5edbb6ed55d8a20c3d689a4ed80a8285"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#a5edbb6ed55d8a20c3d689a4ed80a8285">GetChildCount</a> () const </td></tr>
<tr class="memdesc:a5edbb6ed55d8a20c3d689a4ed80a8285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of children nodes.  <a href="classOGR__SRSNode.html#a5edbb6ed55d8a20c3d689a4ed80a8285">More...</a><br /></td></tr>
<tr class="separator:a5edbb6ed55d8a20c3d689a4ed80a8285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8c07e21a228cdd2e58a9944aa86d76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#aad8c07e21a228cdd2e58a9944aa86d76">GetChild</a> (int)</td></tr>
<tr class="memdesc:aad8c07e21a228cdd2e58a9944aa86d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch requested child.  <a href="classOGR__SRSNode.html#aad8c07e21a228cdd2e58a9944aa86d76">More...</a><br /></td></tr>
<tr class="separator:aad8c07e21a228cdd2e58a9944aa86d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac5d8092e1f5958242d26472bd62769"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#acac5d8092e1f5958242d26472bd62769">GetChild</a> (int) const </td></tr>
<tr class="memdesc:acac5d8092e1f5958242d26472bd62769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch requested child.  <a href="classOGR__SRSNode.html#acac5d8092e1f5958242d26472bd62769">More...</a><br /></td></tr>
<tr class="separator:acac5d8092e1f5958242d26472bd62769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6760a6ffee3941f9b55d184304a70b06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#a6760a6ffee3941f9b55d184304a70b06">GetNode</a> (const char *)</td></tr>
<tr class="memdesc:a6760a6ffee3941f9b55d184304a70b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find named node in tree.  <a href="classOGR__SRSNode.html#a6760a6ffee3941f9b55d184304a70b06">More...</a><br /></td></tr>
<tr class="separator:a6760a6ffee3941f9b55d184304a70b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34f0d1b063a431a7e08b00b83af8922"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#aa34f0d1b063a431a7e08b00b83af8922">GetNode</a> (const char *) const </td></tr>
<tr class="memdesc:aa34f0d1b063a431a7e08b00b83af8922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find named node in tree.  <a href="classOGR__SRSNode.html#aa34f0d1b063a431a7e08b00b83af8922">More...</a><br /></td></tr>
<tr class="separator:aa34f0d1b063a431a7e08b00b83af8922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c84c7cfcadf8ee273eb5f265b5dcd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#a56c84c7cfcadf8ee273eb5f265b5dcd9">InsertChild</a> (<a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> *, int)</td></tr>
<tr class="memdesc:a56c84c7cfcadf8ee273eb5f265b5dcd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the passed node as a child of target node, at the indicated position.  <a href="classOGR__SRSNode.html#a56c84c7cfcadf8ee273eb5f265b5dcd9">More...</a><br /></td></tr>
<tr class="separator:a56c84c7cfcadf8ee273eb5f265b5dcd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161233efeab69c02691bfdfb8acda20d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#a161233efeab69c02691bfdfb8acda20d">AddChild</a> (<a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> *)</td></tr>
<tr class="memdesc:a161233efeab69c02691bfdfb8acda20d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add passed node as a child of target node.  <a href="classOGR__SRSNode.html#a161233efeab69c02691bfdfb8acda20d">More...</a><br /></td></tr>
<tr class="separator:a161233efeab69c02691bfdfb8acda20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047ce17a7a2f76ab0a6c4c7f5cab06a9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#a047ce17a7a2f76ab0a6c4c7f5cab06a9">FindChild</a> (const char *) const </td></tr>
<tr class="memdesc:a047ce17a7a2f76ab0a6c4c7f5cab06a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the index of the child matching the given string.  <a href="classOGR__SRSNode.html#a047ce17a7a2f76ab0a6c4c7f5cab06a9">More...</a><br /></td></tr>
<tr class="separator:a047ce17a7a2f76ab0a6c4c7f5cab06a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad292fa90c3d86e79a7dcc0d1ed7bfa72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#ad292fa90c3d86e79a7dcc0d1ed7bfa72">DestroyChild</a> (int)</td></tr>
<tr class="memdesc:ad292fa90c3d86e79a7dcc0d1ed7bfa72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a child node, and it's subtree.  <a href="classOGR__SRSNode.html#ad292fa90c3d86e79a7dcc0d1ed7bfa72">More...</a><br /></td></tr>
<tr class="separator:ad292fa90c3d86e79a7dcc0d1ed7bfa72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af599fd462c258828a6c1c1987bc96ff2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af599fd462c258828a6c1c1987bc96ff2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#af599fd462c258828a6c1c1987bc96ff2">ClearChildren</a> ()</td></tr>
<tr class="memdesc:af599fd462c258828a6c1c1987bc96ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear children nodes. <br /></td></tr>
<tr class="separator:af599fd462c258828a6c1c1987bc96ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181ab5c7787769906e42ad54101e326a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#a181ab5c7787769906e42ad54101e326a">StripNodes</a> (const char *)</td></tr>
<tr class="memdesc:a181ab5c7787769906e42ad54101e326a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strip child nodes matching name.  <a href="classOGR__SRSNode.html#a181ab5c7787769906e42ad54101e326a">More...</a><br /></td></tr>
<tr class="separator:a181ab5c7787769906e42ad54101e326a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c27a55eba526197af3206ac7b7a94e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#a49c27a55eba526197af3206ac7b7a94e">GetValue</a> () const </td></tr>
<tr class="memdesc:a49c27a55eba526197af3206ac7b7a94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch value string for this node.  <a href="classOGR__SRSNode.html#a49c27a55eba526197af3206ac7b7a94e">More...</a><br /></td></tr>
<tr class="separator:a49c27a55eba526197af3206ac7b7a94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07094ad4ae48e6760d0816ff14d2a8ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#a07094ad4ae48e6760d0816ff14d2a8ad">SetValue</a> (const char *)</td></tr>
<tr class="memdesc:a07094ad4ae48e6760d0816ff14d2a8ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the node value.  <a href="classOGR__SRSNode.html#a07094ad4ae48e6760d0816ff14d2a8ad">More...</a><br /></td></tr>
<tr class="separator:a07094ad4ae48e6760d0816ff14d2a8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb8176e81a89fb8e8cd8522c0785492"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#a1cb8176e81a89fb8e8cd8522c0785492">MakeValueSafe</a> ()</td></tr>
<tr class="memdesc:a1cb8176e81a89fb8e8cd8522c0785492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Massage value string, stripping special characters so it will be a database safe string.  <a href="classOGR__SRSNode.html#a1cb8176e81a89fb8e8cd8522c0785492">More...</a><br /></td></tr>
<tr class="separator:a1cb8176e81a89fb8e8cd8522c0785492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b0a2db1a7a8d9b5395c75510ad3734"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#a25b0a2db1a7a8d9b5395c75510ad3734">FixupOrdering</a> ()</td></tr>
<tr class="memdesc:a25b0a2db1a7a8d9b5395c75510ad3734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Correct parameter ordering to match CT Specification.  <a href="classOGR__SRSNode.html#a25b0a2db1a7a8d9b5395c75510ad3734">More...</a><br /></td></tr>
<tr class="separator:a25b0a2db1a7a8d9b5395c75510ad3734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82e237ee7c6ac0ca77447be35471e7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#af82e237ee7c6ac0ca77447be35471e7f">Clone</a> () const </td></tr>
<tr class="memdesc:af82e237ee7c6ac0ca77447be35471e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a duplicate of this node, and it's children.  <a href="classOGR__SRSNode.html#af82e237ee7c6ac0ca77447be35471e7f">More...</a><br /></td></tr>
<tr class="separator:af82e237ee7c6ac0ca77447be35471e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8db59ea569b214a0ae163f505dc2e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#a6b8db59ea569b214a0ae163f505dc2e0">importFromWkt</a> (char **)</td></tr>
<tr class="memdesc:a6b8db59ea569b214a0ae163f505dc2e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import from WKT string.  <a href="classOGR__SRSNode.html#a6b8db59ea569b214a0ae163f505dc2e0">More...</a><br /></td></tr>
<tr class="separator:a6b8db59ea569b214a0ae163f505dc2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bfb2b84c7887ba524a84bf54bea94c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#a6bfb2b84c7887ba524a84bf54bea94c5">importFromWkt</a> (const char **)</td></tr>
<tr class="memdesc:a6bfb2b84c7887ba524a84bf54bea94c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import from WKT string.  <a href="classOGR__SRSNode.html#a6bfb2b84c7887ba524a84bf54bea94c5">More...</a><br /></td></tr>
<tr class="separator:a6bfb2b84c7887ba524a84bf54bea94c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b147bc2cad0aaafb201c559abe9cc85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#a5b147bc2cad0aaafb201c559abe9cc85">exportToWkt</a> (char **) const </td></tr>
<tr class="memdesc:a5b147bc2cad0aaafb201c559abe9cc85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert this tree of nodes into WKT format.  <a href="classOGR__SRSNode.html#a5b147bc2cad0aaafb201c559abe9cc85">More...</a><br /></td></tr>
<tr class="separator:a5b147bc2cad0aaafb201c559abe9cc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f2cffb52ab9013bbb22496806ce0c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#a41f2cffb52ab9013bbb22496806ce0c8">exportToPrettyWkt</a> (char **, int=1) const </td></tr>
<tr class="memdesc:a41f2cffb52ab9013bbb22496806ce0c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert this tree of nodes into pretty WKT format.  <a href="classOGR__SRSNode.html#a41f2cffb52ab9013bbb22496806ce0c8">More...</a><br /></td></tr>
<tr class="separator:a41f2cffb52ab9013bbb22496806ce0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd16eaf19c7fef5b4a08a0d57705d349"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGR__SRSNode.html#acd16eaf19c7fef5b4a08a0d57705d349">applyRemapper</a> (const char *pszNode, const char *const *papszSrcValues, const char *const *papszDstValues, int nStepSize=1, int bChildOfHit=FALSE)</td></tr>
<tr class="memdesc:acd16eaf19c7fef5b4a08a0d57705d349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remap node values matching list.  <a href="classOGR__SRSNode.html#acd16eaf19c7fef5b4a08a0d57705d349">More...</a><br /></td></tr>
<tr class="separator:acd16eaf19c7fef5b4a08a0d57705d349"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Objects of this class are used to represent value nodes in the parsed representation of the WKT SRS format. </p>
<p>For instance UNIT["METER",1] would be rendered into three OGR_SRSNodes. The root node would have a value of UNIT, and two children, the first with a value of METER, and the second with a value of 1.</p>
<p>Normally application code just interacts with the <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a> object, which uses the <a class="el" href="classOGR__SRSNode.html" title="Objects of this class are used to represent value nodes in the parsed representation of the WKT SRS f...">OGR_SRSNode</a> to implement its data structure; however, this class is user accessible for detailed access to components of an SRS definition. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a656ce6dca85be20c222bb8b5b42cfa32"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OGR_SRSNode::OGR_SRSNode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszValueIn</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszValueIn</td><td>this optional parameter can be used to initialize the value of the node upon creation. If omitted the node will be created with a value of "". Newly created OGR_SRSNodes have no children. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a161233efeab69c02691bfdfb8acda20d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_SRSNode::AddChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> *&#160;</td>
          <td class="paramname"><em>poNew</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add passed node as a child of target node. </p>
<p>Note that ownership of the passed node is assumed by the node on which the method is invoked ... use the <a class="el" href="classOGR__SRSNode.html#af82e237ee7c6ac0ca77447be35471e7f" title="Make a duplicate of this node, and it&#39;s children. ">Clone()</a> method if the original is to be preserved. New children are always added at the end of the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poNew</td><td>the node to add as a child. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acd16eaf19c7fef5b4a08a0d57705d349"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_SRSNode::applyRemapper </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>papszSrcValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>papszDstValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nStepSize</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bChildOfHit</em> = <code>FALSE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remap node values matching list. </p>
<p>Remap the value of this node or any of it's children if it matches one of the values in the source list to the corresponding value from the destination list. If the pszNode value is set, only do so if the parent node matches that value. Even if a replacement occurs, searching continues.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszNode</td><td>Restrict remapping to children of this type of node (e.g. "PROJECTION") </td></tr>
    <tr><td class="paramname">papszSrcValues</td><td>a NULL terminated array of source string. If the node value matches one of these (case insensitive) then replacement occurs. </td></tr>
    <tr><td class="paramname">papszDstValues</td><td>an array of destination strings. On a match, the one corresponding to a source value will be used to replace a node. </td></tr>
    <tr><td class="paramname">nStepSize</td><td>increment when stepping through source and destination arrays, allowing source and destination arrays to be one interleaved array for instances. Defaults to 1. </td></tr>
    <tr><td class="paramname">bChildOfHit</td><td>Only TRUE if we the current node is the child of a match, and so needs to be set. Application code would normally pass FALSE for this argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns OGRERR_NONE unless something bad happens. There is no indication returned about whether any replacement occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="af82e237ee7c6ac0ca77447be35471e7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> * OGR_SRSNode::Clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a duplicate of this node, and it's children. </p>
<dl class="section return"><dt>Returns</dt><dd>a new node tree, which becomes the responsibility of the caller. </dd></dl>

</div>
</div>
<a class="anchor" id="ad292fa90c3d86e79a7dcc0d1ed7bfa72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_SRSNode::DestroyChild </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChild</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a child node, and it's subtree. </p>
<p>Note that removing a child node will result in children after it being renumbered down one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iChild</td><td>the index of the child. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a41f2cffb52ab9013bbb22496806ce0c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_SRSNode::exportToPrettyWkt </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppszResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nDepth</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert this tree of nodes into pretty WKT format. </p>
<p>Note that the returned WKT string should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree() ">CPLFree()</a> when no longer needed. It is the responsibility of the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppszResult</td><td>the resulting string is returned in this pointer.</td></tr>
    <tr><td class="paramname">nDepth</td><td>depth of the node</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>currently OGRERR_NONE is always returned, but the future it is possible error conditions will develop. </dd></dl>

</div>
</div>
<a class="anchor" id="a5b147bc2cad0aaafb201c559abe9cc85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_SRSNode::exportToWkt </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppszResult</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert this tree of nodes into WKT format. </p>
<p>Note that the returned WKT string should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree() ">CPLFree()</a> when no longer needed. It is the responsibility of the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppszResult</td><td>the resulting string is returned in this pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>currently OGRERR_NONE is always returned, but the future it is possible error conditions will develop. </dd></dl>

</div>
</div>
<a class="anchor" id="a047ce17a7a2f76ab0a6c4c7f5cab06a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_SRSNode::FindChild </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszValueIn</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the index of the child matching the given string. </p>
<p>Note that the node value must match pszValue with the exception of case. The comparison is case insensitive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszValueIn</td><td>the node value being searched for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the child index, or -1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a25b0a2db1a7a8d9b5395c75510ad3734"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_SRSNode::FixupOrdering </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Correct parameter ordering to match CT Specification. </p>
<p>Some mechanisms to create WKT using <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a>, and some imported WKT fail to maintain the order of parameters required according to the BNF definitions in the OpenGIS SF-SQL and CT Specifications. This method attempts to massage things back into the required order.</p>
<p>This method will reorder the children of the node it is invoked on and then recurse to all children to fix up their children.</p>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or an error code if something goes wrong. </dd></dl>

</div>
</div>
<a class="anchor" id="aad8c07e21a228cdd2e58a9944aa86d76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> * OGR_SRSNode::GetChild </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChild</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch requested child. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iChild</td><td>the index of the child to fetch, from 0 to <a class="el" href="classOGR__SRSNode.html#a5edbb6ed55d8a20c3d689a4ed80a8285" title="Get number of children nodes. ">GetChildCount()</a> - 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the child <a class="el" href="classOGR__SRSNode.html" title="Objects of this class are used to represent value nodes in the parsed representation of the WKT SRS f...">OGR_SRSNode</a>, or NULL if there is no such child. </dd></dl>

</div>
</div>
<a class="anchor" id="acac5d8092e1f5958242d26472bd62769"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> * OGR_SRSNode::GetChild </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChild</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch requested child. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iChild</td><td>the index of the child to fetch, from 0 to <a class="el" href="classOGR__SRSNode.html#a5edbb6ed55d8a20c3d689a4ed80a8285" title="Get number of children nodes. ">GetChildCount()</a> - 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the child <a class="el" href="classOGR__SRSNode.html" title="Objects of this class are used to represent value nodes in the parsed representation of the WKT SRS f...">OGR_SRSNode</a>, or NULL if there is no such child. </dd></dl>

</div>
</div>
<a class="anchor" id="a5edbb6ed55d8a20c3d689a4ed80a8285"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_SRSNode::GetChildCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of children nodes. </p>
<dl class="section return"><dt>Returns</dt><dd>0 for leaf nodes, or the number of children nodes. </dd></dl>

</div>
</div>
<a class="anchor" id="a6760a6ffee3941f9b55d184304a70b06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> * OGR_SRSNode::GetNode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find named node in tree. </p>
<p>This method does a pre-order traversal of the node tree searching for a node with this exact value (case insensitive), and returns it. Leaf nodes are not considered, under the assumption that they are just attribute value nodes.</p>
<p>If a node appears more than once in the tree (such as UNIT for instance), the first encountered will be returned. Use <a class="el" href="classOGR__SRSNode.html#a6760a6ffee3941f9b55d184304a70b06" title="Find named node in tree. ">GetNode()</a> on a subtree to be more specific.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszName</td><td>the name of the node to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the node found, or NULL if none. </dd></dl>

</div>
</div>
<a class="anchor" id="aa34f0d1b063a431a7e08b00b83af8922"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> * OGR_SRSNode::GetNode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find named node in tree. </p>
<p>This method does a pre-order traversal of the node tree searching for a node with this exact value (case insensitive), and returns it. Leaf nodes are not considered, under the assumption that they are just attribute value nodes.</p>
<p>If a node appears more than once in the tree (such as UNIT for instance), the first encountered will be returned. Use <a class="el" href="classOGR__SRSNode.html#a6760a6ffee3941f9b55d184304a70b06" title="Find named node in tree. ">GetNode()</a> on a subtree to be more specific.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszName</td><td>the name of the node to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the node found, or NULL if none. </dd></dl>

</div>
</div>
<a class="anchor" id="a49c27a55eba526197af3206ac7b7a94e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * OGR_SRSNode::GetValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch value string for this node. </p>
<dl class="section return"><dt>Returns</dt><dd>A non-NULL string is always returned. The returned pointer is to the internal value of this node, and should not be modified, or freed. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b8db59ea569b214a0ae163f505dc2e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_SRSNode::importFromWkt </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppszInput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import from WKT string. </p>
<p>This method will wipe the existing children and value of this node, and reassign them based on the contents of the passed WKT string. Only as much of the input string as needed to construct this node, and its children is consumed from the input string, and the input string pointer is then updated to point to the remaining (unused) input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppszInput</td><td>Pointer to pointer to input. The pointer is updated to point to remaining unused input text.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if import succeeds, or OGRERR_CORRUPT_DATA if it fails for any reason. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000009">Deprecated:</a></b></dt><dd>GDAL 2.3. Use <a class="el" href="classOGR__SRSNode.html#a6bfb2b84c7887ba524a84bf54bea94c5" title="Import from WKT string. ">importFromWkt(const char**)</a> instead. </dd></dl>

</div>
</div>
<a class="anchor" id="a6bfb2b84c7887ba524a84bf54bea94c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_SRSNode::importFromWkt </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>ppszInput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import from WKT string. </p>
<p>This method will wipe the existing children and value of this node, and reassign them based on the contents of the passed WKT string. Only as much of the input string as needed to construct this node, and its children is consumed from the input string, and the input string pointer is then updated to point to the remaining (unused) input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppszInput</td><td>Pointer to pointer to input. The pointer is updated to point to remaining unused input text.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if import succeeds, or OGRERR_CORRUPT_DATA if it fails for any reason.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a56c84c7cfcadf8ee273eb5f265b5dcd9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_SRSNode::InsertChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGR__SRSNode.html">OGR_SRSNode</a> *&#160;</td>
          <td class="paramname"><em>poNew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChild</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert the passed node as a child of target node, at the indicated position. </p>
<p>Note that ownership of the passed node is assumed by the node on which the method is invoked ... use the <a class="el" href="classOGR__SRSNode.html#af82e237ee7c6ac0ca77447be35471e7f" title="Make a duplicate of this node, and it&#39;s children. ">Clone()</a> method if the original is to be preserved. All existing children at location iChild and beyond are push down one space to make space for the new child.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poNew</td><td>the node to add as a child. </td></tr>
    <tr><td class="paramname">iChild</td><td>position to insert, use 0 to insert at the beginning. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad7af4ed12bcd801b4e55185c3f37e210"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_SRSNode::IsLeafNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether this is a leaf node. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE or FALSE </dd></dl>

</div>
</div>
<a class="anchor" id="a1cb8176e81a89fb8e8cd8522c0785492"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_SRSNode::MakeValueSafe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Massage value string, stripping special characters so it will be a database safe string. </p>
<p>The operation is also applies to all subnodes of the current node. </p>

</div>
</div>
<a class="anchor" id="a07094ad4ae48e6760d0816ff14d2a8ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_SRSNode::SetValue </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszNewValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the node value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszNewValue</td><td>the new value to assign to this node. The passed string is duplicated and remains the responsibility of the caller. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a181ab5c7787769906e42ad54101e326a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_SRSNode::StripNodes </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Strip child nodes matching name. </p>
<p>Removes any descendant nodes of this node that match the given name. Of course children of removed nodes are also discarded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszName</td><td>the name for nodes that should be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="ogr__spatialref_8h_source.html">ogr_spatialref.h</a></li>
<li>ogr_srsnode.cpp</li>
</ul>
</div><!-- contents -->
<hr>
Generated for GDAL by
<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.8.8.
</body>
</html>
