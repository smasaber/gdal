<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>GDAL: OGRGeometry Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GDAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="usergroup0.html"><span>Download</span></a></li>
      <li><a href="https://github.com/OSGeo/gdal/issues/"><span>Issue&#160;Tracker</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classOGRGeometry.html#pub-methods">Public Member Functions</a> &#124;
<a href="classOGRGeometry.html#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classOGRGeometry-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">OGRGeometry Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Abstract base class for all geometry classes.  
 <a href="classOGRGeometry.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ogr__geometry_8h_source.html">ogr_geometry.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for OGRGeometry:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classOGRGeometry.png" usemap="#OGRGeometry_map" alt=""/>
  <map id="OGRGeometry_map" name="OGRGeometry_map">
<area href="classOGRCurve.html" title="Abstract curve base class for OGRLineString, OGRCircularString and OGRCompoundCurve. " alt="OGRCurve" shape="rect" coords="82,56,236,80"/>
<area href="classOGRGeometryCollection.html" title="A collection of 1 or more geometry objects. " alt="OGRGeometryCollection" shape="rect" coords="574,56,728,80"/>
<area href="classOGRPoint.html" title="Point class. " alt="OGRPoint" shape="rect" coords="738,56,892,80"/>
<area href="classOGRSurface.html" title="Abstract base class for 2 dimensional objects like polygons or curve polygons. " alt="OGRSurface" shape="rect" coords="984,56,1138,80"/>
<area href="classOGRCompoundCurve.html" title="Utility class to store a collection of curves. " alt="OGRCompoundCurve" shape="rect" coords="0,112,154,136"/>
<area href="classOGRSimpleCurve.html" title="Abstract curve base class for OGRLineString and OGRCircularString. " alt="OGRSimpleCurve" shape="rect" coords="164,112,318,136"/>
<area href="classOGRMultiCurve.html" title="A collection of OGRCurve. " alt="OGRMultiCurve" shape="rect" coords="410,112,564,136"/>
<area href="classOGRMultiPoint.html" title="A collection of OGRPoint. " alt="OGRMultiPoint" shape="rect" coords="574,112,728,136"/>
<area href="classOGRMultiSurface.html" title="A collection of non-overlapping OGRSurface. " alt="OGRMultiSurface" shape="rect" coords="738,112,892,136"/>
<area href="classOGRCurvePolygon.html" title="Concrete class representing curve polygons. " alt="OGRCurvePolygon" shape="rect" coords="902,112,1056,136"/>
<area href="classOGRPolyhedralSurface.html" title="PolyhedralSurface class. " alt="OGRPolyhedralSurface" shape="rect" coords="1066,112,1220,136"/>
<area href="classOGRCircularString.html" title="Concrete representation of a circular string, that is to say a curve made of one or several arc circl..." alt="OGRCircularString" shape="rect" coords="82,168,236,192"/>
<area href="classOGRLineString.html" title="Concrete representation of a multi-vertex line. " alt="OGRLineString" shape="rect" coords="246,168,400,192"/>
<area href="classOGRMultiLineString.html" title="A collection of OGRLineString. " alt="OGRMultiLineString" shape="rect" coords="410,168,564,192"/>
<area href="classOGRMultiPolygon.html" title="A collection of non-overlapping OGRPolygon. " alt="OGRMultiPolygon" shape="rect" coords="738,168,892,192"/>
<area href="classOGRPolygon.html" title="Concrete class representing polygons. " alt="OGRPolygon" shape="rect" coords="902,168,1056,192"/>
<area href="classOGRTriangulatedSurface.html" title="TriangulatedSurface class. " alt="OGRTriangulatedSurface" shape="rect" coords="1066,168,1220,192"/>
<area href="classOGRLinearRing.html" title="Concrete representation of a closed ring. " alt="OGRLinearRing" shape="rect" coords="246,224,400,248"/>
<area href="classOGRTriangle.html" title="Triangle class. " alt="OGRTriangle" shape="rect" coords="902,224,1056,248"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac0b82162f8efdec26efee2e22aba8cda"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ac0b82162f8efdec26efee2e22aba8cda">OGRGeometry</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> &amp;other)</td></tr>
<tr class="memdesc:ac0b82162f8efdec26efee2e22aba8cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classOGRGeometry.html#ac0b82162f8efdec26efee2e22aba8cda">More...</a><br /></td></tr>
<tr class="separator:ac0b82162f8efdec26efee2e22aba8cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b21bad341ab030e749aa88f2bef5c99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a9b21bad341ab030e749aa88f2bef5c99">operator=</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> &amp;other)</td></tr>
<tr class="memdesc:a9b21bad341ab030e749aa88f2bef5c99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="classOGRGeometry.html#a9b21bad341ab030e749aa88f2bef5c99">More...</a><br /></td></tr>
<tr class="separator:a9b21bad341ab030e749aa88f2bef5c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4812c3a99ddd446c306140bfebb02d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ae4812c3a99ddd446c306140bfebb02d1">operator==</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> &amp;other) const </td></tr>
<tr class="memdesc:ae4812c3a99ddd446c306140bfebb02d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if two geometries are equal.  <a href="classOGRGeometry.html#ae4812c3a99ddd446c306140bfebb02d1">More...</a><br /></td></tr>
<tr class="separator:ae4812c3a99ddd446c306140bfebb02d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68dd71d373d3d8fd783e2d064351925"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ab68dd71d373d3d8fd783e2d064351925">operator!=</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> &amp;other) const </td></tr>
<tr class="memdesc:ab68dd71d373d3d8fd783e2d064351925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if two geometries are different.  <a href="classOGRGeometry.html#ab68dd71d373d3d8fd783e2d064351925">More...</a><br /></td></tr>
<tr class="separator:ab68dd71d373d3d8fd783e2d064351925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadca09471fa9917452e087ba12d73eeb"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aadca09471fa9917452e087ba12d73eeb">getDimension</a> () const =0</td></tr>
<tr class="memdesc:aadca09471fa9917452e087ba12d73eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dimension of this object.  <a href="classOGRGeometry.html#aadca09471fa9917452e087ba12d73eeb">More...</a><br /></td></tr>
<tr class="separator:aadca09471fa9917452e087ba12d73eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a93f43a3b66462195b46f7fd2196dfc"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a2a93f43a3b66462195b46f7fd2196dfc">getCoordinateDimension</a> () const </td></tr>
<tr class="memdesc:a2a93f43a3b66462195b46f7fd2196dfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dimension of the coordinates in this object.  <a href="classOGRGeometry.html#a2a93f43a3b66462195b46f7fd2196dfc">More...</a><br /></td></tr>
<tr class="separator:a2a93f43a3b66462195b46f7fd2196dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1cead13e95b28a78261fee3b1cebb3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a9b1cead13e95b28a78261fee3b1cebb3">CoordinateDimension</a> () const </td></tr>
<tr class="memdesc:a9b1cead13e95b28a78261fee3b1cebb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dimension of the coordinates in this object.  <a href="classOGRGeometry.html#a9b1cead13e95b28a78261fee3b1cebb3">More...</a><br /></td></tr>
<tr class="separator:a9b1cead13e95b28a78261fee3b1cebb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8653ba97e53f3e3b041946ca2acc111"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ac8653ba97e53f3e3b041946ca2acc111">IsEmpty</a> () const =0</td></tr>
<tr class="memdesc:ac8653ba97e53f3e3b041946ca2acc111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns TRUE (non-zero) if the object has no points.  <a href="classOGRGeometry.html#ac8653ba97e53f3e3b041946ca2acc111">More...</a><br /></td></tr>
<tr class="separator:ac8653ba97e53f3e3b041946ca2acc111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bbb194937466a6127b5436ac2ae99d9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a7bbb194937466a6127b5436ac2ae99d9">IsValid</a> () const </td></tr>
<tr class="memdesc:a7bbb194937466a6127b5436ac2ae99d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the geometry is valid.  <a href="classOGRGeometry.html#a7bbb194937466a6127b5436ac2ae99d9">More...</a><br /></td></tr>
<tr class="separator:a7bbb194937466a6127b5436ac2ae99d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72b0c5c673d8b1cf6f870fabbeffe26"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ab72b0c5c673d8b1cf6f870fabbeffe26">IsSimple</a> () const </td></tr>
<tr class="memdesc:ab72b0c5c673d8b1cf6f870fabbeffe26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the geometry is simple.  <a href="classOGRGeometry.html#ab72b0c5c673d8b1cf6f870fabbeffe26">More...</a><br /></td></tr>
<tr class="separator:ab72b0c5c673d8b1cf6f870fabbeffe26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395b0a9b471f8ecabe5aa35af2ff5e03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a395b0a9b471f8ecabe5aa35af2ff5e03">Is3D</a> () const </td></tr>
<tr class="separator:a395b0a9b471f8ecabe5aa35af2ff5e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e20b5932408fa59004e4a7e1105475"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a59e20b5932408fa59004e4a7e1105475">IsMeasured</a> () const </td></tr>
<tr class="separator:a59e20b5932408fa59004e4a7e1105475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15ffdcae4351112b3106d4f87b2a3bf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ad15ffdcae4351112b3106d4f87b2a3bf">IsRing</a> () const </td></tr>
<tr class="memdesc:ad15ffdcae4351112b3106d4f87b2a3bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the geometry is a ring.  <a href="classOGRGeometry.html#ad15ffdcae4351112b3106d4f87b2a3bf">More...</a><br /></td></tr>
<tr class="separator:ad15ffdcae4351112b3106d4f87b2a3bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1702b5b8142abe761061a6cd44e50b05"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a1702b5b8142abe761061a6cd44e50b05">empty</a> ()=0</td></tr>
<tr class="memdesc:a1702b5b8142abe761061a6cd44e50b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear geometry information.  <a href="classOGRGeometry.html#a1702b5b8142abe761061a6cd44e50b05">More...</a><br /></td></tr>
<tr class="separator:a1702b5b8142abe761061a6cd44e50b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678d3e4fc419b7b714ecb80cbf603eb5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a678d3e4fc419b7b714ecb80cbf603eb5">clone</a> () const <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a>=0</td></tr>
<tr class="memdesc:a678d3e4fc419b7b714ecb80cbf603eb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a copy of this object.  <a href="classOGRGeometry.html#a678d3e4fc419b7b714ecb80cbf603eb5">More...</a><br /></td></tr>
<tr class="separator:a678d3e4fc419b7b714ecb80cbf603eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d42b06ae6f7bbef6d1a2886da8d398"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aa3d42b06ae6f7bbef6d1a2886da8d398">getEnvelope</a> (OGREnvelope *psEnvelope) const =0</td></tr>
<tr class="memdesc:aa3d42b06ae6f7bbef6d1a2886da8d398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure.  <a href="classOGRGeometry.html#aa3d42b06ae6f7bbef6d1a2886da8d398">More...</a><br /></td></tr>
<tr class="separator:aa3d42b06ae6f7bbef6d1a2886da8d398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3926892dbde299ffd652ee109b5967c5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a3926892dbde299ffd652ee109b5967c5">getEnvelope</a> (OGREnvelope3D *psEnvelope) const =0</td></tr>
<tr class="memdesc:a3926892dbde299ffd652ee109b5967c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the bounding envelope (3D) for this geometry in the passed psEnvelope structure.  <a href="classOGRGeometry.html#a3926892dbde299ffd652ee109b5967c5">More...</a><br /></td></tr>
<tr class="separator:a3926892dbde299ffd652ee109b5967c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1a8164dae2e44e50990756ed6b8b4a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#acd1a8164dae2e44e50990756ed6b8b4a">WkbSize</a> () const =0</td></tr>
<tr class="memdesc:acd1a8164dae2e44e50990756ed6b8b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns size of related binary representation.  <a href="classOGRGeometry.html#acd1a8164dae2e44e50990756ed6b8b4a">More...</a><br /></td></tr>
<tr class="separator:acd1a8164dae2e44e50990756ed6b8b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e604e7393db0dd511b458f3ecd0b819"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a0e604e7393db0dd511b458f3ecd0b819">importFromWkb</a> (const <a class="el" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a> *, int=-1, <a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6">OGRwkbVariant</a>=<a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6a7459e8d11fa69e89271771c8d0f265d8">wkbVariantOldOgc</a>)</td></tr>
<tr class="memdesc:a0e604e7393db0dd511b458f3ecd0b819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign geometry from well known binary data.  <a href="classOGRGeometry.html#a0e604e7393db0dd511b458f3ecd0b819">More...</a><br /></td></tr>
<tr class="separator:a0e604e7393db0dd511b458f3ecd0b819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487b3eec4526421c8c192741d933bfc1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a487b3eec4526421c8c192741d933bfc1">importFromWkb</a> (const unsigned char *, int, <a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6">OGRwkbVariant</a>, int &amp;nBytesConsumedOut)=0</td></tr>
<tr class="memdesc:a487b3eec4526421c8c192741d933bfc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign geometry from well known binary data.  <a href="classOGRGeometry.html#a487b3eec4526421c8c192741d933bfc1">More...</a><br /></td></tr>
<tr class="separator:a487b3eec4526421c8c192741d933bfc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3ad2f9b55285be500ca6ac5dc75d1d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a9a3ad2f9b55285be500ca6ac5dc75d1d">exportToWkb</a> (<a class="el" href="ogr__core_8h.html#a36cc1f4d807ba8f6fb8951f3adf251e2">OGRwkbByteOrder</a>, unsigned char *, <a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6">OGRwkbVariant</a>=<a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6a7459e8d11fa69e89271771c8d0f265d8">wkbVariantOldOgc</a>) const =0</td></tr>
<tr class="memdesc:a9a3ad2f9b55285be500ca6ac5dc75d1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry into well known binary format.  <a href="classOGRGeometry.html#a9a3ad2f9b55285be500ca6ac5dc75d1d">More...</a><br /></td></tr>
<tr class="separator:a9a3ad2f9b55285be500ca6ac5dc75d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1bb0f7cae630c31511766718bcc5b66"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#af1bb0f7cae630c31511766718bcc5b66">importFromWkt</a> (const char **ppszInput)=0</td></tr>
<tr class="memdesc:af1bb0f7cae630c31511766718bcc5b66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign geometry from well known text data.  <a href="classOGRGeometry.html#af1bb0f7cae630c31511766718bcc5b66">More...</a><br /></td></tr>
<tr class="separator:af1bb0f7cae630c31511766718bcc5b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf780889ff2bd04fda67e4a70d88b40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aabf780889ff2bd04fda67e4a70d88b40">importFromWkt</a> (char **ppszInput) CPL_WARN_DEPRECATED(&quot;Use importFromWkt( const char**) instead&quot;)</td></tr>
<tr class="memdesc:aabf780889ff2bd04fda67e4a70d88b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated.  <a href="classOGRGeometry.html#aabf780889ff2bd04fda67e4a70d88b40">More...</a><br /></td></tr>
<tr class="separator:aabf780889ff2bd04fda67e4a70d88b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6ea9cf7a5e940b6e00b2b4c6066e4c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#afb6ea9cf7a5e940b6e00b2b4c6066e4c">exportToWkt</a> (char **ppszDstText, <a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6">OGRwkbVariant</a>=<a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6a7459e8d11fa69e89271771c8d0f265d8">wkbVariantOldOgc</a>) const =0</td></tr>
<tr class="memdesc:afb6ea9cf7a5e940b6e00b2b4c6066e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry into well known text format.  <a href="classOGRGeometry.html#afb6ea9cf7a5e940b6e00b2b4c6066e4c">More...</a><br /></td></tr>
<tr class="separator:afb6ea9cf7a5e940b6e00b2b4c6066e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6bca18682cb933e3227552d480e1a5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a5c6bca18682cb933e3227552d480e1a5">getGeometryType</a> () const =0</td></tr>
<tr class="memdesc:a5c6bca18682cb933e3227552d480e1a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch geometry type.  <a href="classOGRGeometry.html#a5c6bca18682cb933e3227552d480e1a5">More...</a><br /></td></tr>
<tr class="separator:a5c6bca18682cb933e3227552d480e1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f471b43d61e19334618df4929833e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a87f471b43d61e19334618df4929833e9">getIsoGeometryType</a> () const </td></tr>
<tr class="memdesc:a87f471b43d61e19334618df4929833e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the geometry type that conforms with ISO SQL/MM Part3.  <a href="classOGRGeometry.html#a87f471b43d61e19334618df4929833e9">More...</a><br /></td></tr>
<tr class="separator:a87f471b43d61e19334618df4929833e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba109e1c53ce1452942f85eae66d88b8"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aba109e1c53ce1452942f85eae66d88b8">getGeometryName</a> () const =0</td></tr>
<tr class="memdesc:aba109e1c53ce1452942f85eae66d88b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch WKT name for geometry type.  <a href="classOGRGeometry.html#aba109e1c53ce1452942f85eae66d88b8">More...</a><br /></td></tr>
<tr class="separator:aba109e1c53ce1452942f85eae66d88b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8a8e76722551bed49ae5418fc776a0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a4e8a8e76722551bed49ae5418fc776a0">dumpReadable</a> (FILE *, const char *=nullptr, char **papszOptions=nullptr) const </td></tr>
<tr class="memdesc:a4e8a8e76722551bed49ae5418fc776a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump geometry in well known text format to indicated output file.  <a href="classOGRGeometry.html#a4e8a8e76722551bed49ae5418fc776a0">More...</a><br /></td></tr>
<tr class="separator:a4e8a8e76722551bed49ae5418fc776a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae1a2ced937a5900b2bfeb717bad6c9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aaae1a2ced937a5900b2bfeb717bad6c9">flattenTo2D</a> ()=0</td></tr>
<tr class="memdesc:aaae1a2ced937a5900b2bfeb717bad6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert geometry to strictly 2D.  <a href="classOGRGeometry.html#aaae1a2ced937a5900b2bfeb717bad6c9">More...</a><br /></td></tr>
<tr class="separator:aaae1a2ced937a5900b2bfeb717bad6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ced443fbccb280290c107e7b69fb8f"><td class="memItemLeft" align="right" valign="top">virtual char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a56ced443fbccb280290c107e7b69fb8f">exportToGML</a> (const char *const *papszOptions=nullptr) const </td></tr>
<tr class="memdesc:a56ced443fbccb280290c107e7b69fb8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry into GML format.  <a href="classOGRGeometry.html#a56ced443fbccb280290c107e7b69fb8f">More...</a><br /></td></tr>
<tr class="separator:a56ced443fbccb280290c107e7b69fb8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579b67f04630b791a229b6a7c2914640"><td class="memItemLeft" align="right" valign="top">virtual char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a579b67f04630b791a229b6a7c2914640">exportToKML</a> () const </td></tr>
<tr class="memdesc:a579b67f04630b791a229b6a7c2914640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry into KML format.  <a href="classOGRGeometry.html#a579b67f04630b791a229b6a7c2914640">More...</a><br /></td></tr>
<tr class="separator:a579b67f04630b791a229b6a7c2914640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28609fce6bd422b16182eab58ff4e812"><td class="memItemLeft" align="right" valign="top">virtual char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a28609fce6bd422b16182eab58ff4e812">exportToJson</a> () const </td></tr>
<tr class="memdesc:a28609fce6bd422b16182eab58ff4e812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry into GeoJSON format.  <a href="classOGRGeometry.html#a28609fce6bd422b16182eab58ff4e812">More...</a><br /></td></tr>
<tr class="separator:a28609fce6bd422b16182eab58ff4e812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26576c266578a8e83e325881243a166"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aa26576c266578a8e83e325881243a166">accept</a> (<a class="el" href="classIOGRGeometryVisitor.html">IOGRGeometryVisitor</a> *visitor)=0</td></tr>
<tr class="memdesc:aa26576c266578a8e83e325881243a166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept a visitor.  <a href="classOGRGeometry.html#aa26576c266578a8e83e325881243a166">More...</a><br /></td></tr>
<tr class="separator:aa26576c266578a8e83e325881243a166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f659bec82c0184b3bd6592248afda74"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a5f659bec82c0184b3bd6592248afda74">accept</a> (<a class="el" href="classIOGRConstGeometryVisitor.html">IOGRConstGeometryVisitor</a> *visitor) const =0</td></tr>
<tr class="memdesc:a5f659bec82c0184b3bd6592248afda74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept a visitor.  <a href="classOGRGeometry.html#a5f659bec82c0184b3bd6592248afda74">More...</a><br /></td></tr>
<tr class="separator:a5f659bec82c0184b3bd6592248afda74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea594db36b7281f73242273e22d62c2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__geometry_8h.html#adc1d7838410d13f36b3fa41c17a1a57e">GEOSGeom</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a2ea594db36b7281f73242273e22d62c2">exportToGEOS</a> (<a class="el" href="ogr__geometry_8h.html#a8fbe3d578fe2ba147a7a6a0c7a3d8f85">GEOSContextHandle_t</a> hGEOSCtxt) const <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a2ea594db36b7281f73242273e22d62c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a GEOSGeom object corresponding to the geometry.  <a href="classOGRGeometry.html#a2ea594db36b7281f73242273e22d62c2">More...</a><br /></td></tr>
<tr class="separator:a2ea594db36b7281f73242273e22d62c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0148448ea32534a351bcf1c5c88922"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a6c0148448ea32534a351bcf1c5c88922">hasCurveGeometry</a> (int bLookForNonLinear=FALSE) const </td></tr>
<tr class="memdesc:a6c0148448ea32534a351bcf1c5c88922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if this geometry is or has curve geometry.  <a href="classOGRGeometry.html#a6c0148448ea32534a351bcf1c5c88922">More...</a><br /></td></tr>
<tr class="separator:a6c0148448ea32534a351bcf1c5c88922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49749581ed7c99f9923029333f7c834c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a49749581ed7c99f9923029333f7c834c">getCurveGeometry</a> (const char *const *papszOptions=nullptr) const <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a49749581ed7c99f9923029333f7c834c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return curve version of this geometry.  <a href="classOGRGeometry.html#a49749581ed7c99f9923029333f7c834c">More...</a><br /></td></tr>
<tr class="separator:a49749581ed7c99f9923029333f7c834c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac13fa59ae1a0d46070e05d8007bd295e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ac13fa59ae1a0d46070e05d8007bd295e">getLinearGeometry</a> (double dfMaxAngleStepSizeDegrees=0, const char *const *papszOptions=nullptr) const <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:ac13fa59ae1a0d46070e05d8007bd295e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return, possibly approximate, non-curve version of this geometry.  <a href="classOGRGeometry.html#ac13fa59ae1a0d46070e05d8007bd295e">More...</a><br /></td></tr>
<tr class="separator:ac13fa59ae1a0d46070e05d8007bd295e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6cf249316b3046e0d4f77ec400e844"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aeb6cf249316b3046e0d4f77ec400e844">closeRings</a> ()</td></tr>
<tr class="memdesc:aeb6cf249316b3046e0d4f77ec400e844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force rings to be closed.  <a href="classOGRGeometry.html#aeb6cf249316b3046e0d4f77ec400e844">More...</a><br /></td></tr>
<tr class="separator:aeb6cf249316b3046e0d4f77ec400e844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f84a2b948d511f28c47c47577dea49"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a79f84a2b948d511f28c47c47577dea49">setCoordinateDimension</a> (int nDimension)</td></tr>
<tr class="memdesc:a79f84a2b948d511f28c47c47577dea49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the coordinate dimension.  <a href="classOGRGeometry.html#a79f84a2b948d511f28c47c47577dea49">More...</a><br /></td></tr>
<tr class="separator:a79f84a2b948d511f28c47c47577dea49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4dc0ab8f5269e24faad26387e344913"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ad4dc0ab8f5269e24faad26387e344913">set3D</a> (<a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> bIs3D)</td></tr>
<tr class="memdesc:ad4dc0ab8f5269e24faad26387e344913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add or remove the Z coordinate dimension.  <a href="classOGRGeometry.html#ad4dc0ab8f5269e24faad26387e344913">More...</a><br /></td></tr>
<tr class="separator:ad4dc0ab8f5269e24faad26387e344913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1d7eea437838415a14f9dc54523857"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a5f1d7eea437838415a14f9dc54523857">setMeasured</a> (<a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> bIsMeasured)</td></tr>
<tr class="memdesc:a5f1d7eea437838415a14f9dc54523857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add or remove the M coordinate dimension.  <a href="classOGRGeometry.html#a5f1d7eea437838415a14f9dc54523857">More...</a><br /></td></tr>
<tr class="separator:a5f1d7eea437838415a14f9dc54523857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4308e3549c65aa12cc2ba41be15d99a0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a4308e3549c65aa12cc2ba41be15d99a0">assignSpatialReference</a> (<a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *poSR)</td></tr>
<tr class="memdesc:a4308e3549c65aa12cc2ba41be15d99a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign spatial reference to this object.  <a href="classOGRGeometry.html#a4308e3549c65aa12cc2ba41be15d99a0">More...</a><br /></td></tr>
<tr class="separator:a4308e3549c65aa12cc2ba41be15d99a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194f0bbdae896539852106cafbffbe87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a194f0bbdae896539852106cafbffbe87">getSpatialReference</a> (void) const </td></tr>
<tr class="memdesc:a194f0bbdae896539852106cafbffbe87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns spatial reference system for object.  <a href="classOGRGeometry.html#a194f0bbdae896539852106cafbffbe87">More...</a><br /></td></tr>
<tr class="separator:a194f0bbdae896539852106cafbffbe87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e8bfb3c2129f25cf622660f734e1ba"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aa9e8bfb3c2129f25cf622660f734e1ba">transform</a> (<a class="el" href="classOGRCoordinateTransformation.html">OGRCoordinateTransformation</a> *poCT)=0</td></tr>
<tr class="memdesc:aa9e8bfb3c2129f25cf622660f734e1ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply arbitrary coordinate transformation to geometry.  <a href="classOGRGeometry.html#aa9e8bfb3c2129f25cf622660f734e1ba">More...</a><br /></td></tr>
<tr class="separator:aa9e8bfb3c2129f25cf622660f734e1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f0b441fbf2f66ce3ef3571268ab10f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ae3f0b441fbf2f66ce3ef3571268ab10f">transformTo</a> (<a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *poSR)</td></tr>
<tr class="memdesc:ae3f0b441fbf2f66ce3ef3571268ab10f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform geometry to new spatial reference system.  <a href="classOGRGeometry.html#ae3f0b441fbf2f66ce3ef3571268ab10f">More...</a><br /></td></tr>
<tr class="separator:ae3f0b441fbf2f66ce3ef3571268ab10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91685bd7c0bdd67cd073a8b4da3c06a5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a91685bd7c0bdd67cd073a8b4da3c06a5">segmentize</a> (double dfMaxLength)</td></tr>
<tr class="memdesc:a91685bd7c0bdd67cd073a8b4da3c06a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the geometry such it has no segment longer then the given distance.  <a href="classOGRGeometry.html#a91685bd7c0bdd67cd073a8b4da3c06a5">More...</a><br /></td></tr>
<tr class="separator:a91685bd7c0bdd67cd073a8b4da3c06a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb34b556c52aef3e93f03cf65d3f4bc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aadb34b556c52aef3e93f03cf65d3f4bc">Intersects</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const </td></tr>
<tr class="memdesc:aadb34b556c52aef3e93f03cf65d3f4bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do these features intersect?  <a href="classOGRGeometry.html#aadb34b556c52aef3e93f03cf65d3f4bc">More...</a><br /></td></tr>
<tr class="separator:aadb34b556c52aef3e93f03cf65d3f4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b80c7f464de1d332215f16d35138590"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a1b80c7f464de1d332215f16d35138590">Equals</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const =0</td></tr>
<tr class="memdesc:a1b80c7f464de1d332215f16d35138590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns TRUE if two geometries are equivalent.  <a href="classOGRGeometry.html#a1b80c7f464de1d332215f16d35138590">More...</a><br /></td></tr>
<tr class="separator:a1b80c7f464de1d332215f16d35138590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f683761d57c8bea40e4ca1d832760a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a45f683761d57c8bea40e4ca1d832760a">Disjoint</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const </td></tr>
<tr class="memdesc:a45f683761d57c8bea40e4ca1d832760a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for disjointness.  <a href="classOGRGeometry.html#a45f683761d57c8bea40e4ca1d832760a">More...</a><br /></td></tr>
<tr class="separator:a45f683761d57c8bea40e4ca1d832760a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3e23c20b51ceb5a56d397f812a81a2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a5d3e23c20b51ceb5a56d397f812a81a2">Touches</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const </td></tr>
<tr class="memdesc:a5d3e23c20b51ceb5a56d397f812a81a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for touching.  <a href="classOGRGeometry.html#a5d3e23c20b51ceb5a56d397f812a81a2">More...</a><br /></td></tr>
<tr class="separator:a5d3e23c20b51ceb5a56d397f812a81a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5656df62f0857852519bea1486ab1ff"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ad5656df62f0857852519bea1486ab1ff">Crosses</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const </td></tr>
<tr class="memdesc:ad5656df62f0857852519bea1486ab1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for crossing.  <a href="classOGRGeometry.html#ad5656df62f0857852519bea1486ab1ff">More...</a><br /></td></tr>
<tr class="separator:ad5656df62f0857852519bea1486ab1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4bb4687de9b6f23e61b686177b2856"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#abb4bb4687de9b6f23e61b686177b2856">Within</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const </td></tr>
<tr class="memdesc:abb4bb4687de9b6f23e61b686177b2856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for containment.  <a href="classOGRGeometry.html#abb4bb4687de9b6f23e61b686177b2856">More...</a><br /></td></tr>
<tr class="separator:abb4bb4687de9b6f23e61b686177b2856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2c9296c75521ec8aff5bc2285c347f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a5e2c9296c75521ec8aff5bc2285c347f">Contains</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const </td></tr>
<tr class="memdesc:a5e2c9296c75521ec8aff5bc2285c347f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for containment.  <a href="classOGRGeometry.html#a5e2c9296c75521ec8aff5bc2285c347f">More...</a><br /></td></tr>
<tr class="separator:a5e2c9296c75521ec8aff5bc2285c347f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc672c524568f3ee6ee5257b250d2b12"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#afc672c524568f3ee6ee5257b250d2b12">Overlaps</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const </td></tr>
<tr class="memdesc:afc672c524568f3ee6ee5257b250d2b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for overlap.  <a href="classOGRGeometry.html#afc672c524568f3ee6ee5257b250d2b12">More...</a><br /></td></tr>
<tr class="separator:afc672c524568f3ee6ee5257b250d2b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3ff65a7b1b76ec0f957d1c36a0632e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aea3ff65a7b1b76ec0f957d1c36a0632e">Boundary</a> () const <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:aea3ff65a7b1b76ec0f957d1c36a0632e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute boundary.  <a href="classOGRGeometry.html#aea3ff65a7b1b76ec0f957d1c36a0632e">More...</a><br /></td></tr>
<tr class="separator:aea3ff65a7b1b76ec0f957d1c36a0632e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24fb51e9b419e97f14964e5a00ae3fb4"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a24fb51e9b419e97f14964e5a00ae3fb4">Distance</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const </td></tr>
<tr class="memdesc:a24fb51e9b419e97f14964e5a00ae3fb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute distance between two geometries.  <a href="classOGRGeometry.html#a24fb51e9b419e97f14964e5a00ae3fb4">More...</a><br /></td></tr>
<tr class="separator:a24fb51e9b419e97f14964e5a00ae3fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d1ef564a0423a7619b2acc61cdc0dd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a94d1ef564a0423a7619b2acc61cdc0dd">ConvexHull</a> () const <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a94d1ef564a0423a7619b2acc61cdc0dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute convex hull.  <a href="classOGRGeometry.html#a94d1ef564a0423a7619b2acc61cdc0dd">More...</a><br /></td></tr>
<tr class="separator:a94d1ef564a0423a7619b2acc61cdc0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b450af88d10c763e5fb86e056fb307"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#af1b450af88d10c763e5fb86e056fb307">Buffer</a> (double dfDist, int nQuadSegs=30) const <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:af1b450af88d10c763e5fb86e056fb307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute buffer of geometry.  <a href="classOGRGeometry.html#af1b450af88d10c763e5fb86e056fb307">More...</a><br /></td></tr>
<tr class="separator:af1b450af88d10c763e5fb86e056fb307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83adb426e79958c90aecb418d91c765c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a83adb426e79958c90aecb418d91c765c">Intersection</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a83adb426e79958c90aecb418d91c765c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute intersection.  <a href="classOGRGeometry.html#a83adb426e79958c90aecb418d91c765c">More...</a><br /></td></tr>
<tr class="separator:a83adb426e79958c90aecb418d91c765c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a939bb2b738337a3af1fc715187822171"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a939bb2b738337a3af1fc715187822171">Union</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a939bb2b738337a3af1fc715187822171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute union.  <a href="classOGRGeometry.html#a939bb2b738337a3af1fc715187822171">More...</a><br /></td></tr>
<tr class="separator:a939bb2b738337a3af1fc715187822171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3413bfa82a0afc6b5fa77fafa3933549"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a3413bfa82a0afc6b5fa77fafa3933549">UnionCascaded</a> () const <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a3413bfa82a0afc6b5fa77fafa3933549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute union using cascading.  <a href="classOGRGeometry.html#a3413bfa82a0afc6b5fa77fafa3933549">More...</a><br /></td></tr>
<tr class="separator:a3413bfa82a0afc6b5fa77fafa3933549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817c860c39a7b2848f0ff2105faaa25a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a817c860c39a7b2848f0ff2105faaa25a">Difference</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a817c860c39a7b2848f0ff2105faaa25a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute difference.  <a href="classOGRGeometry.html#a817c860c39a7b2848f0ff2105faaa25a">More...</a><br /></td></tr>
<tr class="separator:a817c860c39a7b2848f0ff2105faaa25a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d3ec339f9a96ce2c4c01f165ec78a5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a75d3ec339f9a96ce2c4c01f165ec78a5">SymDifference</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a75d3ec339f9a96ce2c4c01f165ec78a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute symmetric difference.  <a href="classOGRGeometry.html#a75d3ec339f9a96ce2c4c01f165ec78a5">More...</a><br /></td></tr>
<tr class="separator:a75d3ec339f9a96ce2c4c01f165ec78a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab625f452bfbb60e517273c3b0e90ad6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aab625f452bfbb60e517273c3b0e90ad6">Centroid</a> (<a class="el" href="classOGRPoint.html">OGRPoint</a> *poPoint) const </td></tr>
<tr class="memdesc:aab625f452bfbb60e517273c3b0e90ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the geometry centroid.  <a href="classOGRGeometry.html#aab625f452bfbb60e517273c3b0e90ad6">More...</a><br /></td></tr>
<tr class="separator:aab625f452bfbb60e517273c3b0e90ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf92969a640cdd29c4c4eaacc95e6093"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#acf92969a640cdd29c4c4eaacc95e6093">Simplify</a> (double dTolerance) const <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:acf92969a640cdd29c4c4eaacc95e6093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify the geometry.  <a href="classOGRGeometry.html#acf92969a640cdd29c4c4eaacc95e6093">More...</a><br /></td></tr>
<tr class="separator:acf92969a640cdd29c4c4eaacc95e6093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4d7948332d9efd6548e1cf87bb6c8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a0f4d7948332d9efd6548e1cf87bb6c8f">SimplifyPreserveTopology</a> (double dTolerance) const <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a0f4d7948332d9efd6548e1cf87bb6c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify the geometry while preserving topology.  <a href="classOGRGeometry.html#a0f4d7948332d9efd6548e1cf87bb6c8f">More...</a><br /></td></tr>
<tr class="separator:a0f4d7948332d9efd6548e1cf87bb6c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d3c3e5b033ca6bbb470016e7661da7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ab7d3c3e5b033ca6bbb470016e7661da7">DelaunayTriangulation</a> (double dfTolerance, int bOnlyEdges) const <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:ab7d3c3e5b033ca6bbb470016e7661da7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Delaunay triangulation of the vertices of the geometry.  <a href="classOGRGeometry.html#ab7d3c3e5b033ca6bbb470016e7661da7">More...</a><br /></td></tr>
<tr class="separator:ab7d3c3e5b033ca6bbb470016e7661da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5524faa1746d9b6646ce5c6f28d31291"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a5524faa1746d9b6646ce5c6f28d31291">Polygonize</a> () const <a class="el" href="cpl__port_8h.html#add8bd16e2a1e63d383c4b4a06af268df">CPL_WARN_UNUSED_RESULT</a></td></tr>
<tr class="memdesc:a5524faa1746d9b6646ce5c6f28d31291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polygonizes a set of sparse edges.  <a href="classOGRGeometry.html#a5524faa1746d9b6646ce5c6f28d31291">More...</a><br /></td></tr>
<tr class="separator:a5524faa1746d9b6646ce5c6f28d31291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05627d890a50435c2c86db125de66a0"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ad05627d890a50435c2c86db125de66a0">Distance3D</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *poOtherGeom) const </td></tr>
<tr class="memdesc:ad05627d890a50435c2c86db125de66a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 3D distance between two geometries.  <a href="classOGRGeometry.html#ad05627d890a50435c2c86db125de66a0">More...</a><br /></td></tr>
<tr class="separator:ad05627d890a50435c2c86db125de66a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffd51d4998a8e2ae422c69b6adf480a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a3ffd51d4998a8e2ae422c69b6adf480a">swapXY</a> ()</td></tr>
<tr class="memdesc:a3ffd51d4998a8e2ae422c69b6adf480a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap x and y coordinates.  <a href="classOGRGeometry.html#a3ffd51d4998a8e2ae422c69b6adf480a">More...</a><br /></td></tr>
<tr class="separator:a3ffd51d4998a8e2ae422c69b6adf480a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2a41d2ee7091a39fc3f371db9e3825"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRPoint.html">OGRPoint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#acd2a41d2ee7091a39fc3f371db9e3825">toPoint</a> ()</td></tr>
<tr class="memdesc:acd2a41d2ee7091a39fc3f371db9e3825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRPoint*.  <a href="classOGRGeometry.html#acd2a41d2ee7091a39fc3f371db9e3825">More...</a><br /></td></tr>
<tr class="separator:acd2a41d2ee7091a39fc3f371db9e3825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18d20e8db1e512491045e3fa741d9b8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRPoint.html">OGRPoint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ab18d20e8db1e512491045e3fa741d9b8">toPoint</a> () const </td></tr>
<tr class="memdesc:ab18d20e8db1e512491045e3fa741d9b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRPoint*.  <a href="classOGRGeometry.html#ab18d20e8db1e512491045e3fa741d9b8">More...</a><br /></td></tr>
<tr class="separator:ab18d20e8db1e512491045e3fa741d9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2d0dbea86042310b29903dd69ed8fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRCurve.html">OGRCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ace2d0dbea86042310b29903dd69ed8fd">toCurve</a> ()</td></tr>
<tr class="memdesc:ace2d0dbea86042310b29903dd69ed8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRCurve*.  <a href="classOGRGeometry.html#ace2d0dbea86042310b29903dd69ed8fd">More...</a><br /></td></tr>
<tr class="separator:ace2d0dbea86042310b29903dd69ed8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48dc561332dd021bf0683a9c684a7eec"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRCurve.html">OGRCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a48dc561332dd021bf0683a9c684a7eec">toCurve</a> () const </td></tr>
<tr class="memdesc:a48dc561332dd021bf0683a9c684a7eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRCurve*.  <a href="classOGRGeometry.html#a48dc561332dd021bf0683a9c684a7eec">More...</a><br /></td></tr>
<tr class="separator:a48dc561332dd021bf0683a9c684a7eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12124534e4e04cece366a244b13faf3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRSimpleCurve.html">OGRSimpleCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a12124534e4e04cece366a244b13faf3b">toSimpleCurve</a> ()</td></tr>
<tr class="memdesc:a12124534e4e04cece366a244b13faf3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRSimpleCurve*.  <a href="classOGRGeometry.html#a12124534e4e04cece366a244b13faf3b">More...</a><br /></td></tr>
<tr class="separator:a12124534e4e04cece366a244b13faf3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab16930d1b8022fb1ef02cbed2961ad9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRSimpleCurve.html">OGRSimpleCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aab16930d1b8022fb1ef02cbed2961ad9">toSimpleCurve</a> () const </td></tr>
<tr class="memdesc:aab16930d1b8022fb1ef02cbed2961ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRSimpleCurve*.  <a href="classOGRGeometry.html#aab16930d1b8022fb1ef02cbed2961ad9">More...</a><br /></td></tr>
<tr class="separator:aab16930d1b8022fb1ef02cbed2961ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd4fd93ce3b53eb809d72b301bf6a6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRLineString.html">OGRLineString</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a0bd4fd93ce3b53eb809d72b301bf6a6e">toLineString</a> ()</td></tr>
<tr class="memdesc:a0bd4fd93ce3b53eb809d72b301bf6a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRLineString*.  <a href="classOGRGeometry.html#a0bd4fd93ce3b53eb809d72b301bf6a6e">More...</a><br /></td></tr>
<tr class="separator:a0bd4fd93ce3b53eb809d72b301bf6a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a970cf339912ecb4666a4573bb2da5e15"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRLineString.html">OGRLineString</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a970cf339912ecb4666a4573bb2da5e15">toLineString</a> () const </td></tr>
<tr class="memdesc:a970cf339912ecb4666a4573bb2da5e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRLineString*.  <a href="classOGRGeometry.html#a970cf339912ecb4666a4573bb2da5e15">More...</a><br /></td></tr>
<tr class="separator:a970cf339912ecb4666a4573bb2da5e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087c768a91d977f065caa4f7b75e71b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRLinearRing.html">OGRLinearRing</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a087c768a91d977f065caa4f7b75e71b6">toLinearRing</a> ()</td></tr>
<tr class="memdesc:a087c768a91d977f065caa4f7b75e71b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRLinearRing*.  <a href="classOGRGeometry.html#a087c768a91d977f065caa4f7b75e71b6">More...</a><br /></td></tr>
<tr class="separator:a087c768a91d977f065caa4f7b75e71b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae149295a0427b80cc0f780cf71c84cc9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRLinearRing.html">OGRLinearRing</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ae149295a0427b80cc0f780cf71c84cc9">toLinearRing</a> () const </td></tr>
<tr class="memdesc:ae149295a0427b80cc0f780cf71c84cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRLinearRing*.  <a href="classOGRGeometry.html#ae149295a0427b80cc0f780cf71c84cc9">More...</a><br /></td></tr>
<tr class="separator:ae149295a0427b80cc0f780cf71c84cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a3f3726ec41a2579ccaadf34d109b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRCircularString.html">OGRCircularString</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a07a3f3726ec41a2579ccaadf34d109b9">toCircularString</a> ()</td></tr>
<tr class="memdesc:a07a3f3726ec41a2579ccaadf34d109b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRCircularString*.  <a href="classOGRGeometry.html#a07a3f3726ec41a2579ccaadf34d109b9">More...</a><br /></td></tr>
<tr class="separator:a07a3f3726ec41a2579ccaadf34d109b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113fa3d11cff7e5b6bf7ad802a24a7ec"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRCircularString.html">OGRCircularString</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a113fa3d11cff7e5b6bf7ad802a24a7ec">toCircularString</a> () const </td></tr>
<tr class="memdesc:a113fa3d11cff7e5b6bf7ad802a24a7ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRCircularString*.  <a href="classOGRGeometry.html#a113fa3d11cff7e5b6bf7ad802a24a7ec">More...</a><br /></td></tr>
<tr class="separator:a113fa3d11cff7e5b6bf7ad802a24a7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60510a2c16c5735dc358bc2a19b1640d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRCompoundCurve.html">OGRCompoundCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a60510a2c16c5735dc358bc2a19b1640d">toCompoundCurve</a> ()</td></tr>
<tr class="memdesc:a60510a2c16c5735dc358bc2a19b1640d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRCompoundCurve*.  <a href="classOGRGeometry.html#a60510a2c16c5735dc358bc2a19b1640d">More...</a><br /></td></tr>
<tr class="separator:a60510a2c16c5735dc358bc2a19b1640d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39096a050094cf38bb1a1fa79841f865"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRCompoundCurve.html">OGRCompoundCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a39096a050094cf38bb1a1fa79841f865">toCompoundCurve</a> () const </td></tr>
<tr class="memdesc:a39096a050094cf38bb1a1fa79841f865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRCompoundCurve*.  <a href="classOGRGeometry.html#a39096a050094cf38bb1a1fa79841f865">More...</a><br /></td></tr>
<tr class="separator:a39096a050094cf38bb1a1fa79841f865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab897e836fd4781637a34014833b1ee3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRSurface.html">OGRSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ab897e836fd4781637a34014833b1ee3d">toSurface</a> ()</td></tr>
<tr class="memdesc:ab897e836fd4781637a34014833b1ee3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRSurface*.  <a href="classOGRGeometry.html#ab897e836fd4781637a34014833b1ee3d">More...</a><br /></td></tr>
<tr class="separator:ab897e836fd4781637a34014833b1ee3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af593a23539c6c37ae200d493bd856c63"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRSurface.html">OGRSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#af593a23539c6c37ae200d493bd856c63">toSurface</a> () const </td></tr>
<tr class="memdesc:af593a23539c6c37ae200d493bd856c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRSurface*.  <a href="classOGRGeometry.html#af593a23539c6c37ae200d493bd856c63">More...</a><br /></td></tr>
<tr class="separator:af593a23539c6c37ae200d493bd856c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27dff1a7736b53eb4d98c9176059fb80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRPolygon.html">OGRPolygon</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a27dff1a7736b53eb4d98c9176059fb80">toPolygon</a> ()</td></tr>
<tr class="memdesc:a27dff1a7736b53eb4d98c9176059fb80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRPolygon*.  <a href="classOGRGeometry.html#a27dff1a7736b53eb4d98c9176059fb80">More...</a><br /></td></tr>
<tr class="separator:a27dff1a7736b53eb4d98c9176059fb80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3e5a36deb6295c572f779817f5d3f3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRPolygon.html">OGRPolygon</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aef3e5a36deb6295c572f779817f5d3f3">toPolygon</a> () const </td></tr>
<tr class="memdesc:aef3e5a36deb6295c572f779817f5d3f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRPolygon*.  <a href="classOGRGeometry.html#aef3e5a36deb6295c572f779817f5d3f3">More...</a><br /></td></tr>
<tr class="separator:aef3e5a36deb6295c572f779817f5d3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62fb2faaa7fe58555a39509a5ef2714"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRTriangle.html">OGRTriangle</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aa62fb2faaa7fe58555a39509a5ef2714">toTriangle</a> ()</td></tr>
<tr class="memdesc:aa62fb2faaa7fe58555a39509a5ef2714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRTriangle*.  <a href="classOGRGeometry.html#aa62fb2faaa7fe58555a39509a5ef2714">More...</a><br /></td></tr>
<tr class="separator:aa62fb2faaa7fe58555a39509a5ef2714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7870518064bf89ee2e3a2067ab80acd9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRTriangle.html">OGRTriangle</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a7870518064bf89ee2e3a2067ab80acd9">toTriangle</a> () const </td></tr>
<tr class="memdesc:a7870518064bf89ee2e3a2067ab80acd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRTriangle*.  <a href="classOGRGeometry.html#a7870518064bf89ee2e3a2067ab80acd9">More...</a><br /></td></tr>
<tr class="separator:a7870518064bf89ee2e3a2067ab80acd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2307d44f31cc898ecbc2c8349bbc82f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRCurvePolygon.html">OGRCurvePolygon</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a2307d44f31cc898ecbc2c8349bbc82f9">toCurvePolygon</a> ()</td></tr>
<tr class="memdesc:a2307d44f31cc898ecbc2c8349bbc82f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRCurvePolygon*.  <a href="classOGRGeometry.html#a2307d44f31cc898ecbc2c8349bbc82f9">More...</a><br /></td></tr>
<tr class="separator:a2307d44f31cc898ecbc2c8349bbc82f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb0ea3e90f84666dde9ce368dd66aee"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRCurvePolygon.html">OGRCurvePolygon</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a3cb0ea3e90f84666dde9ce368dd66aee">toCurvePolygon</a> () const </td></tr>
<tr class="memdesc:a3cb0ea3e90f84666dde9ce368dd66aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRCurvePolygon*.  <a href="classOGRGeometry.html#a3cb0ea3e90f84666dde9ce368dd66aee">More...</a><br /></td></tr>
<tr class="separator:a3cb0ea3e90f84666dde9ce368dd66aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fdf3c79104eb641260abcc2b4a7cc43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRGeometryCollection.html">OGRGeometryCollection</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a9fdf3c79104eb641260abcc2b4a7cc43">toGeometryCollection</a> ()</td></tr>
<tr class="memdesc:a9fdf3c79104eb641260abcc2b4a7cc43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRGeometryCollection*.  <a href="classOGRGeometry.html#a9fdf3c79104eb641260abcc2b4a7cc43">More...</a><br /></td></tr>
<tr class="separator:a9fdf3c79104eb641260abcc2b4a7cc43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8388899647dc245571be497d86f7ea"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRGeometryCollection.html">OGRGeometryCollection</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a0d8388899647dc245571be497d86f7ea">toGeometryCollection</a> () const </td></tr>
<tr class="memdesc:a0d8388899647dc245571be497d86f7ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRGeometryCollection*.  <a href="classOGRGeometry.html#a0d8388899647dc245571be497d86f7ea">More...</a><br /></td></tr>
<tr class="separator:a0d8388899647dc245571be497d86f7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7cd71af4f5c75ac0b9ccd64bd4b1117"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRMultiPoint.html">OGRMultiPoint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ab7cd71af4f5c75ac0b9ccd64bd4b1117">toMultiPoint</a> ()</td></tr>
<tr class="memdesc:ab7cd71af4f5c75ac0b9ccd64bd4b1117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRMultiPoint*.  <a href="classOGRGeometry.html#ab7cd71af4f5c75ac0b9ccd64bd4b1117">More...</a><br /></td></tr>
<tr class="separator:ab7cd71af4f5c75ac0b9ccd64bd4b1117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a701f30ec2d0c16777c7f474d061136"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRMultiPoint.html">OGRMultiPoint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a5a701f30ec2d0c16777c7f474d061136">toMultiPoint</a> () const </td></tr>
<tr class="memdesc:a5a701f30ec2d0c16777c7f474d061136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRMultiPoint*.  <a href="classOGRGeometry.html#a5a701f30ec2d0c16777c7f474d061136">More...</a><br /></td></tr>
<tr class="separator:a5a701f30ec2d0c16777c7f474d061136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a79860e0f5a7f7e1962a0854d140f6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRMultiLineString.html">OGRMultiLineString</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a4a79860e0f5a7f7e1962a0854d140f6d">toMultiLineString</a> ()</td></tr>
<tr class="memdesc:a4a79860e0f5a7f7e1962a0854d140f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRMultiLineString*.  <a href="classOGRGeometry.html#a4a79860e0f5a7f7e1962a0854d140f6d">More...</a><br /></td></tr>
<tr class="separator:a4a79860e0f5a7f7e1962a0854d140f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464cb74217f911b0010ea716e38b9283"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRMultiLineString.html">OGRMultiLineString</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a464cb74217f911b0010ea716e38b9283">toMultiLineString</a> () const </td></tr>
<tr class="memdesc:a464cb74217f911b0010ea716e38b9283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRMultiLineString*.  <a href="classOGRGeometry.html#a464cb74217f911b0010ea716e38b9283">More...</a><br /></td></tr>
<tr class="separator:a464cb74217f911b0010ea716e38b9283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e387baec4de093ff6af3ec7ad76cbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRMultiPolygon.html">OGRMultiPolygon</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a07e387baec4de093ff6af3ec7ad76cbe">toMultiPolygon</a> ()</td></tr>
<tr class="memdesc:a07e387baec4de093ff6af3ec7ad76cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRMultiPolygon*.  <a href="classOGRGeometry.html#a07e387baec4de093ff6af3ec7ad76cbe">More...</a><br /></td></tr>
<tr class="separator:a07e387baec4de093ff6af3ec7ad76cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e7707556b46a83af4f810b8c771f5a5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRMultiPolygon.html">OGRMultiPolygon</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a5e7707556b46a83af4f810b8c771f5a5">toMultiPolygon</a> () const </td></tr>
<tr class="memdesc:a5e7707556b46a83af4f810b8c771f5a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRMultiPolygon*.  <a href="classOGRGeometry.html#a5e7707556b46a83af4f810b8c771f5a5">More...</a><br /></td></tr>
<tr class="separator:a5e7707556b46a83af4f810b8c771f5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8345d52f5748268059f485790ad8b3a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRMultiCurve.html">OGRMultiCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a8345d52f5748268059f485790ad8b3a1">toMultiCurve</a> ()</td></tr>
<tr class="memdesc:a8345d52f5748268059f485790ad8b3a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRMultiCurve*.  <a href="classOGRGeometry.html#a8345d52f5748268059f485790ad8b3a1">More...</a><br /></td></tr>
<tr class="separator:a8345d52f5748268059f485790ad8b3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f8913f5460bfae2b0c7115e36a453d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRMultiCurve.html">OGRMultiCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ab6f8913f5460bfae2b0c7115e36a453d">toMultiCurve</a> () const </td></tr>
<tr class="memdesc:ab6f8913f5460bfae2b0c7115e36a453d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRMultiCurve*.  <a href="classOGRGeometry.html#ab6f8913f5460bfae2b0c7115e36a453d">More...</a><br /></td></tr>
<tr class="separator:ab6f8913f5460bfae2b0c7115e36a453d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93bfa0ab44ce276ef9666724856c40cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRMultiSurface.html">OGRMultiSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a93bfa0ab44ce276ef9666724856c40cf">toMultiSurface</a> ()</td></tr>
<tr class="memdesc:a93bfa0ab44ce276ef9666724856c40cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRMultiSurface*.  <a href="classOGRGeometry.html#a93bfa0ab44ce276ef9666724856c40cf">More...</a><br /></td></tr>
<tr class="separator:a93bfa0ab44ce276ef9666724856c40cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4389f17ac17f6f0749defc80bfdb91ea"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRMultiSurface.html">OGRMultiSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a4389f17ac17f6f0749defc80bfdb91ea">toMultiSurface</a> () const </td></tr>
<tr class="memdesc:a4389f17ac17f6f0749defc80bfdb91ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRMultiSurface*.  <a href="classOGRGeometry.html#a4389f17ac17f6f0749defc80bfdb91ea">More...</a><br /></td></tr>
<tr class="separator:a4389f17ac17f6f0749defc80bfdb91ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1990bb40f7ef045f9f9e796883591b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRPolyhedralSurface.html">OGRPolyhedralSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a4d1990bb40f7ef045f9f9e796883591b">toPolyhedralSurface</a> ()</td></tr>
<tr class="memdesc:a4d1990bb40f7ef045f9f9e796883591b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRPolyhedralSurface*.  <a href="classOGRGeometry.html#a4d1990bb40f7ef045f9f9e796883591b">More...</a><br /></td></tr>
<tr class="separator:a4d1990bb40f7ef045f9f9e796883591b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7652b5480bd90dcc2849a06a665e6b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRPolyhedralSurface.html">OGRPolyhedralSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a0c7652b5480bd90dcc2849a06a665e6b">toPolyhedralSurface</a> () const </td></tr>
<tr class="memdesc:a0c7652b5480bd90dcc2849a06a665e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRPolyhedralSurface*.  <a href="classOGRGeometry.html#a0c7652b5480bd90dcc2849a06a665e6b">More...</a><br /></td></tr>
<tr class="separator:a0c7652b5480bd90dcc2849a06a665e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46bef33c21122557417dd57517421201"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRTriangulatedSurface.html">OGRTriangulatedSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a46bef33c21122557417dd57517421201">toTriangulatedSurface</a> ()</td></tr>
<tr class="memdesc:a46bef33c21122557417dd57517421201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRTriangulatedSurface*.  <a href="classOGRGeometry.html#a46bef33c21122557417dd57517421201">More...</a><br /></td></tr>
<tr class="separator:a46bef33c21122557417dd57517421201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b17907427dfd40be51cb367d1b19f8d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRTriangulatedSurface.html">OGRTriangulatedSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a6b17907427dfd40be51cb367d1b19f8d">toTriangulatedSurface</a> () const </td></tr>
<tr class="memdesc:a6b17907427dfd40be51cb367d1b19f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRTriangulatedSurface*.  <a href="classOGRGeometry.html#a6b17907427dfd40be51cb367d1b19f8d">More...</a><br /></td></tr>
<tr class="separator:a6b17907427dfd40be51cb367d1b19f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:adc3083a9978cf5ad3658b1b86342e256"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="ogr__geometry_8h.html#a8fbe3d578fe2ba147a7a6a0c7a3d8f85">GEOSContextHandle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#adc3083a9978cf5ad3658b1b86342e256">createGEOSContext</a> ()</td></tr>
<tr class="memdesc:adc3083a9978cf5ad3658b1b86342e256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new GEOS context.  <a href="classOGRGeometry.html#adc3083a9978cf5ad3658b1b86342e256">More...</a><br /></td></tr>
<tr class="separator:adc3083a9978cf5ad3658b1b86342e256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050eca02b140070855dff24bc5b18800"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a050eca02b140070855dff24bc5b18800">freeGEOSContext</a> (<a class="el" href="ogr__geometry_8h.html#a8fbe3d578fe2ba147a7a6a0c7a3d8f85">GEOSContextHandle_t</a> hGEOSCtxt)</td></tr>
<tr class="memdesc:a050eca02b140070855dff24bc5b18800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a GEOS context.  <a href="classOGRGeometry.html#a050eca02b140070855dff24bc5b18800">More...</a><br /></td></tr>
<tr class="separator:a050eca02b140070855dff24bc5b18800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae518798c9e80bad59b0907f43d375876"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ae518798c9e80bad59b0907f43d375876">ToHandle</a> (<a class="el" href="classOGRGeometry.html">OGRGeometry</a> *poGeom)</td></tr>
<tr class="memdesc:ae518798c9e80bad59b0907f43d375876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a OGRGeometry* to a OGRGeometryH.  <a href="classOGRGeometry.html#ae518798c9e80bad59b0907f43d375876">More...</a><br /></td></tr>
<tr class="separator:ae518798c9e80bad59b0907f43d375876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf3407a6fa0e90e4625b023e9ef17c1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#abaf3407a6fa0e90e4625b023e9ef17c1">FromHandle</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hGeom)</td></tr>
<tr class="memdesc:abaf3407a6fa0e90e4625b023e9ef17c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a OGRGeometryH to a OGRGeometry*.  <a href="classOGRGeometry.html#abaf3407a6fa0e90e4625b023e9ef17c1">More...</a><br /></td></tr>
<tr class="separator:abaf3407a6fa0e90e4625b023e9ef17c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Abstract base class for all geometry classes. </p>
<p>Some spatial analysis methods require that OGR is built on the GEOS library to work properly. The precise meaning of methods that describe spatial relationships between geometries is described in the SFCOM, or other simple features interface specifications, like "OpenGIS® Implementation Specification for Geographic information - Simple feature access - Part 1: Common architecture":
&lt;a href="<a href="http://www.opengeospatial.org/standards/sfa">http://www.opengeospatial.org/standards/sfa</a>"&gt;OGC 06-103r4</p>
<p>In GDAL 2.0, the hierarchy of classes has been extended with <a href="https://portal.opengeospatial.org/files/?artifact_id=32024">(working draft) ISO SQL/MM Part 3 (ISO/IEC 13249-3)</a> curve geometries : CIRCULARSTRING (<a class="el" href="classOGRCircularString.html" title="Concrete representation of a circular string, that is to say a curve made of one or several arc circl...">OGRCircularString</a>), COMPOUNDCURVE (<a class="el" href="classOGRCompoundCurve.html" title="Utility class to store a collection of curves. ">OGRCompoundCurve</a>), CURVEPOLYGON (<a class="el" href="classOGRCurvePolygon.html" title="Concrete class representing curve polygons. ">OGRCurvePolygon</a>), MULTICURVE (<a class="el" href="classOGRMultiCurve.html" title="A collection of OGRCurve. ">OGRMultiCurve</a>) and MULTISURFACE (<a class="el" href="classOGRMultiSurface.html" title="A collection of non-overlapping OGRSurface. ">OGRMultiSurface</a>). </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac0b82162f8efdec26efee2e22aba8cda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRGeometry::OGRGeometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Note: before GDAL 2.1, only the default implementation of the constructor existed, which could be unsafe to use.</p>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa26576c266578a8e83e325881243a166"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OGRGeometry::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIOGRGeometryVisitor.html">IOGRGeometryVisitor</a> *&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accept a visitor. </p>

<p>Implemented in <a class="el" href="classOGRMultiLineString.html#a9e8a6117769233cca18b3e3f6fedf3c6">OGRMultiLineString</a>, <a class="el" href="classOGRMultiCurve.html#aed5eb4e886b490a422aaa080f7df84c1">OGRMultiCurve</a>, <a class="el" href="classOGRMultiPoint.html#a6bf5d824525f23b1fc05ffc79a1abbca">OGRMultiPoint</a>, <a class="el" href="classOGRTriangulatedSurface.html#a5677c8acc2c422704d1af2d7868476f6">OGRTriangulatedSurface</a>, <a class="el" href="classOGRPolyhedralSurface.html#a949f9cb8ad8375f9809cde21d1e2a106">OGRPolyhedralSurface</a>, <a class="el" href="classOGRMultiPolygon.html#a90f692cf129a96b56c0c23d4a83bde69">OGRMultiPolygon</a>, <a class="el" href="classOGRMultiSurface.html#a31ccf4eecf78fd60e8c8b5e0b34a6736">OGRMultiSurface</a>, <a class="el" href="classOGRGeometryCollection.html#a252268bb143d32548c961bf9f3edf527">OGRGeometryCollection</a>, <a class="el" href="classOGRTriangle.html#a60102fc842dcd482d95e08af225365bb">OGRTriangle</a>, <a class="el" href="classOGRPolygon.html#af62d95144d5b6c747b492e40a5698195">OGRPolygon</a>, <a class="el" href="classOGRCurvePolygon.html#a43c9af4e0ff50cec5e8662a4fdbd9628">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#aeb258e45cec4488c420e92ecf749b5a7">OGRCompoundCurve</a>, <a class="el" href="classOGRCircularString.html#a33f0db1021f7792a0a5adebbfabe40d5">OGRCircularString</a>, <a class="el" href="classOGRLinearRing.html#acb4cae92e47294abf55c117aafae308b">OGRLinearRing</a>, <a class="el" href="classOGRLineString.html#a49c349d567436a1101017b1e71771ba3">OGRLineString</a>, and <a class="el" href="classOGRPoint.html#a06d0640a4f2aaa222582fb2e23212512">OGRPoint</a>.</p>

</div>
</div>
<a class="anchor" id="a5f659bec82c0184b3bd6592248afda74"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OGRGeometry::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIOGRConstGeometryVisitor.html">IOGRConstGeometryVisitor</a> *&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accept a visitor. </p>

<p>Implemented in <a class="el" href="classOGRMultiLineString.html#a4b64a513652d6e87027bef5ea2e0b3d4">OGRMultiLineString</a>, <a class="el" href="classOGRMultiCurve.html#a328af1b54f09181097e8fa1c549536d4">OGRMultiCurve</a>, <a class="el" href="classOGRMultiPoint.html#a8e327838ce6b3f09051d53ea69487796">OGRMultiPoint</a>, <a class="el" href="classOGRTriangulatedSurface.html#aac2843a3dbfcb72e7e31adfd8e60ab06">OGRTriangulatedSurface</a>, <a class="el" href="classOGRPolyhedralSurface.html#afe0757388ecac3f828bb94691eaa7e97">OGRPolyhedralSurface</a>, <a class="el" href="classOGRMultiPolygon.html#a57b0ffe00bd90549b00b2d23078732e9">OGRMultiPolygon</a>, <a class="el" href="classOGRMultiSurface.html#ae76ae60f4cce3186621afc1f1ee26df3">OGRMultiSurface</a>, <a class="el" href="classOGRGeometryCollection.html#a30e4613f81c8b4154ef3c628f967e58d">OGRGeometryCollection</a>, <a class="el" href="classOGRTriangle.html#a6e2c3ed147af7f0c008873b33a918bfe">OGRTriangle</a>, <a class="el" href="classOGRPolygon.html#ad23ed28465887650ec7887da73869e7c">OGRPolygon</a>, <a class="el" href="classOGRCurvePolygon.html#af5129fb870acd6508fba57b800f7e07a">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#a059debdcf7439431d7080fcaefd328ba">OGRCompoundCurve</a>, <a class="el" href="classOGRCircularString.html#aeef118738c013eeb57e0c52dfcb94aef">OGRCircularString</a>, <a class="el" href="classOGRLinearRing.html#a68734726dded21350284a56a220471c1">OGRLinearRing</a>, <a class="el" href="classOGRLineString.html#a1b7782127f5ae94cda667d82f76660a4">OGRLineString</a>, and <a class="el" href="classOGRPoint.html#a6bb5ba67c3baad75292faba2499a3bda">OGRPoint</a>.</p>

</div>
</div>
<a class="anchor" id="a4308e3549c65aa12cc2ba41be15d99a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::assignSpatialReference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&#160;</td>
          <td class="paramname"><em>poSR</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign spatial reference to this object. </p>
<p>Any existing spatial reference is replaced, but under no circumstances does this result in the object being reprojected. It is just changing the interpretation of the existing geometry. Note that assigning a spatial reference increments the reference count on the <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a>, but does not copy it.</p>
<p>Starting with GDAL 2.3, this will also assign the spatial reference to potential sub-geometries of the geometry (<a class="el" href="classOGRGeometryCollection.html" title="A collection of 1 or more geometry objects. ">OGRGeometryCollection</a>, OGRCurvePolygon/OGRPolygon, <a class="el" href="classOGRCompoundCurve.html" title="Utility class to store a collection of curves. ">OGRCompoundCurve</a>, <a class="el" href="classOGRPolyhedralSurface.html" title="PolyhedralSurface class. ">OGRPolyhedralSurface</a> and their derived classes).</p>
<p>This is similar to the SFCOM IGeometry::put_SpatialReference() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a4dfbd5861e1cd20b372d090539fa4536" title="Assign spatial reference to this object. ">OGR_G_AssignSpatialReference()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poSR</td><td>new spatial reference system to apply. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classOGRPolyhedralSurface.html#a39753fa915f9e55e82e97e10380f3e45">OGRPolyhedralSurface</a>, <a class="el" href="classOGRGeometryCollection.html#ab87ee929a53cceb0293e2eb5dec0d29a">OGRGeometryCollection</a>, <a class="el" href="classOGRCurvePolygon.html#ab7641ef1ec75f1c063ade8c2ad768fa2">OGRCurvePolygon</a>, and <a class="el" href="classOGRCompoundCurve.html#ae477065ac60818ed8c9fb3b44ea3aaac">OGRCompoundCurve</a>.</p>

</div>
</div>
<a class="anchor" id="aea3ff65a7b1b76ec0f957d1c36a0632e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::Boundary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute boundary. </p>
<p>A new geometry object is created and returned containing the boundary of the geometry on which the method is invoked.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a88e2ce6b8ad4347fa8bdbb1cdc0ad272" title="Compute boundary. ">OGR_G_Boundary()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated geometry now owned by the caller, or NULL on failure.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 </dd></dl>

</div>
</div>
<a class="anchor" id="af1b450af88d10c763e5fb86e056fb307"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::Buffer </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nQuadSegs</em> = <code>30</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute buffer of geometry. </p>
<p>Builds a new geometry containing the buffer region around the geometry on which it is invoked. The buffer is a polygon containing the region within the buffer distance of the original geometry.</p>
<p>Some buffer sections are properly described as curves, but are converted to approximate polygons. The nQuadSegs parameter can be used to control how many segments should be used to define a 90 degree curve - a quadrant of a circle. A value of 30 is a reasonable default. Large values result in large numbers of vertices in the resulting buffer geometry while small numbers reduce the accuracy of the result.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a650366258bd4aa2a5a5e55966299cfc1" title="Compute buffer of geometry. ">OGR_G_Buffer()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfDist</td><td>the buffer distance to be applied. Should be expressed into the same unit as the coordinates of the geometry.</td></tr>
    <tr><td class="paramname">nQuadSegs</td><td>the number of segments used to approximate a 90 degree (quadrant) of curvature.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created geometry, or NULL if an error occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="aab625f452bfbb60e517273c3b0e90ad6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRGeometry::Centroid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRPoint.html">OGRPoint</a> *&#160;</td>
          <td class="paramname"><em>poPoint</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the geometry centroid. </p>
<p>The centroid location is applied to the passed in <a class="el" href="classOGRPoint.html" title="Point class. ">OGRPoint</a> object. The centroid is not necessarily within the geometry.</p>
<p>This method relates to the SFCOM ISurface::get_Centroid() method however the current implementation based on GEOS can operate on other geometry types such as multipoint, linestring, geometrycollection such as multipolygons. OGC SF SQL 1.1 defines the operation for surfaces (polygons). SQL/MM-Part 3 defines the operation for surfaces and multisurfaces (multipolygons).</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#a23f5a19a81628af7f9cc59a37378cb2b" title="Compute the geometry centroid. ">OGR_G_Centroid()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or OGRERR_FAILURE on error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 as a <a class="el" href="classOGRGeometry.html" title="Abstract base class for all geometry classes. ">OGRGeometry</a> method (previously was restricted to <a class="el" href="classOGRPolygon.html" title="Concrete class representing polygons. ">OGRPolygon</a>) </dd></dl>

</div>
</div>
<a class="anchor" id="a678d3e4fc419b7b714ecb80cbf603eb5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a copy of this object. </p>
<p>This method relates to the SFCOM IGeometry::clone() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#aed1c08151c1873ebd4722cdf79a5ae2c" title="Make a copy of this object. ">OGR_G_Clone()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a new object instance with the same geometry, and spatial reference system as the original. </dd></dl>

<p>Implemented in <a class="el" href="classOGRPolyhedralSurface.html#a090d02e43183182c1a815f1bb2b990c4">OGRPolyhedralSurface</a>, <a class="el" href="classOGRGeometryCollection.html#aafc55e2c114a9ea65f1c7ca7bc0885b4">OGRGeometryCollection</a>, <a class="el" href="classOGRCurvePolygon.html#ab1f7243dece2962e15927881f13de887">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#a86e2e01a43f04dbcd7fa6806916bbf7a">OGRCompoundCurve</a>, <a class="el" href="classOGRLinearRing.html#aa2ca7e93b6a40a9cbf41e20179929252">OGRLinearRing</a>, <a class="el" href="classOGRSimpleCurve.html#acb9931271d01632f7c2c6d302815663e">OGRSimpleCurve</a>, and <a class="el" href="classOGRPoint.html#afccbf687b550b15b0fe957bd1b407e37">OGRPoint</a>.</p>

</div>
</div>
<a class="anchor" id="aeb6cf249316b3046e0d4f77ec400e844"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::closeRings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Force rings to be closed. </p>
<p>If this geometry, or any contained geometries has polygon rings that are not closed, they will be closed by adding the starting point at the end. </p>

<p>Reimplemented in <a class="el" href="classOGRGeometryCollection.html#a53b4239519af6079fa735e9d91938d5c">OGRGeometryCollection</a>, <a class="el" href="classOGRPolygon.html#aff7bce5d2c53421164b31cc9cb803d03">OGRPolygon</a>, and <a class="el" href="classOGRLinearRing.html#aa094e3579479b77a9dfbcafd91a3f366">OGRLinearRing</a>.</p>

</div>
</div>
<a class="anchor" id="a5e2c9296c75521ec8aff5bc2285c347f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRGeometry::Contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test for containment. </p>
<p>Tests if actual geometry object contains the passed geometry.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call <a class="el" href="classOGRGeometry.html#a7bbb194937466a6127b5436ac2ae99d9" title="Test if the geometry is valid. ">IsValid()</a> before, otherwise the result might be wrong.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ad87e37380f0320faddbe5e67e23312f8" title="Test for containment. ">OGR_G_Contains()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOtherGeom</td><td>the geometry to compare to this geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if poOtherGeom contains this geometry, otherwise FALSE. </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRCurvePolygon.html#a3e60f2ed59b940cf72746a2b9c4dfe18">OGRCurvePolygon</a>.</p>

</div>
</div>
<a class="anchor" id="a94d1ef564a0423a7619b2acc61cdc0dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::ConvexHull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute convex hull. </p>
<p>A new geometry object is created and returned containing the convex hull of the geometry on which the method is invoked.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ad5408cae52870b2d162f166f42cd684b" title="Compute convex hull. ">OGR_G_ConvexHull()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated geometry now owned by the caller, or NULL on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a9b1cead13e95b28a78261fee3b1cebb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRGeometry::CoordinateDimension </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the dimension of the coordinates in this object. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ac4843a200c0c4e57bbdc99e509f68baf" title="Get the dimension of the coordinates in this geometry. ">OGR_G_CoordinateDimension()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>this will return 2 for XY, 3 for XYZ and XYM, and 4 for XYZM data.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

</div>
</div>
<a class="anchor" id="adc3083a9978cf5ad3658b1b86342e256"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__geometry_8h.html#a8fbe3d578fe2ba147a7a6a0c7a3d8f85">GEOSContextHandle_t</a> OGRGeometry::createGEOSContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new GEOS context. </p>
<dl class="section return"><dt>Returns</dt><dd>a new GEOS context. </dd></dl>

</div>
</div>
<a class="anchor" id="ad5656df62f0857852519bea1486ab1ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRGeometry::Crosses </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test for crossing. </p>
<p>Tests if this geometry and the other passed into the method are crossing.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call <a class="el" href="classOGRGeometry.html#a7bbb194937466a6127b5436ac2ae99d9" title="Test if the geometry is valid. ">IsValid()</a> before, otherwise the result might be wrong.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a7af82e14406879c08841331b2a4cfe7c" title="Test for crossing. ">OGR_G_Crosses()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOtherGeom</td><td>the geometry to compare to this geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if they are crossing, otherwise FALSE. </dd></dl>

</div>
</div>
<a class="anchor" id="ab7d3c3e5b033ca6bbb470016e7661da7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::DelaunayTriangulation </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfTolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bOnlyEdges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a Delaunay triangulation of the vertices of the geometry. </p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#a8fff3faa236d12e0374f5c65f61972ae" title="Return a Delaunay triangulation of the vertices of the geometry. ">OGR_G_DelaunayTriangulation()</a>.</p>
<p>This function is built on the GEOS library, v3.4 or above. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfTolerance</td><td>optional snapping tolerance to use for improved robustness </td></tr>
    <tr><td class="paramname">bOnlyEdges</td><td>if TRUE, will return a MULTILINESTRING, otherwise it will return a GEOMETRYCOLLECTION containing triangular POLYGONs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the geometry resulting from the Delaunay triangulation or NULL if an error occurs.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 2.1 </dd></dl>

</div>
</div>
<a class="anchor" id="a817c860c39a7b2848f0ff2105faaa25a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::Difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute difference. </p>
<p>Generates a new geometry which is the region of this geometry with the region of the second geometry removed.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call <a class="el" href="classOGRGeometry.html#a7bbb194937466a6127b5436ac2ae99d9" title="Test if the geometry is valid. ">IsValid()</a> before, otherwise the result might be wrong.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a6e4a22abdb38514237f13828dc1a987f" title="Compute difference. ">OGR_G_Difference()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOtherGeom</td><td>the other geometry removed from "this" geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry representing the difference or NULL if the difference is empty or an error occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="a45f683761d57c8bea40e4ca1d832760a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRGeometry::Disjoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test for disjointness. </p>
<p>Tests if this geometry and the other passed into the method are disjoint.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call <a class="el" href="classOGRGeometry.html#a7bbb194937466a6127b5436ac2ae99d9" title="Test if the geometry is valid. ">IsValid()</a> before, otherwise the result might be wrong.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a7980d65f3d82d5a5442c5141efe3f503" title="Test for disjointness. ">OGR_G_Disjoint()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOtherGeom</td><td>the geometry to compare to this geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if they are disjoint, otherwise FALSE. </dd></dl>

</div>
</div>
<a class="anchor" id="a24fb51e9b419e97f14964e5a00ae3fb4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double OGRGeometry::Distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute distance between two geometries. </p>
<p>Returns the shortest distance between the two geometries. The distance is expressed into the same unit as the coordinates of the geometries.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ab01002a9fd4175832af965930f069401" title="Compute distance between two geometries. ">OGR_G_Distance()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOtherGeom</td><td>the other geometry to compare against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the distance between the geometries or -1 if an error occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="ad05627d890a50435c2c86db125de66a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double OGRGeometry::Distance3D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the 3D distance between two geometries. </p>
<p>The distance is expressed into the same unit as the coordinates of the geometries.</p>
<p>This method is built on the SFCGAL library, check it for the definition of the geometry operation. If OGR is built without the SFCGAL library, this method will always return -1.0</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#a7313a805a15bf78a26c52ff1bc6242e2" title="Returns the 3D distance between two geometries. ">OGR_G_Distance3D()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>distance between the two geometries </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2 </dd></dl>

</div>
</div>
<a class="anchor" id="a4e8a8e76722551bed49ae5418fc776a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::dumpReadable </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPrefix</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dump geometry in well known text format to indicated output file. </p>
<p>A few options can be defined to change the default dump : </p><ul>
<li>
DISPLAY_GEOMETRY=NO : to hide the dump of the geometry </li>
<li>
DISPLAY_GEOMETRY=WKT or YES (default) : dump the geometry as a WKT </li>
<li>
DISPLAY_GEOMETRY=SUMMARY : to get only a summary of the geometry </li>
</ul>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a3a99330bd108940f8a33036c0f83119f" title="Dump geometry in well known text format to indicated output file. ">OGR_G_DumpReadable()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>the text file to write the geometry to. </td></tr>
    <tr><td class="paramname">pszPrefix</td><td>the prefix to put on each line of output. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of options (may be NULL) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1702b5b8142abe761061a6cd44e50b05"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear geometry information. </p>
<p>This restores the geometry to its initial state after construction, and before assignment of actual geometry.</p>
<p>This method relates to the SFCOM IGeometry::Empty() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a90cc83b0a3052b8fbe2ed77a86323bf2" title="Clear geometry information. ">OGR_G_Empty()</a>. </p>

<p>Implemented in <a class="el" href="classOGRPolyhedralSurface.html#af86a1c685793d23f685d7893e1eb7703">OGRPolyhedralSurface</a>, <a class="el" href="classOGRGeometryCollection.html#a4182104d611a46942fcd36edba32c52e">OGRGeometryCollection</a>, <a class="el" href="classOGRCurvePolygon.html#a4f8b6b73430f36513a65d27f556e796d">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#a498b65455f48c2c15dfecd7cb65d4158">OGRCompoundCurve</a>, <a class="el" href="classOGRSimpleCurve.html#ab3e03f7f9094bb69be3d60233dd28353">OGRSimpleCurve</a>, and <a class="el" href="classOGRPoint.html#a51e977d29d7d2a063d2f8f046f61a519">OGRPoint</a>.</p>

</div>
</div>
<a class="anchor" id="a1b80c7f464de1d332215f16d35138590"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OGRGeometry::Equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns TRUE if two geometries are equivalent. </p>
<p>This operation implements the SQL/MM ST_OrderingEquals() operation.</p>
<p>The comparison is done in a structural way, that is to say that the geometry types must be identical, as well as the number and ordering of sub-geometries and vertices. Or equivalently, two geometries are considered equal by this method if their WKT/WKB representation is equal. Note: this must be distinguished for equality in a spatial way (which is the purpose of the ST_Equals() operation).</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#abaed0c4fb6f08abc280f91619e2e47d3" title="Returns TRUE if two geometries are equivalent. ">OGR_G_Equals()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if equivalent or FALSE otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classOGRPolyhedralSurface.html#a92e0592444ba2aa5077ad4dfe2ca6245">OGRPolyhedralSurface</a>, <a class="el" href="classOGRGeometryCollection.html#a6ab977bb05710b88a96e88dce5b8e834">OGRGeometryCollection</a>, <a class="el" href="classOGRCurvePolygon.html#a866bf18d2c0a73d1ced4ff982aee6c25">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#ac85c5a90238f59bb15c05427784d5903">OGRCompoundCurve</a>, <a class="el" href="classOGRSimpleCurve.html#ab048c1cf1d5903076d1e1e6d0d894cb2">OGRSimpleCurve</a>, and <a class="el" href="classOGRPoint.html#a3d4c93922bd9205df46cf6f448c3aab8">OGRPoint</a>.</p>

</div>
</div>
<a class="anchor" id="a2ea594db36b7281f73242273e22d62c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__geometry_8h.html#adc1d7838410d13f36b3fa41c17a1a57e">GEOSGeom</a> OGRGeometry::exportToGEOS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__geometry_8h.html#a8fbe3d578fe2ba147a7a6a0c7a3d8f85">GEOSContextHandle_t</a>&#160;</td>
          <td class="paramname"><em>hGEOSCtxt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a GEOSGeom object corresponding to the geometry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGEOSCtxt</td><td>GEOS context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a GEOSGeom object corresponding to the geometry. </dd></dl>

</div>
</div>
<a class="anchor" id="a56ced443fbccb280290c107e7b69fb8f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * OGRGeometry::exportToGML </td>
          <td>(</td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a geometry into GML format. </p>
<p>The GML geometry is expressed directly in terms of GML basic data types assuming the this is available in the gml namespace. The returned string should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree() ">CPLFree()</a> when no longer required.</p>
<p>The supported options in OGR 1.8.0 are : </p><ul>
<li>
FORMAT=GML3. Otherwise it will default to GML 2.1.2 output. </li>
<li>
GML3_LINESTRING_ELEMENT=curve. (Only valid for FORMAT=GML3) To use gml:Curve element for linestrings. Otherwise gml:LineString will be used . </li>
<li>
GML3_LONGSRS=YES/NO. (Only valid for FORMAT=GML3) Default to YES. If YES, SRS with EPSG authority will be written with the "urn:ogc:def:crs:EPSG::" prefix. In the case, if the SRS is a geographic SRS without explicit AXIS order, but that the same SRS authority code imported with ImportFromEPSGA() should be treated as lat/long, then the function will take care of coordinate order swapping. If set to NO, SRS with EPSG authority will be written with the "EPSG:" prefix, even if they are in lat/long order. </li>
</ul>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ab95226e12c2de1cdd2837c1ca15366fd" title="Convert a geometry into GML format. ">OGR_G_ExportToGMLEx()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszOptions</td><td>NULL-terminated list of options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GML fragment or NULL in case of error. </dd></dl>

</div>
</div>
<a class="anchor" id="a28609fce6bd422b16182eab58ff4e812"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * OGRGeometry::exportToJson </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a geometry into GeoJSON format. </p>
<p>The returned string should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree() ">CPLFree()</a> when no longer required.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#aaf6d95725bd9fdb110b42d3c2749dd38" title="Convert a geometry into GeoJSON format. ">OGR_G_ExportToJson()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A GeoJSON fragment or NULL in case of error. </dd></dl>

</div>
</div>
<a class="anchor" id="a579b67f04630b791a229b6a7c2914640"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * OGRGeometry::exportToKML </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a geometry into KML format. </p>
<p>The returned string should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree() ">CPLFree()</a> when no longer required.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a5a2d35d3f6f10b4ca936a40a76d70d20" title="Convert a geometry into KML format. ">OGR_G_ExportToKML()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A KML fragment or NULL in case of error. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a3ad2f9b55285be500ca6ac5dc75d1d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRGeometry::exportToWkb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a36cc1f4d807ba8f6fb8951f3adf251e2">OGRwkbByteOrder</a>&#160;</td>
          <td class="paramname"><em>eByteOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>pabyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6">OGRwkbVariant</a>&#160;</td>
          <td class="paramname"><em>eWkbVariant</em> = <code><a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6a7459e8d11fa69e89271771c8d0f265d8">wkbVariantOldOgc</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a geometry into well known binary format. </p>
<p>This method relates to the SFCOM IWks::ExportToWKB() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ad5c94ae76c09774dba8725c24daeefd6" title="Convert a geometry well known binary format. ">OGR_G_ExportToWkb()</a> or <a class="el" href="ogr__api_8h.html#a622a18776e6d51515d0f2ff0ee211d91" title="Convert a geometry into SFSQL 1.2 / ISO SQL/MM Part 3 well known binary format. ">OGR_G_ExportToIsoWkb()</a>, depending on the value of eWkbVariant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eByteOrder</td><td>One of wkbXDR or wkbNDR indicating MSB or LSB byte order respectively. </td></tr>
    <tr><td class="paramname">pabyData</td><td>a buffer into which the binary representation is written. This buffer must be at least <a class="el" href="classOGRGeometry.html#acd1a8164dae2e44e50990756ed6b8b4a" title="Returns size of related binary representation. ">OGRGeometry::WkbSize()</a> byte in size. </td></tr>
    <tr><td class="paramname">eWkbVariant</td><td>What standard to use when exporting geometries with three dimensions (or more). The default wkbVariantOldOgc is the historical OGR variant. wkbVariantIso is the variant defined in ISO SQL/MM and adopted by OGC for SFSQL 1.2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Currently OGRERR_NONE is always returned. </dd></dl>

<p>Implemented in <a class="el" href="classOGRPolyhedralSurface.html#a1c4f6fb663a9bf9b8b21d93556f11356">OGRPolyhedralSurface</a>, <a class="el" href="classOGRGeometryCollection.html#ad3ad84274745e728c0794516fa7d52d6">OGRGeometryCollection</a>, <a class="el" href="classOGRPolygon.html#a9a3aba4fe2f6ecdf6a30db8fa02d2c55">OGRPolygon</a>, <a class="el" href="classOGRCurvePolygon.html#a09e7033628e3bcb7f4444ed06a63503c">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#ae073bc7e765f1cea394f5a281b565db9">OGRCompoundCurve</a>, <a class="el" href="classOGRCircularString.html#ac53cee1bcdee85964a1c20fb52b46772">OGRCircularString</a>, <a class="el" href="classOGRLinearRing.html#a1e3df2319c1bd4827b0bf8387c6261de">OGRLinearRing</a>, <a class="el" href="classOGRSimpleCurve.html#a23eb6bc5cea8f7f6fa3d8441ebdc3394">OGRSimpleCurve</a>, and <a class="el" href="classOGRPoint.html#a028e0e4199e722a311101c3454931378">OGRPoint</a>.</p>

</div>
</div>
<a class="anchor" id="afb6ea9cf7a5e940b6e00b2b4c6066e4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRGeometry::exportToWkt </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppszDstText</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6">OGRwkbVariant</a>&#160;</td>
          <td class="paramname"><em>eWkbVariant</em> = <code><a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6a7459e8d11fa69e89271771c8d0f265d8">wkbVariantOldOgc</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a geometry into well known text format. </p>
<p>This method relates to the SFCOM IWks::ExportToWKT() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a3bc9310302e2dbfaab1690de9e2fd2fb" title="Convert a geometry into well known text format. ">OGR_G_ExportToWkt()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppszDstText</td><td>a text buffer is allocated by the program, and assigned to the passed pointer. After use, *ppszDstText should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree() ">CPLFree()</a>. </td></tr>
    <tr><td class="paramname">eWkbVariant</td><td>the specification that must be conformed too :<ul>
<li>wbkVariantOgc for old-style 99-402 extended dimension (Z) WKB types</li>
<li>wbkVariantIso for SFSQL 1.2 and ISO SQL/MM Part 3</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Currently OGRERR_NONE is always returned. </dd></dl>

<p>Implemented in <a class="el" href="classOGRMultiLineString.html#acfc5bb44cb0cf211b27088738edec88b">OGRMultiLineString</a>, <a class="el" href="classOGRMultiCurve.html#ab4487c01f963edab0046a8f1a51e61f0">OGRMultiCurve</a>, <a class="el" href="classOGRMultiPoint.html#a586e5b912f086d0633280231ba0ac871">OGRMultiPoint</a>, <a class="el" href="classOGRPolyhedralSurface.html#a445927db98640d5f49b2e7de079f7b52">OGRPolyhedralSurface</a>, <a class="el" href="classOGRMultiPolygon.html#a02a648d504ef7e7577617ceef78054f2">OGRMultiPolygon</a>, <a class="el" href="classOGRMultiSurface.html#a68019964f1dbad557a7fa6a5fc1fb5fe">OGRMultiSurface</a>, <a class="el" href="classOGRGeometryCollection.html#a5dc0b6fd9bb066a7b148bcf5e350747a">OGRGeometryCollection</a>, <a class="el" href="classOGRPolygon.html#a43dd813c7a447d5d04832c8c4c011e0b">OGRPolygon</a>, <a class="el" href="classOGRCurvePolygon.html#aff8a3553fe672b9c20b6b3178807e449">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#a86e1a3e066fc49fc790e6d5415b639bb">OGRCompoundCurve</a>, <a class="el" href="classOGRCircularString.html#a7e834e6ef19caae5293d2fc7fbee93d9">OGRCircularString</a>, <a class="el" href="classOGRSimpleCurve.html#a5c03629cd94aaac25327a468613b4d04">OGRSimpleCurve</a>, and <a class="el" href="classOGRPoint.html#a7ab7fd857f7027d4ca263260c4156aec">OGRPoint</a>.</p>

</div>
</div>
<a class="anchor" id="aaae1a2ced937a5900b2bfeb717bad6c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::flattenTo2D </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert geometry to strictly 2D. </p>
<p>In a sense this converts all Z coordinates to 0.0.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#afdb7354b55c7448b60b44cd9e36073b8" title="Convert geometry to strictly 2D. ">OGR_G_FlattenTo2D()</a>. </p>

<p>Implemented in <a class="el" href="classOGRPolyhedralSurface.html#a5eabebeefe1ce008a24d1fd97da59547">OGRPolyhedralSurface</a>, <a class="el" href="classOGRGeometryCollection.html#aec6c186d031be3085e5de02fd176ce5b">OGRGeometryCollection</a>, <a class="el" href="classOGRCurvePolygon.html#a42e2b4087c482df97a2cb8ba6d9eb7c1">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#a9334ab5ea081f810a6fa50ffb4ac4308">OGRCompoundCurve</a>, <a class="el" href="classOGRSimpleCurve.html#a67a63edcc3290d3c60a83ede1c995624">OGRSimpleCurve</a>, and <a class="el" href="classOGRPoint.html#a9b2ab4bcbeb865be20d80d01f39c99cc">OGRPoint</a>.</p>

</div>
</div>
<a class="anchor" id="a050eca02b140070855dff24bc5b18800"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::freeGEOSContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__geometry_8h.html#a8fbe3d578fe2ba147a7a6a0c7a3d8f85">GEOSContextHandle_t</a>&#160;</td>
          <td class="paramname"><em>hGEOSCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy a GEOS context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGEOSCtxt</td><td>GEOS context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abaf3407a6fa0e90e4625b023e9ef17c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classOGRGeometry.html">OGRGeometry</a>* OGRGeometry::FromHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a OGRGeometryH to a OGRGeometry*. </p>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a2a93f43a3b66462195b46f7fd2196dfc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OGRGeometry::getCoordinateDimension </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the dimension of the coordinates in this object. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a8a5e78b0753339d1cdd282b0e151d28f" title="Get the dimension of the coordinates in this geometry. ">OGR_G_GetCoordinateDimension()</a>.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000010">Deprecated:</a></b></dt><dd>use <a class="el" href="classOGRGeometry.html#a9b1cead13e95b28a78261fee3b1cebb3" title="Get the dimension of the coordinates in this object. ">CoordinateDimension()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>this will return 2 or 3. </dd></dl>

</div>
</div>
<a class="anchor" id="a49749581ed7c99f9923029333f7c834c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::getCurveGeometry </td>
          <td>(</td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return curve version of this geometry. </p>
<p>Returns a geometry that has possibly CIRCULARSTRING, COMPOUNDCURVE, CURVEPOLYGON, MULTICURVE or MULTISURFACE in it, by de-approximating curve geometries.</p>
<p>If the geometry has no curve portion, the returned geometry will be a clone of it.</p>
<p>The ownership of the returned geometry belongs to the caller.</p>
<p>The reverse method is <a class="el" href="classOGRGeometry.html#ac13fa59ae1a0d46070e05d8007bd295e" title="Return, possibly approximate, non-curve version of this geometry. ">OGRGeometry::getLinearGeometry()</a>.</p>
<p>This function is the same as C function <a class="el" href="ogr__api_8h.html#a4989d5287899041d70f4176d41ceeac2" title="Return curve version of this geometry. ">OGR_G_GetCurveGeometry()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszOptions</td><td>options as a null-terminated list of strings. Unused for now. Must be set to NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRGeometryCollection.html#a25a7ee787f1e660014a5ffa69a94f28e">OGRGeometryCollection</a>, <a class="el" href="classOGRPolygon.html#af35b73e64c9b296afa0685575d6e524f">OGRPolygon</a>, and <a class="el" href="classOGRLineString.html#ab9eab58c0487fcc49c1595e99c881d26">OGRLineString</a>.</p>

</div>
</div>
<a class="anchor" id="aadca09471fa9917452e087ba12d73eeb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OGRGeometry::getDimension </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the dimension of this object. </p>
<p>This method corresponds to the SFCOM IGeometry::GetDimension() method. It indicates the dimension of the object, but does not indicate the dimension of the underlying space (as indicated by <a class="el" href="classOGRGeometry.html#a2a93f43a3b66462195b46f7fd2196dfc" title="Get the dimension of the coordinates in this object. ">OGRGeometry::getCoordinateDimension()</a>).</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a94b633e1acd208c258ad49f8d4fd4104" title="Get the dimension of this geometry. ">OGR_G_GetDimension()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>0 for points, 1 for lines and 2 for surfaces. </dd></dl>

<p>Implemented in <a class="el" href="classOGRMultiCurve.html#a157d866ed088a1117d4cbf3ae936411b">OGRMultiCurve</a>, <a class="el" href="classOGRMultiPoint.html#a0a548602fbedd21eb73c81060a3cb712">OGRMultiPoint</a>, <a class="el" href="classOGRPolyhedralSurface.html#af720cbe418e362ca4753703101a7f952">OGRPolyhedralSurface</a>, <a class="el" href="classOGRMultiSurface.html#a734dcb7f0fafb018b002eee1ea6461eb">OGRMultiSurface</a>, <a class="el" href="classOGRGeometryCollection.html#ad5524a5f6c61218c42b8aac4cbb2075d">OGRGeometryCollection</a>, <a class="el" href="classOGRCurvePolygon.html#a6cfab51e053c687ad39244c08ea298a7">OGRCurvePolygon</a>, <a class="el" href="classOGRCurve.html#a0d1abb0177b55c0ef8320832e5096101">OGRCurve</a>, and <a class="el" href="classOGRPoint.html#a4dcc80993a6e8556da4128c53a3ed7fe">OGRPoint</a>.</p>

</div>
</div>
<a class="anchor" id="aa3d42b06ae6f7bbef6d1a2886da8d398"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::getEnvelope </td>
          <td>(</td>
          <td class="paramtype">OGREnvelope *&#160;</td>
          <td class="paramname"><em>psEnvelope</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a617a9c9ea85157661619a1d8f0a69cf9" title="Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure...">OGR_G_GetEnvelope()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psEnvelope</td><td>the structure in which to place the results. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classOGRPolyhedralSurface.html#a5ba7de77775dd7e782811b8421958faf">OGRPolyhedralSurface</a>, <a class="el" href="classOGRGeometryCollection.html#a88d5e2e936a95b8c866ef36aea57b402">OGRGeometryCollection</a>, <a class="el" href="classOGRCurvePolygon.html#a5c37b416860a3fd2b2aaf471ffd9ad69">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#ac651de749818c615ef3be71fc9ab2383">OGRCompoundCurve</a>, <a class="el" href="classOGRCircularString.html#a9ed8ac2d4d3283866caf0ca2c57d69c3">OGRCircularString</a>, <a class="el" href="classOGRSimpleCurve.html#a8bf6dd6fb48dd2c05ab23cd2c9474a1d">OGRSimpleCurve</a>, and <a class="el" href="classOGRPoint.html#ad265a468bc28d774e70b648c4e8001df">OGRPoint</a>.</p>

</div>
</div>
<a class="anchor" id="a3926892dbde299ffd652ee109b5967c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::getEnvelope </td>
          <td>(</td>
          <td class="paramtype">OGREnvelope3D *&#160;</td>
          <td class="paramname"><em>psEnvelope</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes and returns the bounding envelope (3D) for this geometry in the passed psEnvelope structure. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a9a950633ac824042b0afdb88c670c5ce" title="Computes and returns the bounding envelope (3D) for this geometry in the passed psEnvelope structure...">OGR_G_GetEnvelope3D()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psEnvelope</td><td>the structure in which to place the results.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

<p>Implemented in <a class="el" href="classOGRPolyhedralSurface.html#af29c8434458527b796847804fa2b5d61">OGRPolyhedralSurface</a>, <a class="el" href="classOGRGeometryCollection.html#a8ef6f62e0446c66ea4874a4bbcbf8d35">OGRGeometryCollection</a>, <a class="el" href="classOGRCurvePolygon.html#a46fa4514aead52995de7aee70a6b8bb3">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#a14ca542873325ac5737b9ee7f232c651">OGRCompoundCurve</a>, <a class="el" href="classOGRCircularString.html#a42fd0f525d83caa5968cce77b1105e48">OGRCircularString</a>, <a class="el" href="classOGRSimpleCurve.html#a899397ea5545f3c8e306c30d2adf9ccb">OGRSimpleCurve</a>, and <a class="el" href="classOGRPoint.html#aeccd80f6034d2ae786f44a78991ac314">OGRPoint</a>.</p>

</div>
</div>
<a class="anchor" id="aba109e1c53ce1452942f85eae66d88b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * OGRGeometry::getGeometryName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch WKT name for geometry type. </p>
<p>There is no SFCOM analog to this method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a18121f835b2fb724a0c1a87beb1a437a" title="Fetch WKT name for geometry type. ">OGR_G_GetGeometryName()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>name used for this geometry type in well known text format. The returned pointer is to a static internal string and should not be modified or freed. </dd></dl>

<p>Implemented in <a class="el" href="classOGRMultiLineString.html#a97027c7c97c031cc858170d2ae851ca8">OGRMultiLineString</a>, <a class="el" href="classOGRMultiCurve.html#a5dd73ff324e0c25402e64db11e3b192a">OGRMultiCurve</a>, <a class="el" href="classOGRMultiPoint.html#a95172676d264da6bd7453d3196d54fac">OGRMultiPoint</a>, <a class="el" href="classOGRTriangulatedSurface.html#a156c11aa645cb91ce5c74b5338e67b82">OGRTriangulatedSurface</a>, <a class="el" href="classOGRPolyhedralSurface.html#aa1c960495b0a4851b27a08b2b539bb2d">OGRPolyhedralSurface</a>, <a class="el" href="classOGRMultiPolygon.html#a1040d86861577dbe80a68b7cabcd0a1d">OGRMultiPolygon</a>, <a class="el" href="classOGRMultiSurface.html#aa2cc2f5a5d7f69979d23a86dfe8ceeef">OGRMultiSurface</a>, <a class="el" href="classOGRGeometryCollection.html#a53eb7b3785dbc4cb79893756d140de1e">OGRGeometryCollection</a>, <a class="el" href="classOGRTriangle.html#af85e6b2097861cc92f74678acfb341f0">OGRTriangle</a>, <a class="el" href="classOGRPolygon.html#a70ab4a9518743c87ab7d36b731fce530">OGRPolygon</a>, <a class="el" href="classOGRCurvePolygon.html#a657a572a4c14c429f6729b22f813a0b8">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#af234b900eac034fa6cb224859ef81f6e">OGRCompoundCurve</a>, <a class="el" href="classOGRCircularString.html#ac6fd941ff17e4a583c1744cd12fcc1e8">OGRCircularString</a>, <a class="el" href="classOGRLinearRing.html#a7ea2cff1b5a9f37ee137fd6ac36cc498">OGRLinearRing</a>, <a class="el" href="classOGRLineString.html#a33b8f9ab541e0a083f0a597852be1db5">OGRLineString</a>, and <a class="el" href="classOGRPoint.html#ab179d07fae1da649afd568f465c9476e">OGRPoint</a>.</p>

</div>
</div>
<a class="anchor" id="a5c6bca18682cb933e3227552d480e1a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a> OGRGeometry::getGeometryType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch geometry type. </p>
<p>Note that the geometry type may include the 2.5D flag. To get a 2D flattened version of the geometry type apply the <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type. ">wkbFlatten()</a> macro to the return result.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a8fae58102f5c4a4cf2526e5ca8369a76" title="Fetch geometry type. ">OGR_G_GetGeometryType()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the geometry type code. </dd></dl>

<p>Implemented in <a class="el" href="classOGRMultiLineString.html#a33043ad4b8c6e79b8c8bbdfbb25be8b7">OGRMultiLineString</a>, <a class="el" href="classOGRMultiCurve.html#a5005ce01767bccf7a4de7de175ec6c27">OGRMultiCurve</a>, <a class="el" href="classOGRMultiPoint.html#a9c162729b796f8d2af528f12a6fd6e95">OGRMultiPoint</a>, <a class="el" href="classOGRTriangulatedSurface.html#a1aba9929118409503d72ca9e6ac03a7f">OGRTriangulatedSurface</a>, <a class="el" href="classOGRPolyhedralSurface.html#a8e00dff027b039688b6097d7700edd69">OGRPolyhedralSurface</a>, <a class="el" href="classOGRMultiPolygon.html#aadf1464a49e1ad2dc35a08184e58ca5e">OGRMultiPolygon</a>, <a class="el" href="classOGRMultiSurface.html#aedfcb9f739896250129f7020fc5678ef">OGRMultiSurface</a>, <a class="el" href="classOGRGeometryCollection.html#ac5f92c525b0569a971c5d47bc0f9f1c1">OGRGeometryCollection</a>, <a class="el" href="classOGRTriangle.html#a48b5fd19cbd9e93e4961a46660bb8181">OGRTriangle</a>, <a class="el" href="classOGRPolygon.html#a5f1316ac915dad438b599c825b8c0068">OGRPolygon</a>, <a class="el" href="classOGRCurvePolygon.html#a9a1a2d708cdf852785a66417f9889bfc">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#af0c737a27f323cf7fdd92c62c973d9dc">OGRCompoundCurve</a>, <a class="el" href="classOGRCircularString.html#a95883a6e918b8b07b2dac0a10c589f65">OGRCircularString</a>, <a class="el" href="classOGRLineString.html#aabbfb9f0024b1def22428d68d3b88d00">OGRLineString</a>, and <a class="el" href="classOGRPoint.html#a9545758cbbf6ae93548f19851fd0f594">OGRPoint</a>.</p>

</div>
</div>
<a class="anchor" id="a87f471b43d61e19334618df4929833e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a> OGRGeometry::getIsoGeometryType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the geometry type that conforms with ISO SQL/MM Part3. </p>
<dl class="section return"><dt>Returns</dt><dd>the geometry type that conforms with ISO SQL/MM Part3 </dd></dl>

</div>
</div>
<a class="anchor" id="ac13fa59ae1a0d46070e05d8007bd295e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::getLinearGeometry </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMaxAngleStepSizeDegrees</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return, possibly approximate, non-curve version of this geometry. </p>
<p>Returns a geometry that has no CIRCULARSTRING, COMPOUNDCURVE, CURVEPOLYGON, MULTICURVE or MULTISURFACE in it, by approximating curve geometries.</p>
<p>The ownership of the returned geometry belongs to the caller.</p>
<p>The reverse method is <a class="el" href="classOGRGeometry.html#a49749581ed7c99f9923029333f7c834c" title="Return curve version of this geometry. ">OGRGeometry::getCurveGeometry()</a>.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a6bd069f8338954fc8a6215594a37a8db" title="Return, possibly approximate, linear version of this geometry. ">OGR_G_GetLinearGeometry()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfMaxAngleStepSizeDegrees</td><td>the largest step in degrees along the arc, zero to use the default setting. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>options as a null-terminated list of strings. See <a class="el" href="classOGRGeometryFactory.html#a6f661d6691fcf745ca185ae4d586156c" title="Converts an arc circle into an approximate line string. ">OGRGeometryFactory::curveToLineString()</a> for valid options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRGeometryCollection.html#aa4ac63e76ac14460bb5f883208deaed7">OGRGeometryCollection</a>, <a class="el" href="classOGRPolygon.html#a19479ddee1f05fe4d6b4ae9f52cbfb71">OGRPolygon</a>, <a class="el" href="classOGRCurvePolygon.html#a10c3cdd9accf2547e975ddb78558e9b4">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#a1fbf857d7dc61def6aafaf42dc45f118">OGRCompoundCurve</a>, and <a class="el" href="classOGRCircularString.html#ae4dbce1e06fa7f072902fcc2594428d0">OGRCircularString</a>.</p>

</div>
</div>
<a class="anchor" id="a194f0bbdae896539852106cafbffbe87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> * OGRGeometry::getSpatialReference </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns spatial reference system for object. </p>
<p>This method relates to the SFCOM IGeometry::get_SpatialReference() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#abc393e40282eec3801fb4a4abc9e25bf" title="Returns spatial reference system for geometry. ">OGR_G_GetSpatialReference()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the spatial reference object. The object may be shared with many geometry objects, and should not be modified. </dd></dl>

</div>
</div>
<a class="anchor" id="a6c0148448ea32534a351bcf1c5c88922"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRGeometry::hasCurveGeometry </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bLookForNonLinear</em> = <code>FALSE</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if this geometry is or has curve geometry. </p>
<p>Returns if a geometry is, contains or may contain a CIRCULARSTRING, COMPOUNDCURVE, CURVEPOLYGON, MULTICURVE or MULTISURFACE.</p>
<p>If bLookForNonLinear is set to TRUE, it will be actually looked if the geometry or its subgeometries are or contain a non-linear geometry in them. In which case, if the method returns TRUE, it means that <a class="el" href="classOGRGeometry.html#ac13fa59ae1a0d46070e05d8007bd295e" title="Return, possibly approximate, non-curve version of this geometry. ">getLinearGeometry()</a> would return an approximate version of the geometry. Otherwise, <a class="el" href="classOGRGeometry.html#ac13fa59ae1a0d46070e05d8007bd295e" title="Return, possibly approximate, non-curve version of this geometry. ">getLinearGeometry()</a> would do a conversion, but with just converting container type, like COMPOUNDCURVE -&gt; LINESTRING, MULTICURVE -&gt; MULTILINESTRING or MULTISURFACE -&gt; MULTIPOLYGON, resulting in a "loss-less" conversion.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#af4f8e7d05f06a1fe69ea9638085e5e26" title="Returns if this geometry is or has curve geometry. ">OGR_G_HasCurveGeometry()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bLookForNonLinear</td><td>set it to TRUE to check if the geometry is or contains a CIRCULARSTRING.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if this geometry is or has curve geometry.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRMultiLineString.html#a678746170012f8bb9a06edaa8b913f19">OGRMultiLineString</a>, <a class="el" href="classOGRMultiCurve.html#a487d0d04e3fa4adabfbd2015c67a1dc5">OGRMultiCurve</a>, <a class="el" href="classOGRMultiPoint.html#adae8036c3438d18714a9da1f01b0d8dd">OGRMultiPoint</a>, <a class="el" href="classOGRPolyhedralSurface.html#a7cb0d5b6c4772cd8ead5582c9f2ac117">OGRPolyhedralSurface</a>, <a class="el" href="classOGRMultiPolygon.html#a1bbc86aef701032ea2e4817d0a7c55aa">OGRMultiPolygon</a>, <a class="el" href="classOGRMultiSurface.html#af552b59005624d9cfbd77f9731f75ea0">OGRMultiSurface</a>, <a class="el" href="classOGRGeometryCollection.html#affd13afe6b29f1bca6823f88aadaffe0">OGRGeometryCollection</a>, <a class="el" href="classOGRPolygon.html#a473e648dc1d29d9776811b27ad53b7a2">OGRPolygon</a>, <a class="el" href="classOGRCurvePolygon.html#af3e3b31c4b80544151852e825f3f555c">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#ae3514beab03dc72a2a551218d6e52491">OGRCompoundCurve</a>, and <a class="el" href="classOGRCircularString.html#afb4ef3593c52575d22dcef4bd7166e49">OGRCircularString</a>.</p>

</div>
</div>
<a class="anchor" id="a0e604e7393db0dd511b458f3ecd0b819"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRGeometry::importFromWkb </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a> *&#160;</td>
          <td class="paramname"><em>pabyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nSize</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6">OGRwkbVariant</a>&#160;</td>
          <td class="paramname"><em>eWkbVariant</em> = <code><a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6a7459e8d11fa69e89271771c8d0f265d8">wkbVariantOldOgc</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign geometry from well known binary data. </p>
<p>The object must have already been instantiated as the correct derived type of geometry object to match the binaries type. This method is used by the <a class="el" href="classOGRGeometryFactory.html" title="Create geometry objects from well known text/binary. ">OGRGeometryFactory</a> class, but not normally called by application code.</p>
<p>This method relates to the SFCOM IWks::ImportFromWKB() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ae523fe14c8c87dffcee706438ec2e81f" title="Assign geometry from well known binary data. ">OGR_G_ImportFromWkb()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pabyData</td><td>the binary input data. </td></tr>
    <tr><td class="paramname">nSize</td><td>the size of pabyData in bytes, or -1 if not known. </td></tr>
    <tr><td class="paramname">eWkbVariant</td><td>if wkbVariantPostGIS1, special interpretation is done for curve geometries code</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a487b3eec4526421c8c192741d933bfc1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRGeometry::importFromWkb </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>pabyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6">OGRwkbVariant</a>&#160;</td>
          <td class="paramname"><em>eWkbVariant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nBytesConsumedOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign geometry from well known binary data. </p>
<p>The object must have already been instantiated as the correct derived type of geometry object to match the binaries type. This method is used by the <a class="el" href="classOGRGeometryFactory.html" title="Create geometry objects from well known text/binary. ">OGRGeometryFactory</a> class, but not normally called by application code.</p>
<p>This method relates to the SFCOM IWks::ImportFromWKB() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ae523fe14c8c87dffcee706438ec2e81f" title="Assign geometry from well known binary data. ">OGR_G_ImportFromWkb()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pabyData</td><td>the binary input data. </td></tr>
    <tr><td class="paramname">nSize</td><td>the size of pabyData in bytes, or -1 if not known. </td></tr>
    <tr><td class="paramname">eWkbVariant</td><td>if wkbVariantPostGIS1, special interpretation is done for curve geometries code </td></tr>
    <tr><td class="paramname">nBytesConsumedOut</td><td>output parameter. Number of bytes consumed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

<p>Implemented in <a class="el" href="classOGRPolyhedralSurface.html#a8172aeee12caddafc2c5ca0b5d255f86">OGRPolyhedralSurface</a>, <a class="el" href="classOGRGeometryCollection.html#a7b36de805041210a9aeaa16132383ed0">OGRGeometryCollection</a>, <a class="el" href="classOGRTriangle.html#a276c9d061680167a05bca7c3a248b9cf">OGRTriangle</a>, <a class="el" href="classOGRPolygon.html#a45e3afd06a1a98fffd7bb03ee5a50dda">OGRPolygon</a>, <a class="el" href="classOGRCurvePolygon.html#a8a2543bbce4f827155b661765b4c13a6">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#a7a9dde2abe74f0a48ef6b65ff0926cb8">OGRCompoundCurve</a>, <a class="el" href="classOGRCircularString.html#a4058a7d9e8a65c4326bbfa3610185004">OGRCircularString</a>, <a class="el" href="classOGRLinearRing.html#a6af6a993fd4786225ad713956725d2b4">OGRLinearRing</a>, <a class="el" href="classOGRSimpleCurve.html#a9d27af37e55e80a845620e7b751de4c7">OGRSimpleCurve</a>, and <a class="el" href="classOGRPoint.html#a62c51c2c09f6ea01ff23e381e1a1b18a">OGRPoint</a>.</p>

</div>
</div>
<a class="anchor" id="af1bb0f7cae630c31511766718bcc5b66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRGeometry::importFromWkt </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>ppszInput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign geometry from well known text data. </p>
<p>The object must have already been instantiated as the correct derived type of geometry object to match the text type. This method is used by the <a class="el" href="classOGRGeometryFactory.html" title="Create geometry objects from well known text/binary. ">OGRGeometryFactory</a> class, but not normally called by application code.</p>
<p>This method relates to the SFCOM IWks::ImportFromWKT() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a4286ba243fb05a831a49f52aabcbc6f8" title="Assign geometry from well known text data. ">OGR_G_ImportFromWkt()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppszInput</td><td>pointer to a pointer to the source text. The pointer is updated to pointer after the consumed text.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned. </dd></dl>

<p>Implemented in <a class="el" href="classOGRMultiCurve.html#a6f58ca204d4882bb2bbc0c8e7cdb7dee">OGRMultiCurve</a>, <a class="el" href="classOGRMultiPoint.html#ac4151d5a2b0fa6879007ffc9496ba9cd">OGRMultiPoint</a>, <a class="el" href="classOGRPolyhedralSurface.html#a8ccd8d83db6335228e3aa4ae7fbf9b37">OGRPolyhedralSurface</a>, <a class="el" href="classOGRMultiSurface.html#a809baf6868016dfe4efdcd9f7a13b42f">OGRMultiSurface</a>, <a class="el" href="classOGRGeometryCollection.html#aa151b02502d60eb5d9a2eaa7a68fde63">OGRGeometryCollection</a>, <a class="el" href="classOGRPolygon.html#a7e59ca06b3f87c688d4ad4ff3b31fd24">OGRPolygon</a>, <a class="el" href="classOGRCurvePolygon.html#a154a45e780861e77d1a17520c08a527d">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#ab44a873bdf7e9adfa5ae19a7578893a1">OGRCompoundCurve</a>, <a class="el" href="classOGRCircularString.html#ad03352f887b09040332ff1c17e87dcb3">OGRCircularString</a>, <a class="el" href="classOGRSimpleCurve.html#a35279777e9d344683e8521fefa4b674e">OGRSimpleCurve</a>, and <a class="el" href="classOGRPoint.html#a280e5260440a81ff8374f7d14c99f4ab">OGRPoint</a>.</p>

</div>
</div>
<a class="anchor" id="aabf780889ff2bd04fda67e4a70d88b40"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRGeometry::importFromWkt </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppszInput</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd>in GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a83adb426e79958c90aecb418d91c765c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::Intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute intersection. </p>
<p>Generates a new geometry which is the region of intersection of the two geometries operated on. The <a class="el" href="classOGRGeometry.html#aadb34b556c52aef3e93f03cf65d3f4bc" title="Do these features intersect? ">Intersects()</a> method can be used to test if two geometries intersect.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call <a class="el" href="classOGRGeometry.html#a7bbb194937466a6127b5436ac2ae99d9" title="Test if the geometry is valid. ">IsValid()</a> before, otherwise the result might be wrong.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a96d73915584c997f9bd79c8940379578" title="Compute intersection. ">OGR_G_Intersection()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOtherGeom</td><td>the other geometry intersected with "this" geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry representing the intersection or NULL if there is no intersection or an error occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="aadb34b556c52aef3e93f03cf65d3f4bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRGeometry::Intersects </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do these features intersect? </p>
<p>Determines whether two geometries intersect. If GEOS is enabled, then this is done in rigorous fashion otherwise TRUE is returned if the envelopes (bounding boxes) of the two geometries overlap.</p>
<p>The poOtherGeom argument may be safely NULL, but in this case the method will always return TRUE. That is, a NULL geometry is treated as being everywhere.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#acaed6926b75cd33a42b284c10def6e87" title="Do these features intersect? ">OGR_G_Intersects()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOtherGeom</td><td>the other geometry to test against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the geometries intersect, otherwise FALSE. </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRCurvePolygon.html#a78ec798e8a8918c0bf71edceff9765da">OGRCurvePolygon</a>, and <a class="el" href="classOGRPoint.html#ae732577a0dbaccb0aafe03caf49b65dd">OGRPoint</a>.</p>

</div>
</div>
<a class="anchor" id="a395b0a9b471f8ecabe5aa35af2ff5e03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRGeometry::Is3D </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether the geometry has a Z component. </p>

</div>
</div>
<a class="anchor" id="ac8653ba97e53f3e3b041946ca2acc111"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRGeometry::IsEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns TRUE (non-zero) if the object has no points. </p>
<p>Normally this returns FALSE except between when an object is instantiated and points have been assigned.</p>
<p>This method relates to the SFCOM IGeometry::IsEmpty() method.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if object is empty, otherwise FALSE. </dd></dl>

<p>Implemented in <a class="el" href="classOGRPolyhedralSurface.html#a2282450711465eed4f559d0fb29f72f8">OGRPolyhedralSurface</a>, <a class="el" href="classOGRGeometryCollection.html#a909d9a27284d3e1f32b5d17bd34568ef">OGRGeometryCollection</a>, <a class="el" href="classOGRCurvePolygon.html#aa659e9d7d87da1ae552a69a7fc5508f9">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#af8f2d0c97340ab615dd2424d3b03e1eb">OGRCompoundCurve</a>, <a class="el" href="classOGRSimpleCurve.html#afec30fb77311843160528536ab9bd3a3">OGRSimpleCurve</a>, and <a class="el" href="classOGRPoint.html#abc9e91d93d4707bc0fa25754bb70d583">OGRPoint</a>.</p>

</div>
</div>
<a class="anchor" id="a59e20b5932408fa59004e4a7e1105475"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRGeometry::IsMeasured </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether the geometry has a M component. </p>

</div>
</div>
<a class="anchor" id="ad15ffdcae4351112b3106d4f87b2a3bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRGeometry::IsRing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if the geometry is a ring. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ab9e99b4792042aca861866cb29bdf826" title="Test if the geometry is a ring. ">OGR_G_IsRing()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always return FALSE.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the geometry has no points, otherwise FALSE. </dd></dl>

</div>
</div>
<a class="anchor" id="ab72b0c5c673d8b1cf6f870fabbeffe26"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRGeometry::IsSimple </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if the geometry is simple. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a3cb66472d7e302d16aacf0d66c01ac73" title="Returns TRUE if the geometry is simple. ">OGR_G_IsSimple()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always return FALSE.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the geometry has no points, otherwise FALSE. </dd></dl>

</div>
</div>
<a class="anchor" id="a7bbb194937466a6127b5436ac2ae99d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRGeometry::IsValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if the geometry is valid. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a4df68924f3b41fd377c5b4aa6631a00b" title="Test if the geometry is valid. ">OGR_G_IsValid()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always return FALSE.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the geometry has no points, otherwise FALSE. </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRCircularString.html#a540c540f8454d5c6726969caf3e8f904">OGRCircularString</a>.</p>

</div>
</div>
<a class="anchor" id="ab68dd71d373d3d8fd783e2d064351925"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OGRGeometry::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if two geometries are different. </p>

</div>
</div>
<a class="anchor" id="a9b21bad341ab030e749aa88f2bef5c99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> &amp; OGRGeometry::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>Note: before GDAL 2.1, only the default implementation of the operator existed, which could be unsafe to use.</p>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

</div>
</div>
<a class="anchor" id="ae4812c3a99ddd446c306140bfebb02d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OGRGeometry::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if two geometries are equal. </p>

</div>
</div>
<a class="anchor" id="afc672c524568f3ee6ee5257b250d2b12"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRGeometry::Overlaps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test for overlap. </p>
<p>Tests if this geometry and the other passed into the method overlap, that is their intersection has a non-zero area.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call <a class="el" href="classOGRGeometry.html#a7bbb194937466a6127b5436ac2ae99d9" title="Test if the geometry is valid. ">IsValid()</a> before, otherwise the result might be wrong.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a07acfe1bef39cd2cd1ad4a5ec26f2ceb" title="Test for overlap. ">OGR_G_Overlaps()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOtherGeom</td><td>the geometry to compare to this geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if they are overlapping, otherwise FALSE. </dd></dl>

</div>
</div>
<a class="anchor" id="a5524faa1746d9b6646ce5c6f28d31291"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::Polygonize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Polygonizes a set of sparse edges. </p>
<p>A new geometry object is created and returned containing a collection of reassembled Polygons: NULL will be returned if the input collection doesn't corresponds to a MultiLinestring, or when reassembling Edges into Polygons is impossible due to topological inconsistencies.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ad7c6a082065407712ff865471ad7136f" title="Polygonizes a set of sparse edges. ">OGR_G_Polygonize()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated geometry now owned by the caller, or NULL on failure.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a91685bd7c0bdd67cd073a8b4da3c06a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::segmentize </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMaxLength</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the geometry such it has no segment longer then the given distance. </p>
<p>Add intermediate vertices to a geometry.</p>
<p>Interpolated points will have Z and M values (if needed) set to 0. Distance computation is performed in 2d only</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#ade9f08c8d63bc0e726cb20c201c86423" title="Modify the geometry such it has no segment longer then the given distance. ">OGR_G_Segmentize()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfMaxLength</td><td>the maximum distance between 2 points after segmentization</td></tr>
  </table>
  </dd>
</dl>
<p>This method modifies the geometry to add intermediate vertices if necessary so that the maximum length between 2 consecutive vertices is lower than dfMaxLength.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfMaxLength</td><td>maximum length between 2 consecutive vertices. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classOGRGeometryCollection.html#aa3dfea765e5d59542825a80d060af98e">OGRGeometryCollection</a>, <a class="el" href="classOGRCurvePolygon.html#a922d66445e62efa2199595821dfc3d44">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#ac55ba5da766a3adcd73d1664e516532c">OGRCompoundCurve</a>, <a class="el" href="classOGRCircularString.html#a699d38f5d172b803411aba9fcb8a10ef">OGRCircularString</a>, and <a class="el" href="classOGRSimpleCurve.html#a9241df908a32e3e6a89027797a730be1">OGRSimpleCurve</a>.</p>

</div>
</div>
<a class="anchor" id="ad4dc0ab8f5269e24faad26387e344913"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::set3D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td>
          <td class="paramname"><em>bIs3D</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add or remove the Z coordinate dimension. </p>
<p>This method adds or removes the explicit Z coordinate dimension. Removing the Z coordinate dimension of a geometry will remove any existing Z values. Adding the Z dimension to a geometry collection, a compound curve, a polygon, etc. will affect the children geometries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bIs3D</td><td>Should the geometry have a Z dimension, either TRUE or FALSE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRPolyhedralSurface.html#a83b3277b37d362cc0863e90174314610">OGRPolyhedralSurface</a>, <a class="el" href="classOGRGeometryCollection.html#aaa7c464bf1dd02bcfbe3d942b4398c05">OGRGeometryCollection</a>, <a class="el" href="classOGRCurvePolygon.html#afb4e059b5d4965304f795044910c8769">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#a110a942d747ec30dd1e0a43a74f642a8">OGRCompoundCurve</a>, and <a class="el" href="classOGRSimpleCurve.html#a77dd58c81f9e3bb2fe5882e437d85319">OGRSimpleCurve</a>.</p>

</div>
</div>
<a class="anchor" id="a79f84a2b948d511f28c47c47577dea49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::setCoordinateDimension </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nNewDimension</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the coordinate dimension. </p>
<p>This method sets the explicit coordinate dimension. Setting the coordinate dimension of a geometry to 2 should zero out any existing Z values. Setting the dimension of a geometry collection, a compound curve, a polygon, etc. will affect the children geometries. This will also remove the M dimension if present before this call.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000012">Deprecated:</a></b></dt><dd>use <a class="el" href="classOGRGeometry.html#ad4dc0ab8f5269e24faad26387e344913" title="Add or remove the Z coordinate dimension. ">set3D()</a> or <a class="el" href="classOGRGeometry.html#a5f1d7eea437838415a14f9dc54523857" title="Add or remove the M coordinate dimension. ">setMeasured()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nNewDimension</td><td>New coordinate dimension value, either 2 or 3. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classOGRPolyhedralSurface.html#a31f3c231a49f20332fdc5050883ac173">OGRPolyhedralSurface</a>, <a class="el" href="classOGRGeometryCollection.html#accce5440870d67ee44499cfa9045e1af">OGRGeometryCollection</a>, <a class="el" href="classOGRCurvePolygon.html#adf41d14265fdabd4b4ceb3d8c22341fa">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#a7a66c4c9a9f70fe0cf3ff1e587f54d85">OGRCompoundCurve</a>, <a class="el" href="classOGRSimpleCurve.html#a0002d7766820341a235cf339c515623d">OGRSimpleCurve</a>, and <a class="el" href="classOGRPoint.html#a7ca8c6afb50f61d5fbd4a9bdd04f65f6">OGRPoint</a>.</p>

</div>
</div>
<a class="anchor" id="a5f1d7eea437838415a14f9dc54523857"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::setMeasured </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td>
          <td class="paramname"><em>bIsMeasured</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add or remove the M coordinate dimension. </p>
<p>This method adds or removes the explicit M coordinate dimension. Removing the M coordinate dimension of a geometry will remove any existing M values. Adding the M dimension to a geometry collection, a compound curve, a polygon, etc. will affect the children geometries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bIsMeasured</td><td>Should the geometry have a M dimension, either TRUE or FALSE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRPolyhedralSurface.html#a2546d2dd69b3fb42eeecf78c9a54c542">OGRPolyhedralSurface</a>, <a class="el" href="classOGRGeometryCollection.html#a579b3b5efb71816115c68b90155df3b5">OGRGeometryCollection</a>, <a class="el" href="classOGRCurvePolygon.html#adf784aaad99c0878b5bc8f8e5a65c3b0">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#a2eebb511ed8a59fe3d6c08a804f55891">OGRCompoundCurve</a>, and <a class="el" href="classOGRSimpleCurve.html#a8f8630903d62298da0b82c403b4ba2df">OGRSimpleCurve</a>.</p>

</div>
</div>
<a class="anchor" id="acf92969a640cdd29c4c4eaacc95e6093"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::Simplify </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dTolerance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simplify the geometry. </p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#ae7727c1e3f1aea8740020a75d150b09c" title="Compute a simplified geometry. ">OGR_G_Simplify()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dTolerance</td><td>the distance tolerance for the simplification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the simplified geometry or NULL if an error occurs.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a0f4d7948332d9efd6548e1cf87bb6c8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::SimplifyPreserveTopology </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dTolerance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplify the geometry while preserving topology. </p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#a2393494229046406871c38e58ffaf156" title="Simplify the geometry while preserving topology. ">OGR_G_SimplifyPreserveTopology()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dTolerance</td><td>the distance tolerance for the simplification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the simplified geometry or NULL if an error occurs.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a3ffd51d4998a8e2ae422c69b6adf480a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::swapXY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap x and y coordinates. </p>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRPolyhedralSurface.html#a56b0ea1f8755897755fbc73bb328158b">OGRPolyhedralSurface</a>, <a class="el" href="classOGRGeometryCollection.html#a129ed0276ea145b66ce1da1a5a0c6b1e">OGRGeometryCollection</a>, <a class="el" href="classOGRCurvePolygon.html#a820f36b21407a7400b0af0a5d95b0e5e">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#a222976c0791c8fe47cb26efc245ff2e6">OGRCompoundCurve</a>, <a class="el" href="classOGRSimpleCurve.html#a2c243eb37885b8affd9f6c7cbd24ff7e">OGRSimpleCurve</a>, and <a class="el" href="classOGRPoint.html#a6598d91071a583dce1c462aa6f4778c4">OGRPoint</a>.</p>

</div>
</div>
<a class="anchor" id="a75d3ec339f9a96ce2c4c01f165ec78a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::SymDifference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute symmetric difference. </p>
<p>Generates a new geometry which is the symmetric difference of this geometry and the second geometry passed into the method.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call <a class="el" href="classOGRGeometry.html#a7bbb194937466a6127b5436ac2ae99d9" title="Test if the geometry is valid. ">IsValid()</a> before, otherwise the result might be wrong.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#af59305c5838b6118e2d3f57f919ae666" title="Compute symmetric difference. ">OGR_G_SymDifference()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOtherGeom</td><td>the other geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry representing the symmetric difference or NULL if the difference is empty or an error occurs.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a07a3f3726ec41a2579ccaadf34d109b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRCircularString.html">OGRCircularString</a>* OGRGeometry::toCircularString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRCircularString*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type. ">wkbFlatten(getGeometryType())</a> == wkbCircularString. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a113fa3d11cff7e5b6bf7ad802a24a7ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRCircularString.html">OGRCircularString</a>* OGRGeometry::toCircularString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRCircularString*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type. ">wkbFlatten(getGeometryType())</a> == wkbCircularString. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a60510a2c16c5735dc358bc2a19b1640d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRCompoundCurve.html">OGRCompoundCurve</a>* OGRGeometry::toCompoundCurve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRCompoundCurve*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type. ">wkbFlatten(getGeometryType())</a> == wkbCompoundCurve. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a39096a050094cf38bb1a1fa79841f865"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRCompoundCurve.html">OGRCompoundCurve</a>* OGRGeometry::toCompoundCurve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRCompoundCurve*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type. ">wkbFlatten(getGeometryType())</a> == wkbCompoundCurve. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="ace2d0dbea86042310b29903dd69ed8fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRCurve.html">OGRCurve</a>* OGRGeometry::toCurve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRCurve*. </p>
<p>Implies prior checking that OGR_GT_IsSubClass(getGeometryType(), wkbCurve). </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a48dc561332dd021bf0683a9c684a7eec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRCurve.html">OGRCurve</a>* OGRGeometry::toCurve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRCurve*. </p>
<p>Implies prior checking that OGR_GT_IsSubClass(getGeometryType(), wkbCurve). </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a2307d44f31cc898ecbc2c8349bbc82f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRCurvePolygon.html">OGRCurvePolygon</a>* OGRGeometry::toCurvePolygon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRCurvePolygon*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type. ">wkbFlatten(getGeometryType())</a> == wkbCurvePolygon or wkbPolygon or wkbTriangle. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a3cb0ea3e90f84666dde9ce368dd66aee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRCurvePolygon.html">OGRCurvePolygon</a>* OGRGeometry::toCurvePolygon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRCurvePolygon*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type. ">wkbFlatten(getGeometryType())</a> == wkbCurvePolygon or wkbPolygon or wkbTriangle. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a9fdf3c79104eb641260abcc2b4a7cc43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometryCollection.html">OGRGeometryCollection</a>* OGRGeometry::toGeometryCollection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRGeometryCollection*. </p>
<p>Implies prior checking that OGR_GT_IsSubClass(getGeometryType(), wkbGeometryCollection). </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a0d8388899647dc245571be497d86f7ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRGeometryCollection.html">OGRGeometryCollection</a>* OGRGeometry::toGeometryCollection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRGeometryCollection*. </p>
<p>Implies prior checking that OGR_GT_IsSubClass(getGeometryType(), wkbGeometryCollection). </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="ae518798c9e80bad59b0907f43d375876"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGRGeometry::ToHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a OGRGeometry* to a OGRGeometryH. </p>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a087c768a91d977f065caa4f7b75e71b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRLinearRing.html">OGRLinearRing</a>* OGRGeometry::toLinearRing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRLinearRing*. </p>
<p>Implies prior checking that EQUAL(<a class="el" href="classOGRGeometry.html#aba109e1c53ce1452942f85eae66d88b8" title="Fetch WKT name for geometry type. ">getGeometryName()</a>, "LINEARRING"). </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="ae149295a0427b80cc0f780cf71c84cc9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRLinearRing.html">OGRLinearRing</a>* OGRGeometry::toLinearRing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRLinearRing*. </p>
<p>Implies prior checking that EQUAL(<a class="el" href="classOGRGeometry.html#aba109e1c53ce1452942f85eae66d88b8" title="Fetch WKT name for geometry type. ">getGeometryName()</a>, "LINEARRING"). </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a0bd4fd93ce3b53eb809d72b301bf6a6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRLineString.html">OGRLineString</a>* OGRGeometry::toLineString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRLineString*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type. ">wkbFlatten(getGeometryType())</a> == wkbLineString. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a970cf339912ecb4666a4573bb2da5e15"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRLineString.html">OGRLineString</a>* OGRGeometry::toLineString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRLineString*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type. ">wkbFlatten(getGeometryType())</a> == wkbLineString. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a8345d52f5748268059f485790ad8b3a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRMultiCurve.html">OGRMultiCurve</a>* OGRGeometry::toMultiCurve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRMultiCurve*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type. ">wkbFlatten(getGeometryType())</a> == wkbMultiCurve and derived types. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="ab6f8913f5460bfae2b0c7115e36a453d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRMultiCurve.html">OGRMultiCurve</a>* OGRGeometry::toMultiCurve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRMultiCurve*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type. ">wkbFlatten(getGeometryType())</a> == wkbMultiCurve and derived types. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a4a79860e0f5a7f7e1962a0854d140f6d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRMultiLineString.html">OGRMultiLineString</a>* OGRGeometry::toMultiLineString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRMultiLineString*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type. ">wkbFlatten(getGeometryType())</a> == wkbMultiLineString. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a464cb74217f911b0010ea716e38b9283"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRMultiLineString.html">OGRMultiLineString</a>* OGRGeometry::toMultiLineString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRMultiLineString*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type. ">wkbFlatten(getGeometryType())</a> == wkbMultiLineString. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="ab7cd71af4f5c75ac0b9ccd64bd4b1117"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRMultiPoint.html">OGRMultiPoint</a>* OGRGeometry::toMultiPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRMultiPoint*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type. ">wkbFlatten(getGeometryType())</a> == wkbMultiPoint. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a5a701f30ec2d0c16777c7f474d061136"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRMultiPoint.html">OGRMultiPoint</a>* OGRGeometry::toMultiPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRMultiPoint*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type. ">wkbFlatten(getGeometryType())</a> == wkbMultiPoint. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a07e387baec4de093ff6af3ec7ad76cbe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRMultiPolygon.html">OGRMultiPolygon</a>* OGRGeometry::toMultiPolygon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRMultiPolygon*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type. ">wkbFlatten(getGeometryType())</a> == wkbMultiPolygon. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a5e7707556b46a83af4f810b8c771f5a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRMultiPolygon.html">OGRMultiPolygon</a>* OGRGeometry::toMultiPolygon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRMultiPolygon*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type. ">wkbFlatten(getGeometryType())</a> == wkbMultiPolygon. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a93bfa0ab44ce276ef9666724856c40cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRMultiSurface.html">OGRMultiSurface</a>* OGRGeometry::toMultiSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRMultiSurface*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type. ">wkbFlatten(getGeometryType())</a> == wkbMultiSurface and derived types. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a4389f17ac17f6f0749defc80bfdb91ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRMultiSurface.html">OGRMultiSurface</a>* OGRGeometry::toMultiSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRMultiSurface*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type. ">wkbFlatten(getGeometryType())</a> == wkbMultiSurface and derived types. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="acd2a41d2ee7091a39fc3f371db9e3825"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRPoint.html">OGRPoint</a>* OGRGeometry::toPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRPoint*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type. ">wkbFlatten(getGeometryType())</a> == wkbPoint. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="ab18d20e8db1e512491045e3fa741d9b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRPoint.html">OGRPoint</a>* OGRGeometry::toPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRPoint*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type. ">wkbFlatten(getGeometryType())</a> == wkbPoint. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a27dff1a7736b53eb4d98c9176059fb80"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRPolygon.html">OGRPolygon</a>* OGRGeometry::toPolygon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRPolygon*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type. ">wkbFlatten(getGeometryType())</a> == wkbPolygon or wkbTriangle. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="aef3e5a36deb6295c572f779817f5d3f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRPolygon.html">OGRPolygon</a>* OGRGeometry::toPolygon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRPolygon*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type. ">wkbFlatten(getGeometryType())</a> == wkbPolygon or wkbTriangle. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a4d1990bb40f7ef045f9f9e796883591b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRPolyhedralSurface.html">OGRPolyhedralSurface</a>* OGRGeometry::toPolyhedralSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRPolyhedralSurface*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type. ">wkbFlatten(getGeometryType())</a> == wkbPolyhedralSurface or wkbTIN. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a0c7652b5480bd90dcc2849a06a665e6b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRPolyhedralSurface.html">OGRPolyhedralSurface</a>* OGRGeometry::toPolyhedralSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRPolyhedralSurface*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type. ">wkbFlatten(getGeometryType())</a> == wkbPolyhedralSurface or wkbTIN. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a12124534e4e04cece366a244b13faf3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRSimpleCurve.html">OGRSimpleCurve</a>* OGRGeometry::toSimpleCurve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRSimpleCurve*. </p>
<p>Implies prior checking that <a class="el" href="classOGRGeometry.html#a5c6bca18682cb933e3227552d480e1a5" title="Fetch geometry type. ">getGeometryType()</a> is wkbLineString, wkbCircularString or a derived type. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="aab16930d1b8022fb1ef02cbed2961ad9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRSimpleCurve.html">OGRSimpleCurve</a>* OGRGeometry::toSimpleCurve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRSimpleCurve*. </p>
<p>Implies prior checking that <a class="el" href="classOGRGeometry.html#a5c6bca18682cb933e3227552d480e1a5" title="Fetch geometry type. ">getGeometryType()</a> is wkbLineString, wkbCircularString or a derived type. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="ab897e836fd4781637a34014833b1ee3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRSurface.html">OGRSurface</a>* OGRGeometry::toSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRSurface*. </p>
<p>Implies prior checking that OGR_GT_IsSubClass(getGeometryType(), wkbSurface). </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="af593a23539c6c37ae200d493bd856c63"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRSurface.html">OGRSurface</a>* OGRGeometry::toSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRSurface*. </p>
<p>Implies prior checking that OGR_GT_IsSubClass(getGeometryType(), wkbSurface). </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="aa62fb2faaa7fe58555a39509a5ef2714"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRTriangle.html">OGRTriangle</a>* OGRGeometry::toTriangle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRTriangle*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type. ">wkbFlatten(getGeometryType())</a> == wkbTriangle. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a7870518064bf89ee2e3a2067ab80acd9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRTriangle.html">OGRTriangle</a>* OGRGeometry::toTriangle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRTriangle*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type. ">wkbFlatten(getGeometryType())</a> == wkbTriangle. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a46bef33c21122557417dd57517421201"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRTriangulatedSurface.html">OGRTriangulatedSurface</a>* OGRGeometry::toTriangulatedSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRTriangulatedSurface*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type. ">wkbFlatten(getGeometryType())</a> == wkbTIN. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a6b17907427dfd40be51cb367d1b19f8d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRTriangulatedSurface.html">OGRTriangulatedSurface</a>* OGRGeometry::toTriangulatedSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRTriangulatedSurface*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type. ">wkbFlatten(getGeometryType())</a> == wkbTIN. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="a5d3e23c20b51ceb5a56d397f812a81a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRGeometry::Touches </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test for touching. </p>
<p>Tests if this geometry and the other passed into the method are touching.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call <a class="el" href="classOGRGeometry.html#a7bbb194937466a6127b5436ac2ae99d9" title="Test if the geometry is valid. ">IsValid()</a> before, otherwise the result might be wrong.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a6f67616eb88f479eba50f9783c8494d9" title="Test for touching. ">OGR_G_Touches()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOtherGeom</td><td>the geometry to compare to this geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if they are touching, otherwise FALSE. </dd></dl>

</div>
</div>
<a class="anchor" id="aa9e8bfb3c2129f25cf622660f734e1ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRGeometry::transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRCoordinateTransformation.html">OGRCoordinateTransformation</a> *&#160;</td>
          <td class="paramname"><em>poCT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply arbitrary coordinate transformation to geometry. </p>
<p>This method will transform the coordinates of a geometry from their current spatial reference system to a new target spatial reference system. Normally this means reprojecting the vectors, but it could include datum shifts, and changes of units.</p>
<p>Note that this method does not require that the geometry already have a spatial reference system. It will be assumed that they can be treated as having the source spatial reference system of the <a class="el" href="classOGRCoordinateTransformation.html" title="Interface for transforming between coordinate systems. ">OGRCoordinateTransformation</a> object, and the actual SRS of the geometry will be ignored. On successful completion the output <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a> of the <a class="el" href="classOGRCoordinateTransformation.html" title="Interface for transforming between coordinate systems. ">OGRCoordinateTransformation</a> will be assigned to the geometry.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a59a5b3f954b11cfbf6e78807c28d6090" title="Apply arbitrary coordinate transformation to geometry. ">OGR_G_Transform()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poCT</td><td>the transformation to apply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or an error code. </dd></dl>

<p>Implemented in <a class="el" href="classOGRPolyhedralSurface.html#aa8ba9e1bc7f4f8ddd50634b095ffa441">OGRPolyhedralSurface</a>, <a class="el" href="classOGRGeometryCollection.html#ad5f7ae4a8937b11450277f22ba599af2">OGRGeometryCollection</a>, <a class="el" href="classOGRCurvePolygon.html#a6c14e71640ee125335023f2f0124aecc">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#ae3c157dbef9191d4f1c8cf00e2c133b9">OGRCompoundCurve</a>, <a class="el" href="classOGRLinearRing.html#a969a7a442a3ae16f1e042e5413113509">OGRLinearRing</a>, <a class="el" href="classOGRSimpleCurve.html#aaccfa682c2fa499d3613fc5980d881a7">OGRSimpleCurve</a>, and <a class="el" href="classOGRPoint.html#a620731c7abab289a7b109c4ea8c39fe0">OGRPoint</a>.</p>

</div>
</div>
<a class="anchor" id="ae3f0b441fbf2f66ce3ef3571268ab10f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRGeometry::transformTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&#160;</td>
          <td class="paramname"><em>poSR</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform geometry to new spatial reference system. </p>
<p>This method will transform the coordinates of a geometry from their current spatial reference system to a new target spatial reference system. Normally this means reprojecting the vectors, but it could include datum shifts, and changes of units.</p>
<p>This method will only work if the geometry already has an assigned spatial reference system, and if it is transformable to the target coordinate system.</p>
<p>Because this method requires internal creation and initialization of an <a class="el" href="classOGRCoordinateTransformation.html" title="Interface for transforming between coordinate systems. ">OGRCoordinateTransformation</a> object it is significantly more expensive to use this method to transform many geometries than it is to create the <a class="el" href="classOGRCoordinateTransformation.html" title="Interface for transforming between coordinate systems. ">OGRCoordinateTransformation</a> in advance, and call <a class="el" href="classOGRGeometry.html#aa9e8bfb3c2129f25cf622660f734e1ba" title="Apply arbitrary coordinate transformation to geometry. ">transform()</a> with that transformation. This method exists primarily for convenience when only transforming a single geometry.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a43af4c2127cea0a5059692a62c0feb63" title="Transform geometry to new spatial reference system. ">OGR_G_TransformTo()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poSR</td><td>spatial reference system to transform to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success, or an error code. </dd></dl>

</div>
</div>
<a class="anchor" id="a939bb2b738337a3af1fc715187822171"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::Union </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute union. </p>
<p>Generates a new geometry which is the region of union of the two geometries operated on.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call <a class="el" href="classOGRGeometry.html#a7bbb194937466a6127b5436ac2ae99d9" title="Test if the geometry is valid. ">IsValid()</a> before, otherwise the result might be wrong.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a59a695a0e26f4992ba58d79eac92ed25" title="Compute union. ">OGR_G_Union()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOtherGeom</td><td>the other geometry unioned with "this" geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry representing the union or NULL if an error occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="a3413bfa82a0afc6b5fa77fafa3933549"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::UnionCascaded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute union using cascading. </p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call <a class="el" href="classOGRGeometry.html#a7bbb194937466a6127b5436ac2ae99d9" title="Test if the geometry is valid. ">IsValid()</a> before, otherwise the result might be wrong.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ad6a2be7e6f0e16a18df2d0d54f55554f" title="Compute union using cascading. ">OGR_G_UnionCascaded()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="section return"><dt>Returns</dt><dd>a new geometry representing the union or NULL if an error occurs.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 </dd></dl>

</div>
</div>
<a class="anchor" id="abb4bb4687de9b6f23e61b686177b2856"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRGeometry::Within </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test for containment. </p>
<p>Tests if actual geometry object is within the passed geometry.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call <a class="el" href="classOGRGeometry.html#a7bbb194937466a6127b5436ac2ae99d9" title="Test if the geometry is valid. ">IsValid()</a> before, otherwise the result might be wrong.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a80ba9e516ccae381ae7240cc9684eb72" title="Test for containment. ">OGR_G_Within()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOtherGeom</td><td>the geometry to compare to this geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if poOtherGeom is within this geometry, otherwise FALSE. </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRPoint.html#a6d60b7f1e06f837425e598ddc47443a8">OGRPoint</a>.</p>

</div>
</div>
<a class="anchor" id="acd1a8164dae2e44e50990756ed6b8b4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OGRGeometry::WkbSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns size of related binary representation. </p>
<p>This method returns the exact number of bytes required to hold the well known binary representation of this geometry object. Its computation may be slightly expensive for complex geometries.</p>
<p>This method relates to the SFCOM IWks::WkbSize() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a5f7035a933b957a9d453184c154c237c" title="Returns size of related binary representation. ">OGR_G_WkbSize()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>size of binary representation in bytes. </dd></dl>

<p>Implemented in <a class="el" href="classOGRPolyhedralSurface.html#a58b01470ec0a2a1fdcbacf962c9d151e">OGRPolyhedralSurface</a>, <a class="el" href="classOGRGeometryCollection.html#a7cf2c7c719b618aafaf2691b4a29be45">OGRGeometryCollection</a>, <a class="el" href="classOGRPolygon.html#a870e53c42491570099c5e24954b14158">OGRPolygon</a>, <a class="el" href="classOGRCurvePolygon.html#ac114fecb74bbb173785cc011f40b4835">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#a460cf90bb5af4171b4efd55ab1cf089a">OGRCompoundCurve</a>, <a class="el" href="classOGRLinearRing.html#a0ce47cbe7328cb2f198089cc7f0ff73f">OGRLinearRing</a>, <a class="el" href="classOGRSimpleCurve.html#a46985b0653ea6439ddf5fbc785d2096b">OGRSimpleCurve</a>, and <a class="el" href="classOGRPoint.html#a77dc2aa7de13606464d4974ffd343d5e">OGRPoint</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="ogr__geometry_8h_source.html">ogr_geometry.h</a></li>
<li>ogrgeometry.cpp</li>
</ul>
</div><!-- contents -->
<hr>
Generated for GDAL by
<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.8.8.
</body>
</html>
